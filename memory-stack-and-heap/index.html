<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>操作系统-存储空间和堆栈 | Shuzang's Blog</title><meta name=Description content="书藏的个人博客，包括Golang、数据结构、算法的学习记录，各类生活技能的学习，每周五发布一期自己的生活周刊"><meta property="og:title" content="操作系统-存储空间和堆栈"><meta property="og:description" content="本节介绍计算机堆栈的概念，并顺便介绍计算机存储空间。"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/memory-stack-and-heap/"><meta property="article:published_time" content="2020-07-12T09:22:00+08:00"><meta property="article:modified_time" content="2020-07-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="操作系统-存储空间和堆栈"><meta name=twitter:description content="本节介绍计算机堆栈的概念，并顺便介绍计算机存储空间。"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=canonical href=https://shuzang.github.io/memory-stack-and-heap/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=prev href=https://shuzang.github.io/http-and-https/><link rel=next href=https://shuzang.github.io/mysql-learning-7-view-and-index/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/css/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"操作系统-存储空间和堆栈","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/memory-stack-and-heap\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"操作系统, Golang","wordcount":4336,"url":"https:\/\/shuzang.github.io\/memory-stack-and-heap\/","datePublished":"2020-07-12T09:22:00\x2b08:00","dateModified":"2020-07-12T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script></head><body><script>if(!window.localStorage||!window.localStorage.getItem('theme')){window.isDark=window.matchMedia('(prefers-color-scheme: dark)').matches;}else{window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';}
window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class="header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch title="Switch Theme">
<i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></header><header class=mobile id=header-mobile><div class=header-wrapper><div class=header-container><div class="header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch title="Switch Theme">
<i class="fas fa-adjust fa-rotate-180 fa-fw"></i></a></div></div></header><script>window.desktopHeaderMode="fixed";window.mobileHeaderMode="auto";</script><main class=main><div class=container><article class="page single"><h1 class="single-title animated flipInX">操作系统-存储空间和堆栈</h1><div class=meta><div class=meta-line><a class=author href=https://shuzang.github.io/about/ rel=author target=_blank><i class="fas fa-user-circle fa-fw"></i>shuzang
</a>&nbsp;<span class=post-category>included in&nbsp;<i class="far fa-folder fa-fw"></i><a href=https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=meta-line><i class="far fa-calendar-alt fa-fw"></i><time datetime=2020-07-12>2020-07-12</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 4336 words&nbsp;
<i class="far fa-clock fa-fw"></i>9 min&nbsp;</div></div><aside class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1-存储器组织>1. 存储器组织</a><ul><li><a href=#11-存储单元>1.1 存储单元</a></li><li><a href=#12-地址>1.2 地址</a></li></ul></li><li><a href=#2-虚拟地址空间>2. 虚拟地址空间</a></li><li><a href=#3-堆栈>3. 堆栈</a></li><li><a href=#4-go跟踪堆栈>4. Go跟踪堆栈</a></li><li><a href=#参考>参考</a></li></ul></nav></div></aside><aside class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#1-存储器组织>1. 存储器组织</a><ul><li><a href=#11-存储单元>1.1 存储单元</a></li><li><a href=#12-地址>1.2 地址</a></li></ul></li><li><a href=#2-虚拟地址空间>2. 虚拟地址空间</a></li><li><a href=#3-堆栈>3. 堆栈</a></li><li><a href=#4-go跟踪堆栈>4. Go跟踪堆栈</a></li><li><a href=#参考>参考</a></li></ul></nav></div></details></aside><div class=content><p>本节介绍计算机堆栈的概念，并顺便介绍计算机存储空间。</p><h2 id=1-存储器组织>1. 存储器组织</h2><p>关于计算机存储器组织的相关问题，在汇编的课程中。</p><p>尽管现在计算机采用 Cache—主存—辅存 的三级结构，但为了解释起来简单，我们将前两者统称为主存。主存的物理实体就是我们常说的内存条（事实上还有一些其它的存储器），主要作用是保存正在运行的指令与数据，注意，这里的关键是<strong>正在运行</strong>，这也意味着计算机关机后主存数据将会被清除，这一点也是主存与外存的区别。</p><p>计算机运行时会不断地执行各种指令，指令从主存中读取，执行指令过程中需要的数据也从主存读取，这里读取的含义其实是取数据副本，在新的数据写入前，原本的数据不会被主动擦除。因此，与存储器相关的最基本的操作是写入和读出数据，完成这一工作我们首先需要对主存进行编址，这样才能在需要时找到对应的指令和数据。</p><h3 id=11-存储单元>1.1 存储单元</h3><p>现代计算机系统存储的基本单位是一个二进制位（bit，比特），每位可存储一个二进制数 0 或 1，一般用小写字母 b 表示。8 个二进制位组成一个字节（Byte），用大写字母 B 表示。</p><p>对主存进行编址时，其基本单位叫做存储单元，为每一个存储单元分配一个顺序号码，就是该存储单元的地址。现代计算机一个存储单元一般就是一个字节，称为字节编址（Byte Addressable），所以，通过任何一个存储器地址可以访问到一个字节的信息。主存的总容量就是这些存储单元的集合，为了表达比字节更大的存储空间，人们分配了一些常用的单位，如下表</p><table><thead><tr><th>英文符号</th><th>中英文名称</th><th>二进制倍数关系</th></tr></thead><tbody><tr><td>K</td><td>千（Kilo）</td><td>1KB=$2^{10}B$=1024B</td></tr><tr><td>M</td><td>兆（Mega）</td><td>1MB=$2^{10}KB$=$2^{20}B$</td></tr><tr><td>G</td><td>千兆，吉（Giga）</td><td>1GB=$2^{10}MB$=$2^{30}B$</td></tr><tr><td>T</td><td>兆兆，太（Tera）</td><td>1TB=$2^{10}GB$=$2^{40}B$</td></tr></tbody></table><h3 id=12-地址>1.2 地址</h3><p>明白了编址方式，我们还需要明白CPU如何访问主存，在物理上，CPU通过总线来访问主存。总线分为三种：地址总线，数据总线和控制总线，分别用来传输数据地址、数据和控制信号。所以，与寻址相关的是地址总线，直接决定了计算机可直接寻址的空间大小。</p><p>最初的8位机地址总线为16位，可寻址空间最大 64KB。16位机地址总线20位，可寻址空间最大1MB。32位机的地址总线也是32位，可寻址的空间上限就只有 $2^{32}B = 4GB$，所以一个32位计算机最大只支持4GB的内存。现在计算机普遍都是64位，采用地址总线位数暂时不太清楚，不过，所支持的最大内存通常是128G，足以满足我们的需要。</p><p>主存地址的编号习惯上用十六进制数表达，一个4GB 的内存对应二进制的32位，1个16进制数是4位，所以可以用8位十六进制数表达一个 4GB 的内存的物理空间：00000000H~FFFFFFFFH</p><p>但是，计算机的寄存器通常是16位的，可以表达的存储大小上限为 64KB（$2^{16}B$），于是，计算机会将主存分成许多不超过 64KB 的区域进行管理，这种区域被称为（区）段（Segment），计算机原理和程序设计中也常被称为逻辑段。所以，计算机的寻址在逻辑上实际上是两级的，先在主存中找到逻辑段的地址（叫做段基地址），然后以段基地址为起点，偏移一定的量找到指令或数据（这个偏移量叫做偏移地址）。</p><p>最后，根据所存数据类型的不同，计算机设计了4种类型的逻辑段，有4个段寄存器分别保存对应段的段基地址，如下表</p><table><thead><tr><th>段名称</th><th>段的作用</th><th>段基地址</th><th>偏移地址</th></tr></thead><tbody><tr><td>代码段</td><td>存放程序的指令序列</td><td>CS</td><td>IP</td></tr><tr><td>堆栈段</td><td>确定堆栈所在的主存区域</td><td>SS</td><td>SP</td></tr><tr><td>数据段</td><td>存放当前运行程序所用的数据</td><td>DS</td><td>EA</td></tr><tr><td>附加段</td><td>附加的数据段，也用于保存数据</td><td>ES</td><td>EA</td></tr></tbody></table><p>程序的指令代码必须存放在代码段，否则将无法正常执行。程序利用代码段寄存器 CS获得当前代码段的段基地址，指令指针寄存器IP保存代码段中指令的偏移地址。处理器利用CS:IP取得下一条要执行的指令。</p><p>程序使用的堆栈（临时存放数据的区域）一定在堆栈段。程序利用SS获得当前堆栈段的段基地址，堆栈指针寄存器SP保存堆栈栈顶的偏移地址。处理器利用SS:SP操作堆栈数据。</p><p>一个程序可以使用多个数据段，便于安全有效地访问不同类型的数据。例如，程序的主要数据存放在一个数据段，只读的数据存放在另一个数据段，动态分配的数据安排在第3个数据段。</p><p>段基地址的低4位均为0，因为一个段最大不超过64KB，下面是一个分段管理的简单例子</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/images/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f-%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4%e4%b8%8e%e5%a0%86%e6%a0%88/epub_773370_14.jpg alt class=lazyload></figure></p><p>注：上述的讨论基本都是基于8086，64位机不是很清楚内部机理，主要因为现有的教材基本都是介绍的8086。但是已知的，64位系统的寄存器是64位的。</p><h2 id=2-虚拟地址空间>2. 虚拟地址空间</h2><p>这部分知识位于操作系统课程。</p><p>一个进程的执行过程中，大部分的程序和数据并不经常访问，所以被放到外存中，需要时才会调入内存。用户编写的程序，在编译后才能形成 CPU 可执行的目标代码，显然，不同程序段的目标代码会有不同的地址。</p><p>有两种办法安排这些目标代码的地址，一种是按照前面所述的寻址方式赋予实际的物理地址，这样做的好处是CPU执行目标代码时速度会比较快。但是，由于内存的容量限制，同时装入内存并发执行的进程数量必然会受到极大的限制，甚至对于某些进程，当所需求的容量超过内存容量，将会无法执行。另外，编译程序也必须知道内存当前的空闲部分的地址，并且把一个进程的不同程序段连续地存放起来，因此编译程序将比较复杂。</p><p>另一种方法是编译链接程序将用户源程序编译后链接到一个以 0 为起始地址的虚拟地址空间，每个进程都拥有这样一个空间，每个指令或数据单元都在该空间中有个确定的地址，称为虚拟地址。最后通过设定虚拟地址到物理地址的转换方式，计算机同样可以访问目标指令和数据。</p><p>每个进程的虚拟地址空间也成为进程空间或虚空间，不受物理存储器的限制，只与计算机位数有关。例如，16位计算机进程空间大小为 $2^{16}$，64位计算机进程空间大小为 $2^{64}$。程序的执行都在进程空间内进行，用户程序、进程的各种控制表格等都按一定的结构排列在进程空间中。</p><p>对于 UNIX 和 Linux 等操作系统，进程空间还被划分为用户空间和系统空间两部分，用户程序在用户空间执行，操作系统内核程序在系统空间执行。另外，为了防止用户程序访问系统空间，造成错误，计算机系统还通过程序状态寄存器设置了用户模式和系统模式两种执行模式，这两种模式通常也被称为用户态和系统态。</p><p>网上的一些文章通常把用户空间叫做内核空间，下面是一个32位系统的Linux进程空间示意图，其中0-3G被划分为用户空间，3-4G被划分为内核空间。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/images/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f-%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4%e4%b8%8e%e5%a0%86%e6%a0%88/091011_1614_Linux2.png alt class=lazyload></figure></p><h2 id=3-堆栈>3. 堆栈</h2><p>数据结构中栈满足后入先出的特性，在计算机系统中，也有一块满足该特性的动态内存区域，程序可以将数据压入栈中已经将数据从栈中弹出，从而使栈动态的增大或减小。通常，栈是向下增长的，即入栈操作使得栈顶地址减小，出栈操作使得栈顶地址增加。</p><p>除此之外，堆也是计算机中的一中内存区域。堆与栈的区别如下</p><ol><li>栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放</li><li>栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量，实际上，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面</li><li>栈的访问速度相对比堆快</li><li>一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。</li><li>stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。</li></ol><p>在C/C++中，程序员申请的内存空间使用完毕后需要自己释放，在Java、Go等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。</p><h2 id=4-go跟踪堆栈>4. Go跟踪堆栈</h2><p>我们理解堆栈主要是为了更好的理解程序，所以，这里介绍如何在Go调试的时候查看堆栈跟踪信息及识别传递的参数。</p><p>测试使用的版本是Go 1.14.3</p><p>示例程序如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
	<span class=s>&#34;runtime/debug&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>slice</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
	<span class=nf>Example</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=s>&#34;hello&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=nf>Example</span><span class=p>(</span><span class=nx>slice</span> <span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>str</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>debug</span><span class=p>.</span><span class=nf>PrintStack</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>在程序中我们使用了 runtime/debug 下的 PrintStack() 函数将调用栈的返回信息打印到标准错误输出，如下所示</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>goroutine</span> <span class=mi>1</span> <span class=p>[</span><span class=nx>running</span><span class=p>]</span><span class=p>:</span>
<span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=p>.</span><span class=nf>Stack</span><span class=p>(</span><span class=mh>0x0</span><span class=p>,</span> <span class=mh>0x0</span><span class=p>,</span> <span class=mh>0x0</span><span class=p>)</span>
	<span class=nx>c</span><span class=p>:</span><span class=o>/</span><span class=k>go</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=o>/</span><span class=nx>stack</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>24</span> <span class=o>+</span><span class=mh>0xa8</span>
<span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=p>.</span><span class=nf>PrintStack</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>c</span><span class=p>:</span><span class=o>/</span><span class=k>go</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=o>/</span><span class=nx>stack</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>16</span> <span class=o>+</span><span class=mh>0x29</span>
<span class=nx>main</span><span class=p>.</span><span class=nf>Example</span><span class=p>(</span><span class=mh>0xc000077f38</span><span class=p>,</span> <span class=mh>0x2</span><span class=p>,</span> <span class=mh>0x4</span><span class=p>,</span> <span class=mh>0x4a8534</span><span class=p>,</span> <span class=mh>0x5</span><span class=p>,</span> <span class=mh>0xa</span><span class=p>)</span>
	<span class=nx>f</span><span class=p>:</span><span class=o>/</span><span class=nx>Gotest</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>13</span> <span class=o>+</span><span class=mh>0x2e</span>
<span class=nx>main</span><span class=p>.</span><span class=nf>main</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>f</span><span class=p>:</span><span class=o>/</span><span class=nx>Gotest</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>9</span> <span class=o>+</span><span class=mh>0xb1</span>
<span class=nx>Process</span> <span class=nx>exiting</span> <span class=nx>with</span> <span class=nx>code</span><span class=p>:</span> <span class=mi>0</span>
</code></pre></td></tr></table></div></div><p>注意，在其它编程语言如C中，运行一个程序会启动一个线程来执行，在Go中，启动的是一个 Goroutine。上面第一行就说明了启动了一个 Goroutine，Goroutine ID 为1，其后各行是不同层次的调用，最深的调用最先打印，最浅的调用最后打印。各行说明如下</p><p>第8、9行：main package 的 main 函数，代码文件路径为 <code>f:/Gotest/main.go</code>，调用出现在 main.go 文件的第9行</p><p>第6、7行：main 函数调用 Example 函数</p><p>第4、5行：Example 函数调用 debug.PrintStack 函数</p><p>第2，3行：debug.PrintStack 函数调用 debug.Stack 函数</p><p>Example 函数传参信息如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 调用
</span><span class=c1></span><span class=nx>slice</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
<span class=nf>Example</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=s>&#34;hello&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
<span class=c1>// 栈追踪
</span><span class=c1></span><span class=nx>main</span><span class=p>.</span><span class=nf>Example</span><span class=p>(</span><span class=mh>0xc000077f38</span><span class=p>,</span> <span class=mh>0x2</span><span class=p>,</span> <span class=mh>0x4</span><span class=p>,</span> <span class=mh>0x4a8534</span><span class=p>,</span> <span class=mh>0x5</span><span class=p>,</span> <span class=mh>0xa</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>堆栈跟踪信息中，前三个参数分别代表切片的指针、长度、容量，第4和第5个参数代表字符串的指针和大小，最后一个参数指向整型数值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 切片
</span><span class=c1></span><span class=nx>Pointer</span><span class=p>:</span> <span class=mh>0xc000077f38</span>
<span class=nx>Length</span><span class=p>:</span> <span class=mh>0x2</span>
<span class=nx>Capacity</span><span class=p>:</span> <span class=mh>0x4</span>
<span class=c1>// 字符串
</span><span class=c1></span><span class=nx>Pointer</span><span class=p>:</span> <span class=mh>0x4a8534</span>
<span class=nx>Length</span><span class=p>:</span> <span class=mh>0x5</span>
<span class=c1>// 整数
</span><span class=c1></span><span class=nx>base</span> <span class=mi>16</span><span class=p>:</span> <span class=mh>0xa</span>
</code></pre></td></tr></table></div></div><p>如果是调用方法，跟踪信息会显示接收者</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 程序
</span><span class=c1></span><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
   <span class=s>&#34;fmt&#34;</span>
   <span class=s>&#34;runtime/debug&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>trace</span> <span class=kd>struct</span><span class=p>{</span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
   <span class=nx>slice</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
   <span class=kd>var</span> <span class=nx>t</span> <span class=nx>trace</span>
   <span class=nx>t</span><span class=p>.</span><span class=nf>Example</span><span class=p>(</span><span class=nx>slice</span><span class=p>,</span> <span class=s>&#34;hello&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>trace</span><span class=p>)</span> <span class=nf>Example</span><span class=p>(</span><span class=nx>slice</span> <span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>str</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
   <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Receiver Address: %p\n&#34;</span><span class=p>,</span> <span class=nx>t</span><span class=p>)</span>
   <span class=nx>debug</span><span class=p>.</span><span class=nf>PrintStack</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// 堆栈信息
</span><span class=c1></span><span class=nx>Receiver</span> <span class=nx>Address</span><span class=p>:</span> <span class=mh>0x5781c8</span>
<span class=nx>goroutine</span> <span class=mi>1</span> <span class=p>[</span><span class=nx>running</span><span class=p>]</span><span class=p>:</span>
<span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=p>.</span><span class=nf>Stack</span><span class=p>(</span><span class=mh>0x15</span><span class=p>,</span> <span class=mh>0xc000071ef0</span><span class=p>,</span> <span class=mh>0x1</span><span class=p>)</span>
	<span class=nx>C</span><span class=p>:</span><span class=o>/</span><span class=nx>Go</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=o>/</span><span class=nx>stack</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>24</span> <span class=o>+</span><span class=mh>0xae</span>
<span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=p>.</span><span class=nf>PrintStack</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>C</span><span class=p>:</span><span class=o>/</span><span class=nx>Go</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=o>/</span><span class=nx>stack</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>16</span> <span class=o>+</span><span class=mh>0x29</span>
<span class=nx>main</span><span class=p>.</span><span class=p>(</span><span class=o>*</span><span class=nx>trace</span><span class=p>)</span><span class=p>.</span><span class=nf>Example</span><span class=p>(</span><span class=mh>0x5781c8</span><span class=p>,</span> <span class=mh>0xc000071f48</span><span class=p>,</span> <span class=mh>0x2</span><span class=p>,</span> <span class=mh>0x4</span><span class=p>,</span> <span class=mh>0x4c04bb</span><span class=p>,</span> <span class=mh>0x5</span><span class=p>,</span> <span class=mh>0xa</span><span class=p>)</span>
	<span class=nx>D</span><span class=p>:</span><span class=o>/</span><span class=nx>gopath</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>17</span> <span class=o>+</span><span class=mh>0x7c</span>
<span class=nx>main</span><span class=p>.</span><span class=nf>main</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>D</span><span class=p>:</span><span class=o>/</span><span class=nx>gopath</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>13</span> <span class=o>+</span><span class=mh>0x9a</span>
</code></pre></td></tr></table></div></div><p>传递的参数全部为值类型时，可能会防止一个32位的字中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 程序
</span><span class=c1></span><span class=kn>import</span> <span class=p>(</span>
   <span class=s>&#34;runtime/debug&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
   <span class=nf>Example</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=mi>25</span><span class=p>)</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=nf>Example</span><span class=p>(</span><span class=nx>b1</span><span class=p>,</span> <span class=nx>b2</span><span class=p>,</span> <span class=nx>b3</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>i</span> <span class=kt>uint8</span><span class=p>)</span> <span class=p>{</span>

   <span class=nx>debug</span><span class=p>.</span><span class=nf>PrintStack</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// 堆栈信息
</span><span class=c1></span><span class=nx>goroutine</span> <span class=mi>1</span> <span class=p>[</span><span class=nx>running</span><span class=p>]</span><span class=p>:</span>
<span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=p>.</span><span class=nf>Stack</span><span class=p>(</span><span class=mh>0x4</span><span class=p>,</span> <span class=mh>0xc00007a010</span><span class=p>,</span> <span class=mh>0xc000077f88</span><span class=p>)</span>
	<span class=nx>C</span><span class=p>:</span><span class=o>/</span><span class=nx>Go</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=o>/</span><span class=nx>stack</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>24</span> <span class=o>+</span><span class=mh>0xae</span>
<span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=p>.</span><span class=nf>PrintStack</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>C</span><span class=p>:</span><span class=o>/</span><span class=nx>Go</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>runtime</span><span class=o>/</span><span class=nx>debug</span><span class=o>/</span><span class=nx>stack</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>16</span> <span class=o>+</span><span class=mh>0x29</span>
<span class=nx>main</span><span class=p>.</span><span class=nf>Example</span><span class=p>(</span><span class=mh>0xc019010001</span><span class=p>)</span>
	<span class=nx>D</span><span class=p>:</span><span class=o>/</span><span class=nx>gopath</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>12</span> <span class=o>+</span><span class=mh>0x27</span>
<span class=nx>main</span><span class=p>.</span><span class=nf>main</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>D</span><span class=p>:</span><span class=o>/</span><span class=nx>gopath</span><span class=o>/</span><span class=nx>src</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>example</span><span class=o>/</span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>8</span> <span class=o>+</span><span class=mh>0x30</span>
</code></pre></td></tr></table></div></div><p>可以看到 Example 的参数只有一个，实际上底层四个参数放在一个字中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Parameter values
</span><span class=c1></span><span class=kc>true</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=mi>25</span>

<span class=c1>// Word value
</span><span class=c1></span><span class=nx>Bits</span>    <span class=nx>Binary</span>      <span class=nx>Hex</span>   <span class=nx>Value</span>
<span class=mo>00</span><span class=o>-</span><span class=mo>07</span>   <span class=mo>0000</span> <span class=mo>0001</span>   <span class=mo>01</span>    <span class=kc>true</span>
<span class=mi>0</span><span class=mi>8</span><span class=o>-</span><span class=mi>15</span>   <span class=mo>0000</span> <span class=mo>0000</span>   <span class=mo>00</span>    <span class=kc>false</span>
<span class=mi>16</span><span class=o>-</span><span class=mi>23</span>   <span class=mo>0000</span> <span class=mo>0001</span>   <span class=mo>01</span>    <span class=kc>true</span>
<span class=mi>24</span><span class=o>-</span><span class=mi>31</span>   <span class=mo>0001</span> <span class=mi>1001</span>   <span class=mi>19</span>    <span class=mi>25</span>
</code></pre></td></tr></table></div></div><p>关于在Go中，变量究竟是放在堆还是栈里，官方有这么一段解释</p><blockquote><p>只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。</p><p>在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。</p><p>总之，分配在堆还是栈完全由编译器确定。</p></blockquote><p>通过 <code>go tool compile</code> 命令可以反编译代码为汇编代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>a</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=kt>int</span>
	<span class=nx>c</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=p>:</span><span class=p>]</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>反编译</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go tool compile -S main.go
...   
        0x0028 <span class=m>00040</span> <span class=o>(</span>main.go:6<span class=o>)</span>        PCDATA  <span class=nv>$0</span>, <span class=nv>$1</span>
        0x0028 <span class=m>00040</span> <span class=o>(</span>main.go:6<span class=o>)</span>        PCDATA  <span class=nv>$1</span>, <span class=nv>$0</span>
        0x0028 <span class=m>00040</span> <span class=o>(</span>main.go:6<span class=o>)</span>        LEAQ    type.<span class=o>[</span>1<span class=o>]</span>int<span class=o>(</span>SB<span class=o>)</span>, AX
        0x002f <span class=m>00047</span> <span class=o>(</span>main.go:6<span class=o>)</span>        PCDATA  <span class=nv>$0</span>, <span class=nv>$0</span>
        0x002f <span class=m>00047</span> <span class=o>(</span>main.go:6<span class=o>)</span>        MOVQ    AX, <span class=o>(</span>SP<span class=o>)</span>
        0x0033 <span class=m>00051</span> <span class=o>(</span>main.go:6<span class=o>)</span>        CALL    runtime.newobject<span class=o>(</span>SB<span class=o>)</span>
        0x0038 <span class=m>00056</span> <span class=o>(</span>main.go:6<span class=o>)</span>        PCDATA  <span class=nv>$0</span>, <span class=nv>$1</span>
        0x0038 <span class=m>00056</span> <span class=o>(</span>main.go:6<span class=o>)</span>        MOVQ    8<span class=o>(</span>SP<span class=o>)</span>, AX
        0x003d <span class=m>00061</span> <span class=o>(</span>main.go:8<span class=o>)</span>        PCDATA  <span class=nv>$0</span>, <span class=nv>$0</span>
        0x003d <span class=m>00061</span> <span class=o>(</span>main.go:8<span class=o>)</span>        MOVQ    AX, <span class=o>(</span>SP<span class=o>)</span>
        0x0041 <span class=m>00065</span> <span class=o>(</span>main.go:8<span class=o>)</span>        MOVQ    <span class=nv>$1</span>, 8<span class=o>(</span>SP<span class=o>)</span>
        0x004a <span class=m>00074</span> <span class=o>(</span>main.go:8<span class=o>)</span>        MOVQ    <span class=nv>$1</span>, 16<span class=o>(</span>SP<span class=o>)</span>
...
</code></pre></td></tr></table></div></div><p>其中有调用 runtime.newobject 就说明 main.go 第6行 的数组变量 a 分配在堆上。反之，如果没有发现 runtime.newobject 调用，就说明分配在栈上。</p><h2 id=参考>参考</h2><p>[1] <a href=https://segmentfault.com/a/1190000017498101 target=_blank>Go堆栈的理解</a></p><p>[2] 阮一峰，<a href=http://www.ruanyifeng.com/blog/2013/11/stack.html target=_blank>栈的三种含义</a></p><p>[3] <a href=https://golang.org/doc/faq target=_blank>官方关于变量分配在堆还是栈上的说明</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>The article was updated on 2020-07-12</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://shuzang.github.io/memory-stack-and-heap/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://shuzang.github.io/memory-stack-and-heap/ data-title=操作系统-存储空间和堆栈 data-hashtags=操作系统,Golang><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://shuzang.github.io/memory-stack-and-heap/ data-hashtag=操作系统><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Reddit" data-sharer=reddit data-url=https://shuzang.github.io/memory-stack-and-heap/><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/><i class="fas fa-tag fa-fw"></i>&nbsp;操作系统</a>&nbsp;
</span><span class=tag><a href=https://shuzang.github.io/tags/golang/><i class="fas fa-tag fa-fw"></i>&nbsp;Golang</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/http-and-https/ class=prev rel=prev title=HTTP与HTTPS协议><i class="fas fa-angle-left fa-fw"></i>HTTP与HTTPS协议</a>
<a href=https://shuzang.github.io/mysql-learning-7-view-and-index/ class=next rel=next title=Mysql学习7-视图与索引>Mysql学习7-视图与索引<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=comment><div id=disqus_thread></div><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><div id=valine></div><script>document.addEventListener("DOMContentLoaded",function(event){new Valine({el:'#valine',appId:'GteMvevTjOBmhvFh2QGsopGO-gzGzoHsz',appKey:'fL4SYl06GIe012PswFdY17VC',placeholder:'Your comment ...',verify:true,avatar:'hide',pageSize:10,lang:'en',visitor:true,recordIP:true,});});</script><noscript>Please enable JavaScript to view the <a href=https://valine.js.org/>comments powered by Valine.</a></noscript></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io/about/ target=_blank>shuzang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><a href=# class="dynamic-to-top animated faster" id=dynamic-to-top><span>&nbsp;</span>
</a><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><link href=https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css rel=stylesheet><link href=https://cdn.bootcss.com/KaTeX/0.11.1/contrib/copy-tex.css rel=stylesheet><link rel=stylesheet href=/css/lib/valine/dark.css><script src=https://dillonzq.disqus.com/embed.js></script><script src=https://cdn.bootcss.com/smooth-scroll/16.1.0/smooth-scroll.js></script><script src=https://cdn.bootcss.com/lazysizes/5.1.2/lazysizes.min.js></script><script src=https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js></script><script src=https://cdn.bootcss.com/KaTeX/0.11.1/contrib/auto-render.js></script><script src=https://cdn.bootcss.com/KaTeX/0.11.1/contrib/copy-tex.js></script><script src=https://cdn.bootcss.com/KaTeX/0.11.1/contrib/mhchem.js></script><script src=/js/lib/valine/Valine.min.js></script><script src=/js/lib/sharer/sharer.min.js></script><script src=/js/theme.min.js></script></body></html>