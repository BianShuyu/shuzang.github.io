<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Golang语法基础2-命令、包与模块 | Shuzang&#39;s Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="shuzang's personal blog"><link rel=prev href=https://shuzang.github.io/2019/09/%E8%80%81%E8%88%8D%E5%B9%BD%E9%BB%98%E5%B0%8F%E8%AF%B4/><link rel=next href=https://shuzang.github.io/2019/09/%E5%BA%9F%E5%90%8D%E7%94%B0%E5%9B%AD%E5%B0%8F%E8%AF%B4/><link rel=canonical href=https://shuzang.github.io/2019/09/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%91%BD%E4%BB%A4%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang语法基础2-命令、包与模块"><meta name=twitter:description content="本篇介绍Go中的基础命令，包和垃圾回收机制 1. 命令 Go在安装后自带一个命令行工具，名为go，用来下载、编译、安装、测试Go的包和源文件，关于G"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础2-命令、包与模块","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2019\/09\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%91%BD%E4%BB%A4%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Golang","wordcount":7860,"url":"https:\/\/shuzang.github.io\/2019\/09\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%802-%E5%91%BD%E4%BB%A4%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97\/","datePublished":"2019-09-19T00:00:00\x2b00:00","dateModified":"2019-09-19T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/css/lib/animate/animate.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=navbar-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">Golang语法基础2-命令、包与模块</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://shuzang.github.io rel=author target=_blank><i class="fas fa-user-circle fa-fw"></i>shuzang
</a>&nbsp;<span class=post-category>included in&nbsp;<i class="far fa-folder fa-fw"></i><a href=https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-09-19>2019-09-19</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 7860 words&nbsp;
<i class="far fa-clock fa-fw"></i>16 min&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#1-命令>1. 命令</a><ul><li><a href=#1-1-command>1.1 command</a><ul><li><a href=#go-version>go version</a></li><li><a href=#go-env>go env</a></li><li><a href=#go-build>go build</a></li><li><a href=#go-install>go install</a></li><li><a href=#go-get>go get</a></li><li><a href=#go-run>go run</a></li><li><a href=#其它>其它</a></li></ul></li><li><a href=#1-2-topic>1.2 topic</a></li></ul></li><li><a href=#2-包>2. 包</a><ul><li><a href=#2-1-包名>2.1 包名</a></li><li><a href=#2-2-标准库>2.2 标准库</a></li><li><a href=#2-3-导入包>2.3 导入包</a></li><li><a href=#2-4-使用脚本编译或安装>2.4 使用脚本编译或安装</a></li></ul></li><li><a href=#3-垃圾回收>3. 垃圾回收</a></li><li><a href=#4-go-mod>4. go mod</a><ul><li><a href=#4-1-创建新模块>4.1 创建新模块</a></li><li><a href=#4-2-添加依赖>4.2 添加依赖</a></li><li><a href=#4-3-更新依赖>4.3 更新依赖</a></li><li><a href=#4-4-在主版本号上添加依赖>4.4 在主版本号上添加依赖</a></li><li><a href=#4-5-更新依赖到新的主版本号>4.5 更新依赖到新的主版本号</a></li><li><a href=#4-6-移除不使用的依赖>4.6 移除不使用的依赖</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#1-命令>1. 命令</a><ul><li><a href=#1-1-command>1.1 command</a><ul><li><a href=#go-version>go version</a></li><li><a href=#go-env>go env</a></li><li><a href=#go-build>go build</a></li><li><a href=#go-install>go install</a></li><li><a href=#go-get>go get</a></li><li><a href=#go-run>go run</a></li><li><a href=#其它>其它</a></li></ul></li><li><a href=#1-2-topic>1.2 topic</a></li></ul></li><li><a href=#2-包>2. 包</a><ul><li><a href=#2-1-包名>2.1 包名</a></li><li><a href=#2-2-标准库>2.2 标准库</a></li><li><a href=#2-3-导入包>2.3 导入包</a></li><li><a href=#2-4-使用脚本编译或安装>2.4 使用脚本编译或安装</a></li></ul></li><li><a href=#3-垃圾回收>3. 垃圾回收</a></li><li><a href=#4-go-mod>4. go mod</a><ul><li><a href=#4-1-创建新模块>4.1 创建新模块</a></li><li><a href=#4-2-添加依赖>4.2 添加依赖</a></li><li><a href=#4-3-更新依赖>4.3 更新依赖</a></li><li><a href=#4-4-在主版本号上添加依赖>4.4 在主版本号上添加依赖</a></li><li><a href=#4-5-更新依赖到新的主版本号>4.5 更新依赖到新的主版本号</a></li><li><a href=#4-6-移除不使用的依赖>4.6 移除不使用的依赖</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><p>本篇介绍Go中的基础命令，包和垃圾回收机制</p><a class=post-dummy-target id=1-命令></a><h2>1. 命令</h2><p>Go在安装后自带一个命令行工具，名为<code>go</code>，用来下载、编译、安装、测试Go的包和源文件，关于Go CLI的发展历史和设计理念，可以查看<a href=https://golang.google.cn/doc/articles/go_command.html>About the go command</a>，这里只介绍如何使用这些命令。</p><p>我们之前已经接触过几种命令，包括查看环境变量的<code>go env</code>，查看go版本的<code>go version</code>，用于编译和安装的<code>go install</code>和<code>go build</code>，已经对它们有了一定的了解，这里继续详细解释这些以及剩下的命令，明确它们的作用，弄清楚它们的区别。</p><p>首先使用<code>go --help</code>可以查看go的所有命令</p><pre><code class=language-bash>Go is a tool for managing Go source code.

Usage:

        go &lt;command&gt; [arguments]

The commands are:

        bug         start a bug report
        build       compile packages and dependencies
        clean       remove object files and cached files
        doc         show documentation for package or symbol
        env         print Go environment information
        fix         update packages to use new APIs
        fmt         gofmt (reformat) package sources
        generate    generate Go files by processing source
        get         download and install packages and dependencies
        install     compile and install packages and dependencies
        list        list packages or modules
        mod         module maintenance
        run         compile and run Go program
        test        test packages
        tool        run specified go tool
        version     print Go version
        vet         report likely mistakes in packages

Use &quot;go help &lt;command&gt;&quot; for more information about a command.

Additional help topics:

        buildmode   build modes
        c           calling between Go and C
        cache       build and test caching
        environment environment variables
        filetype    file types
        go.mod      the go.mod file
        gopath      GOPATH environment variable
        gopath-get  legacy GOPATH go get
        goproxy     module proxy protocol
        importpath  import path syntax
        modules     modules, module versions, and more
        module-get  module-aware go get
        packages    package lists and patterns
        testflag    testing flags
        testfunc    testing functions

Use &quot;go help &lt;topic&gt;&quot; for more information about that topic.
</code></pre><p>可以看到，主体分为两部分，一部分是命令(command)，一部分是话题(topic)。话题是对Go中一些概念作解释，是一个文档，使用<code>go helo &lt;topic&gt;</code>来查看这些说明，不过这些随后介绍，这里首先来看各种命令。</p><a class=post-dummy-target id=1-1-command></a><h3>1.1 command</h3><p>当前命令一共17个，使用<code>go help &lt;command&gt;</code>可以查看这些命令的详细说明</p><a class=post-dummy-target id=go-version></a><h4>go version</h4><p><code>go version</code>在没有参数时，会打印自身的版本信息</p><pre><code class=language-powershell>&gt; go version
go version go1.13.4 windows/amd64
</code></pre><p>但是<code>go version</code>后也可以跟一个目录，这时会递归的查找该目录下的可执行文件，并打印它们的版本信息，以<code>bin</code>目录为例</p><pre><code class=language-powershell>PS C:\Users\lylw1\go&gt; go version bin
bin\cobra.exe: go1.13.4
bin\dlv.exe: go1.13.4
bin\go-outline.exe: go1.13.4
bin\go-symbols.exe: go1.13.4
bin\gocode-gomod.exe: go1.13.4
bin\gocode.exe: go1.13.4
bin\godef.exe: go1.13.4
bin\golint.exe: go1.13.4
bin\gopkgs.exe: go1.13.4
bin\gorename.exe: go1.13.4
bin\goreturns.exe: go1.13.4
bin\guru.exe: go1.13.4
bin\hello.exe: go1.13.4
</code></pre><p>添加<code>-v</code>参数还会将无法识别的文件信息也打印出来，以<code>stringutil</code>为例</p><pre><code class=language-powershell>&gt; go version -v src/github.com/shuzang/stringutil
src\github.com\shuzang\stringutil\reverse.go: not executable file
</code></pre><p>添加<code>-m</code>参数则会打印包导入的模块信息，仍以<code>bin</code>目录为例</p><pre><code class=language-powershell>&gt; go version -m bin
...
bin\godef.exe: go1.13.4
        path    github.com/rogpeppe/godef
        mod     github.com/rogpeppe/godef       v1.1.1  h1:NujOtt9q9vIClRTB3sCZpavac+NMRaIayzrcz1h4fSE=
        dep     9fans.net/go    v0.0.0-20181112161441-237454027057      h1:OcHlKWkAMJEF1ndWLGxp5dnJQkYM/YImUOvsBoz6h5E=
        dep     golang.org/x/tools      v0.0.0-20181130195746-895048a75ecf      h1:1efYtlcDNt7EL138lS6P4KphZ1KEMWvhFa3FsLbTWEY=
...
</code></pre><a class=post-dummy-target id=go-env></a><h4>go env</h4><p><code>go env</code>的基本作用是打印go的环境变量信息，但是添加<code>-json</code>参数可以以JSON的格式打印，不过并没有默认的脚本形式可读性高。另外，使用<code>-w</code>参数可以设置某个环境变量的值，比如</p><pre><code class=language-powershell>&gt; go env -w GOPATH=d:\go
</code></pre><p>与之相反，重置某个环境变量为默认值可以使用<code>-u</code>参数</p><pre><code class=language-powershell>&gt; go env -u GOPATH
</code></pre><a class=post-dummy-target id=go-build></a><h4>go build</h4><p>程序运行的必要过程是编译，<code>go build</code>用来完成编译功能。实际上，使用<code>go build</code>编译会将依赖的包一同编译，但会忽略掉以<code>_test.go</code>结尾的文件，因为这些文件是用来测试的。</p><p>编译<code>main</code>包时，输出的可执行文件会放到<strong>当前</strong>目录下，可执行文件的后缀取决于操作系统，只有在windows下后缀才会是<code>.exe</code>，而可执行文件的名字同编译的go文件名相同，如ed.go会编译成ed.exe。</p><p>编译多个包或单个非<code>main</code>包时，编译器不会输出可执行文件，仅仅作为这些包是否可编译的一个检查。</p><p>以我们的第一个hello.go程序为例，下列命令执行完成后，hello.exe文件位于<code>C:\User\lylw1\go</code>目录下</p><pre><code class=language-powershell>PS C:\Users\lylw1\go&gt; go build github.com/shuzang/hello
</code></pre><p>而如果我们进入包目录执行，hello.exe文件会随之存放在包的目录下</p><pre><code class=language-powershell>&gt; cd $GOPATH\src\github.com\shuzang\hello
&gt; go build
&gt; ls
hello.go  hello.exe
</code></pre><p><code>go build</code>有两个常用参数，<code>-o</code>指定输出文件，不再放到默认的<code>bin</code>目录，<code>-i</code>则在编译后自动执行安装过程</p><a class=post-dummy-target id=go-install></a><h4>go install</h4><p><code>go install</code>命令在编译的基础上增添了安装这一步，<code>安装</code>的基本含义是将生成的可执行文件放到指定的目录，默认为GOBIN环境变量指定的目录，而GOBIN的默认值是<code>$GOPATH/bin</code>。仍以<code>hello</code>为例，如下命令执行后，<code>hello.exe</code>文件将位于<code>$GOPATH/bin</code>目录下</p><pre><code class=language-powershell>&gt; go install github.com/shuzang/hello
</code></pre><a class=post-dummy-target id=go-get></a><h4>go get</h4><p><code>go get</code>与导入包息息相关，是最常用的命令之一。代码编辑过程中，我们经常需要使用别人的包，这些包一般位于各种分布式版本控制仓库中，存放在云端，比如github，我们需要将它们下载下来，然后编译安装，才能继续使用。<code>go get</code>正是一个集下载、编译、安装为一体的命令。以<code>github.com/google/codesearch/index</code>包为例</p><pre><code class=language-powershell>&gt; go get -v github.com/google/codesearch/index
github.com/google/codesearch (download)
github.com/google/codesearch/sparse
github.com/google/codesearch/index
</code></pre><p><code>-v</code>参数输出下载安装的详细过程，并输出debug信息。包会下载到<code>$GOPATH/src/github.com/google/codesearch/index</code>目录，<code>index.a</code>文件生成到<code>$GOPATH/pkg\windows_amd64\github.com\google\codesearch</code>目录，如果生成可执行文件，会放到<code>$GOPATH/bin</code>目录，不过该包并没有。</p><p><code>go get</code>拥有大量的可选参数，其中</p><ul><li><code>-d</code>只下载不安装</li><li><code>-fix</code>在对下载的包解析依赖项或编译前先运行修复工具</li><li><code>-t</code>下载为指定的包生成测试需要的包</li><li><code>-u</code>用于更新已有的包和依赖</li></ul><p><code>go get</code>下载的默认路径是GOPATH的第一个路径，这也是为什么设定多个GOPATH路径没有意义的原因。在检查或更新包时，Go会寻找符合本地已安装的Go版本的分支或标签，如果本地版本是<code>go1</code>，那么就会下载<code>go1</code>的分支或标签，否则会下载默认分支的包。</p><p>如果下载或更新的是一个git仓库，其中的submodule会一同下载或更新</p><a class=post-dummy-target id=go-run></a><h4>go run</h4><p>以上三个命令虽然都包含编译过程，但也到此为止，在生成可执行文件后将不再做任何操作，需要自己来执行。<code>go run</code>命令则在编译后直接执行运行操作，以<code>hello</code>为例</p><pre><code class=language-powershell>&gt; go run github.com/shuzang/hello
Hello, Go!
</code></pre><a class=post-dummy-target id=其它></a><h4>其它</h4><p>除了上述提到的常用命令，还有大量其它的命令，有些可能使用频率不高，或者有些不需要我们关注，因此只简单介绍其作用。<code>go test</code>和<code>go mod</code>两个命令比较特别，后面的文章单独介绍。</p><ul><li><code>go bug</code>，作用是打开默认浏览器并启动新的 Bug 报告，该报告包含有用的系统信息。</li><li><code>go clean</code>，移除源码包中编译生成的文件</li><li><code>go doc</code>，显示包或符号的文档</li><li><code>go fix</code>，用来更新老版本的代码到新版本</li><li><code>go fmt</code>，go的代码有严格的格式要求，该命令用来做格式化，但一般IDE都会帮忙做这件事</li><li><code>go generate</code>，通过处理源码生成go文件</li><li><code>go list</code>，列出当前安装的包或模块</li><li><code>go mod</code>，模块维持</li><li><code>go test</code>，自动读取源码目录下名为<code>*_test.go</code>的文件进行测试</li><li><code>go tool</code>，运行指定的go工具，后面跟的参数是其它命令</li><li><code>go vet</code>，用于检查Go语言源码中的静态错误</li></ul><a class=post-dummy-target id=1-2-topic></a><h3>1.2 topic</h3><p>topic有15个，签名已经提到，topic的本质是对Go中的一些概念作解释，所以它实际上是一些文档说明，使用<code>go help &lt;topic&gt;</code>查看，这些topic包括</p><ul><li>buildmode：构建模式的描述</li><li>c：Go和c的相互调用</li><li>cache：构建和测试缓存</li><li>environment：环境变量</li><li>filetype：文件类型</li><li>go.mod：go.mod文件</li><li>gopath：GOPATH环境变量</li><li>gopath-get：</li><li>goproxy：模块代理协议</li><li>importpath：导入路径语法</li><li>modules：模块，模块版本等</li><li>modules-get：</li><li>packages：包列表的描述</li><li>testflag：测试符号描述</li><li>testfunc：测试函数描述</li></ul><a class=post-dummy-target id=2-包></a><h2>2. 包</h2><p>包是Go语言代码组织和代码编译的一个基本结构，一个包可能由一个或多个<code>.go</code>文件组成，而一个或多个包可以构成完整的项目(仓库)。</p><a class=post-dummy-target id=2-1-包名></a><h3>2.1 包名</h3><p>每个Go源文件(<code>.go</code>文件)都必须在非注释的首行声明属于哪个包</p><pre><code class=language-go>package name
</code></pre><p><code>name</code>就是包名，包名的命名遵循命名规范，而且不得使用大写字母。每个Go应用程序都必须包含一个<code>main</code>包</p><p>一个Go程序通过<code>import</code>关键字将一组包衔接在一起，如</p><pre><code class=language-go>import &quot;fmt&quot;
</code></pre><p>包名需要用双引号包围，多个包可以使用多个<code>import</code>语句，也可以使用一个小括号全部放在一起，如</p><pre><code class=language-go>import (
   &quot;fmt&quot;
   &quot;os&quot;
    &quot;crypto/rot13&quot;
    &quot;github.com/shuzang/hello&quot;
)
</code></pre><p>包名也是导入路径的最后一个字段，比如<code>crypto/rot13</code>，其包名为<code>rot13</code>；<code>github.com/shuzang/hello</code>，其包名为<code>hello</code></p><p>没有必要刻意使用不同的包名，只要导入路径保持唯一即可</p><a class=post-dummy-target id=2-2-标准库></a><h3>2.2 标准库</h3><p>像 <code>fmt</code>、<code>os</code> 等这样具有常用功能的内置包在 Go 语言中有 150 个以上，它们被称为标准库，大部分内置于Go本身，位于<code>C:\Go\pkg\windows_amd64</code>，即<code>$GOROOT/pkg/$GOOS__$GOARCH</code>目录下，不需要额外的下载、安装和编译，详细列表和说明可以在 <a href=https://golang.google.cn/pkg/>Go Packages</a> 查看，这里简单介绍一些常用包的基本功能</p><ul><li><code>unsafe</code>: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中</li><li>系统操作类<ul><li><code>os</code>: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致</li><li><code>os/exec</code>: 提供我们运行外部操作系统命令和程序的方式</li><li><code>syscall</code>: 底层的外部包，提供了操作系统底层调用的基本接口</li></ul></li><li><code>archive/tar</code> 和 <code>/zip-compress</code>：压缩(解压缩)文件功能。</li><li>输入输出类<ul><li><code>fmt</code>: 提供了格式化输入输出功能</li><li><code>io</code>: 提供了基本输入输出功能，大多数是围绕系统功能的封装</li><li><code>bufio</code>: 缓冲输入输出功能的封装</li><li><code>path/filepath</code>: 用来操作在当前系统中的目标文件名路径</li><li><code>flag</code>: 对命令行参数的操作　</li></ul></li><li>字符串操作类<ul><li><code>strings</code>: 提供对字符串的操作</li><li><code>strconv</code>: 提供将字符串转换为基础类型的功能</li><li><code>unicode</code>: 为 unicode 型的字符串提供特殊的功能</li><li><code>regexp</code>: 正则表达式功能</li><li><code>bytes</code>: 提供对字符型分片的操作</li><li><code>index/suffixarray</code>: 子字符串快速查询</li></ul></li><li>数学<ul><li><code>math</code>: 基本的数学函数</li><li><code>math/cmath</code>: 对复数的操作</li><li><code>math/rand</code>: 伪随机数生成</li><li><code>sort</code>: 为数组排序和自定义集合</li><li><code>math/big</code>: 大数的实现和计算</li></ul></li><li>数据结构<ul><li><code>list</code>: 双链表</li><li><code>ring</code>: 环形链表</li></ul></li><li>时间<ul><li><code>time</code>: 日期和时间的基本操作</li><li><code>log</code>: 记录程序运行时产生的日志,我们将在后面的章节使用它</li></ul></li><li>编/解码<ul><li><code>encoding/json</code>: 读取并解码和写入并编码 JSON 数据</li><li><code>encoding/xml</code>:简单的 XML1.0 解析器</li><li><code>text/template</code>:生成像 HTML 一样的数据与文本混合的数据驱动模板</li></ul></li><li>网络<ul><li><code>net</code>: 网络数据的基本操作。</li><li><code>http</code>: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。</li><li><code>html</code>: HTML5 解析器</li></ul></li><li><code>runtime</code>: Go 程序运行时的交互操作，例如垃圾回收和协程创建。</li><li><code>reflect</code>: 实现通过程序运行时反射，让程序操作任意类型的变量。</li></ul><p>Go的生态远不止这些标准库，社区里存在大量的第三方包或项目，在开发自己的项目时，最好先查找下是否有已存在的第三方包或可用的库。 <a href=https://gowalker.org/>Go Walker</a> 支持根据包名在海量数据中查询。</p><a class=post-dummy-target id=2-3-导入包></a><h3>2.3 导入包</h3><p>导入包的基本格式如下</p><pre><code class=language-go>import &quot;包的路径或 URL 地址&quot; 
</code></pre><p>”包的路径“指可以是以下这种形式</p><pre><code class=language-go>import &quot;./pack1/pack1&quot;
</code></pre><p>而URL地址指的是下载的外部安装包</p><pre><code class=language-go>import &quot;github.com/org1/pack1”
</code></pre><p>导入时可以对包进行重命名，比如</p><pre><code class=language-go>import packx &quot;github.com/org1/pack1”
</code></pre><p>也可以重命名为两种特殊符号：<code>.</code>和<code>_</code>，前者可以在使用时省略包名，直接使用对外部可见的函数和变量，后者则只执行其中的init函数和初始化其全局变量，无法调用函数</p><pre><code class=language-go>import . &quot;./pack1&quot;
import _ &quot;./pack1/pack1&quot;
</code></pre><a class=post-dummy-target id=2-4-使用脚本编译或安装></a><h3>2.4 使用脚本编译或安装</h3><p>在 Linux/OS X 下可以用 Makefile 脚本 实现自动检测机器架构并调用正确的编译器和链接器</p><pre><code class=language-go>include $(GOROOT)/src/Make.inc
TARG=pack1
GOFILES=\
 	pack1.go\
 	pack1b.go\
include $(GOROOT)/src/Make.pkg
</code></pre><p>通过 <code>chmod 777 ./Makefile</code>确保它的可执行性，然后在终端使用make工具</p><a class=post-dummy-target id=3-垃圾回收></a><h2>3. 垃圾回收</h2><p>Go代码运行在Go的runtime（这部分代码可以在runtime包中找到）上，类似于java虚拟机，它负责管理包括内存分配、垃圾回收、栈处理、goroutine、channel、slice、map和reflection等。可以在<code>$GOROOT/src/runtime</code>找到关于runtime的说明。</p><p>Go的可执行文件一般比相应的源码文件大很多，这是因为runtime潜入了每一个可执行文件中，因此，Go运行不依赖于其它任何文件。</p><p>垃圾回收器(GC)正是runtime上独立运行的一个进程，它会自动搜索不再使用的变量和结构，然后释放它们的内存。通过调用<code>runtime.GC()</code>可以手动触发垃圾回收，但很少需要这样做。</p><p>如果想知道当前的内存状态，可以使用</p><pre><code class=language-go>// fmt.Printf(&quot;%d\n&quot;, runtime.MemStats.Alloc/1024)
// 此处代码在 Go 1.5.1下不再有效，更正为
var m runtime.MemStats
runtime.ReadMemStats(&amp;m)
fmt.Printf(&quot;%d Kb\n&quot;, m.Alloc / 1024)
</code></pre><p>上面的程序会给出已分配内存的总量，单位是 Kb。进一步的测量参考 <a href=https://golang.google.cn/pkg/runtime/>package runtime</a></p><a class=post-dummy-target id=4-go-mod></a><h2>4. go mod</h2><p>自Go 1.11起，开始支持使用Go Module进行包管理，这里参考Go Blog中的<a href=https://blog.golang.org/using-go-modules>Using Go Modules</a>一文对其进行说明。</p><p>模块(module)通过存在项目根目录下<code>go.mod</code>文件起作用，项目中使用的所有包的集合定义在该文件中。<code>go.mod</code>文件定义了模块路径，用于项目中包的导入路径。以delve的<code>go.mod</code>文件为例</p><pre><code class=language-go>module github.com/go-delve/delve

go 1.10

require (
	github.com/cosiner/argv v0.0.0-20170225145430-13bacc38a0a5
	github.com/cpuguy83/go-md2man v1.0.8 // indirect
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/kr/pretty v0.1.0 // indirect
	github.com/mattn/go-colorable v0.0.0-20170327083344-ded68f7a9561
	github.com/mattn/go-isatty v0.0.3
	github.com/onsi/ginkgo v1.8.0 // indirect
	github.com/onsi/gomega v1.5.0 // indirect
	github.com/peterh/liner v0.0.0-20170317030525-88609521dc4b
	github.com/pkg/profile v0.0.0-20170413231811-06b906832ed0
	github.com/russross/blackfriday v0.0.0-20180428102519-11635eb403ff // indirect
	github.com/sirupsen/logrus v0.0.0-20180523074243-ea8897e79973
	github.com/spf13/cobra v0.0.0-20170417170307-b6cb39589372
	github.com/spf13/pflag v0.0.0-20170417173400-9e4c21054fa1 // indirect
	github.com/stretchr/testify v1.3.0 // indirect
	go.starlark.net v0.0.0-20190702223751-32f345186213
	golang.org/x/arch v0.0.0-20171004143515-077ac972c2e4
	golang.org/x/crypto v0.0.0-20180614174826-fd5f17ee7299 // indirect
	golang.org/x/sys v0.0.0-20190626221950-04f50cda93cb
	golang.org/x/tools v0.0.0-20181120060634-fc4f04983f62
	gopkg.in/airbrake/gobrake.v2 v2.0.9 // indirect
	gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect
	gopkg.in/gemnasium/logrus-airbrake-hook.v2 v2.1.2 // indirect
	gopkg.in/yaml.v2 v2.2.1
)
</code></pre><p>由此可以注意到的是，使用模块进行包管理已经独立于原来使用<code>$GOPATH</code>进行包管理的方式，所有的代码不必全部放在一个工作区中。在任意位置建立项目目录，<code>go.mod</code>文件会存放在项目根目录中，所有项目源代码根据该文件进行包管理。如果<code>go.mod</code>文件放在<code>$GOPATH/src</code>，即原来的统一工作区，是不起作用的，会被旧的GOPATH模式屏蔽。自Go 1.13开始，module模式已经成为了Go开发的默认模式。</p><a class=post-dummy-target id=4-1-创建新模块></a><h3>4.1 创建新模块</h3><p>在<code>$GOPATH/src</code>外的任意位置创建项目目录，<code>cd</code>进入该目录，创建<code>hello.go</code>文件</p><pre><code class=language-go>package hello

func Hello() string {
    return &quot;Hello, world.&quot;
}
</code></pre><p>为它写一个测试文件<code>hello_test.go</code></p><pre><code class=language-go>package hello

import &quot;testing&quot;

func TestHello(t *testing.T) {
    want := &quot;Hello, world.&quot;
    if got := Hello(); got != want {
        t.Errorf(&quot;Hello() = %q, want %q&quot;, got, want)
    }
}
</code></pre><p>现在，项目中有了一个包，因为项目目录位于<code>F:/hello</code>，执行<code>go test</code>的结果如下</p><pre><code class=language-bash>$ go test
PASS
ok      _/F_/hello 0.240s
</code></pre><p>因为我们在$GOPATH外进行的测试，而且现在还没有<code>go.mod</code>文件，所以Go命令不知道导入路径，只能根据目录名生成一个导入路径。现在我们来创建<code>go.mod</code>文件并再次执行<code>go test</code>命令</p><pre><code class=language-bash>$ go mod init example.com/hello
go: creating new go.mod: module example.com/hello
$ go test
PASS
ok      example.com/hello       0.214s
</code></pre><p><code>go mod init</code>命令用于创建<code>go.mod</code>文件，初始化Go模块，其内容如下</p><pre><code class=language-bash>$ pwd
/f/hello
$ ls
go.mod  hello.go  hello_test.go
$ cat go.mod
module example.com/hello

go 1.13
</code></pre><p><code>go.mod</code>文件位于项目根目录，其中的模块路径也只显示到项目根目录，子目录中包的导入路径由模块路径+子目录路径组成。我们在当前项目目录下创建<code>world</code>子目录，其导入路径将会是<code>example.com/hello/world</code></p><a class=post-dummy-target id=4-2-添加依赖></a><h3>4.2 添加依赖</h3><p>使用Go模块的首要目的是提升别的开发者使用我们编写的代码的体验。编辑<code>hello.go</code>文件，导入<code>rsc.io/quote</code>，然后用它来实施<code>Hello</code></p><pre><code class=language-go>package hello

import &quot;rsc.io/quote&quot;

func Hello() string {
    return quote.Hello()
}
</code></pre><p>现在运行<code>go test</code></p><pre><code class=language-bash>$ go test
go: finding rsc.io/quote v1.5.2
go: downloading rsc.io/quote v1.5.2
go: extracting rsc.io/quote v1.5.2
go: finding rsc.io/sampler v1.3.0
go: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
go: downloading rsc.io/sampler v1.3.0
go: extracting rsc.io/sampler v1.3.0
go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
go: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
PASS
ok      example.com/hello    0.023s
</code></pre><p>Go使用<code>go.mod</code>文件中列举的依赖模块版本来解析导入的包，但是当在<code>go.mod</code>文件中找不到这个包是，就会自动的查找包含这个包的模块的最新版本，然后添加到<code>go.mod</code>文件。上例中自动下载了模块<code>rsc.io/quote v1.5.2</code>，还下载了它依赖的两个其它模块：<code>rsc.io/sampler</code>和<code>golang.org/x/text</code>。不过只有直接依赖会被记录到<code>go.mod</code>文件</p><pre><code class=language-bash>$ cat go.mod
module example.com/hello

go 1.13

require rsc.io/quote v1.5.2
</code></pre><p>下载的包位于<code>$GOPATH/pkg/mod</code>，再次运行<code>go test</code>命令，就不会重新下载了，因为已经存在。</p><pre><code class=language-bash>$ go test
PASS
ok      example.com/hello    0.020s
</code></pre><p>需要注意的是，尽管使用模块使得添加包管理简单轻松，但并非没有代价，当前代码的安全性、正确性和许可等都依赖于导入的模块，关于这个问题的详细描述可以查看 <a href=https://research.swtch.com/deps>Our Software Dependency Problem</a>.</p><p>如上所述，添加一个直接依赖通常会引入一些间接的依赖，使用<code>go list -m all</code>可以列举当前模块和它们所有的依赖。</p><pre><code class=language-bash>$ go list -m all
example.com/hello
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
rsc.io/quote v1.5.2
rsc.io/sampler v1.3.0
</code></pre><p>在<code>go list</code>的输出中，当前模块是主模块，总是位于第一行，其它的模块按模块路径顺序显示。</p><p><code>go.mod</code>文件外，Go还维持一个名为<code>go.sum</code>的文件，包含特定模块版本内容的加密哈希。Go使用该文件确保将来下载该模块时内容与第一次下载的内容相同，从而保证所依赖的模块没有被恶意或非恶意的更改。</p><pre><code class=language-bash>$ ls
go.mod  go.sum  hello.go  hello_test.go
$ cat go.sum
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZO...
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:Nq...
rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3...
rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPX...
rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/Q...
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9...
</code></pre><p><code>go.mod</code>和<code>go.sum</code>文件都应该包含到版本控制系统中，也就是说随着源代码文件一起提交到远程仓库。</p><a class=post-dummy-target id=4-3-更新依赖></a><h3>4.3 更新依赖</h3><p>Go模块使用的版本号分三部分：主版本号(major)，次版本号(minor)和修订版本号(patch)。例如，<code>v0.1.2</code>，主版本号是<code>0</code>，次版本号是<code>1</code>，修订版本号是<code>2</code>。首先以一个次版本号的更新举例说明</p><p>前面<code>go list -m all</code>的输出中我们可以看到<code>golang.org/x/text</code>使用的不是标准的版本号，我们可以使用<code>go get</code>命令将其更新</p><pre><code class=language-bash>$ go get golang.org/x/text
go: finding golang.org/x/text v0.3.0
go: downloading golang.org/x/text v0.3.0
go: extracting golang.org/x/text v0.3.0
$ go test
PASS
ok      example.com/hello    0.013s
</code></pre><p>现在再次列举所有的模块以及查看<code>go.mod</code>文件</p><pre><code class=language-bash>$ go list -m all
example.com/hello
golang.org/x/text v0.3.0
rsc.io/quote v1.5.2
rsc.io/sampler v1.3.0
$ cat go.mod
module example.com/hello

go 1.12

require (
    golang.org/x/text v0.3.0 // indirect
    rsc.io/quote v1.5.2
)
</code></pre><p>可以看到两者中<code>golang.org/x/text</code>都已经更新到了最新的版本号<code>v0.3.0</code>，注释中的<code>indirect</code>说明这个依赖不是直接被引用的，只是被其它的模块间接引用。</p><p>现在我们更新<code>rsc.io/sampler</code>的次版本号</p><pre><code class=language-bash>$ go get rsc.io/sampler
go: finding rsc.io/sampler v1.99.99
go: downloading rsc.io/sampler v1.99.99
go: extracting rsc.io/sampler v1.99.99
$ go test
--- FAIL: TestHello (0.00s)
    hello_test.go:8: Hello() = &quot;99 bottles of beer on the wall, 99 bottles of beer, ...&quot;, want &quot;Hello, world.&quot;
FAIL
exit status 1
FAIL    example.com/hello    0.014s
</code></pre><p>测试失败说明版本不匹配，列举所有可用版本</p><pre><code class=language-bash>$ go list -m -versions rsc.io/sampler
rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99
</code></pre><p>之前使用的是v1.3.0，v1.99.99也被证明无法使用，因此换用v1.3.1</p><pre><code class=language-bash>$ go get rsc.io/sampler@v1.3.1
go: finding rsc.io/sampler v1.3.1
go: downloading rsc.io/sampler v1.3.1
go: extracting rsc.io/sampler v1.3.1
$ go test
PASS
ok      example.com/hello    0.022s
</code></pre><p>通过<code>@</code>来指定具体的版本号，<code>go get</code>的参数实际上应该带有版本号，不明确指定会使用默认的<code>@latest</code>，从而使用最新版本。</p><a class=post-dummy-target id=4-4-在主版本号上添加依赖></a><h3>4.4 在主版本号上添加依赖</h3><p>主版本号的更新是不同的，会看作一个独立的依赖。在<code>hello.go</code>中添加一个新的函数<code>Proverb()</code>，它使用了<code>rsc.io/quote</code>的<code>v3</code>版本，导入格式为<code>rsc.io/quote/v3</code></p><pre><code class=language-go>package hello

import (
    &quot;rsc.io/quote&quot;
    quoteV3 &quot;rsc.io/quote/v3&quot;
)

func Hello() string {
    return quote.Hello()
}

func Proverb() string {
    return quoteV3.Concurrency()
}
</code></pre><p>然后为其添加测试函数</p><pre><code class=language-go>func TestProverb(t *testing.T) {
    want := &quot;Concurrency is not parallelism.&quot;
    if got := Proverb(); got != want {
        t.Errorf(&quot;Proverb() = %q, want %q&quot;, got, want)
    }
}
</code></pre><p>测试结果如下</p><pre><code class=language-bash>$ go test
go: finding rsc.io/quote/v3 v3.1.0
go: downloading rsc.io/quote/v3 v3.1.0
go: extracting rsc.io/quote/v3 v3.1.0
PASS
ok      example.com/hello    0.024s
</code></pre><p>现在我们的模块同时依赖于<code>rsc.io/quote</code>和<code>rsc.io/quote/v3</code></p><pre><code class=language-bash>$ go list -m rsc.io/q...
rsc.io/quote v1.5.2
rsc.io/quote/v3 v3.1.0
</code></pre><p>Go模块的每个主版本号(v1, v2, and so on)都使用一个不同的模块路径，从<code>v2</code>开始，路径必须以主版本号结尾，比如<code>rsc.io/quote</code>的<code>v3</code>版本模块路径为<code>rsc.io/quote/v3</code>，这种惯例称作 <a href=https://research.swtch.com/vgo-import>semantic import versioning</a> ，给不兼容的包提供了不同的名字。相反，同一个主版本号，如<code>v1.6.0</code>应该向前兼容，和<code>rsc.io/quote</code>使用同一个名字，在同一个项目中，每个主版本号Go只允许出现一种，比如<code>v1.5.2</code>和<code>v1.6.0</code>不能同时存在，但不同的主版本号可以同时存在，这是为了使程序可以逐步过渡到新的版本。</p><a class=post-dummy-target id=4-5-更新依赖到新的主版本号></a><h3>4.5 更新依赖到新的主版本号</h3><p>比如从<code>rsc.io/quote</code>迁移到<code>rsc.io/quote/v3</code>，由于大版本更新，某些不兼容的API可能被删除、重命名或做其它的更改，阅读文档，我们可以发现<code>HelloV3</code>相对于<code>Hello</code>做了如下改动</p><pre><code class=language-bash>$ go doc rsc.io/quote/v3
package quote // import &quot;rsc.io/quote&quot;

Package quote collects pithy sayings.

func Concurrency() string
func GlassV3() string
func GoV3() string
func HelloV3() string
func OptV3() string
</code></pre><p>检查并更新我们的源码</p><pre><code class=language-go>package hello

import quoteV3 &quot;rsc.io/quote/v3&quot;

func Hello() string {
    return quoteV3.HelloV3()
}

func Proverb() string {
    return quoteV3.Concurrency()
}
</code></pre><p>由于没有冲突，这里导入的包不再需要重命名，因此可以继续简化</p><pre><code class=language-go>package hello

import &quot;rsc.io/quote/v3&quot;

func Hello() string {
    return quote.HelloV3()
}

func Proverb() string {
    return quote.Concurrency()
}
</code></pre><p>运行测试</p><pre><code class=language-bash>$ go test
PASS
ok      example.com/hello       0.014s
</code></pre><a class=post-dummy-target id=4-6-移除不使用的依赖></a><h3>4.6 移除不使用的依赖</h3><p>我们已经不再使用<code>rsc.io/quote</code>，但它依然存在于<code>go list -m all</code>的输出和<code>go.mod</code>文件中</p><pre><code class=language-bash>$ go list -m all
example.com/hello
golang.org/x/text v0.3.0
rsc.io/quote v1.5.2
rsc.io/quote/v3 v3.1.0
rsc.io/sampler v1.3.1
$ cat go.mod
module example.com/hello

go 1.12

require (
    golang.org/x/text v0.3.0 // indirect
    rsc.io/quote v1.5.2
    rsc.io/quote/v3 v3.0.0
    rsc.io/sampler v1.3.1 // indirect
)
</code></pre><p>这是因为编译单个包时无法自动检测是否可以安全的移除某个包，只能通过手动执行<code>go mod tidy</code>命令清理不再使用的依赖</p><pre><code class=language-bash>$ go mod tidy
$ go list -m all
example.com/hello
golang.org/x/text v0.3.0
rsc.io/quote/v3 v3.1.0
rsc.io/sampler v1.3.1
$ cat go.mod
module example.com/hello

go 1.12

require (
    golang.org/x/text v0.3.0 // indirect
    rsc.io/quote/v3 v3.1.0
    rsc.io/sampler v1.3.1 // indirect
)

$ go test
PASS
ok      example.com/hello    0.020s
$
</code></pre><p>最后是关于发布自己的模块版本的注意，参考两篇文章</p><ul><li><a href=https://blog.golang.org/publishing-go-modules>Publishing Go Modules</a></li><li><a href=https://blog.golang.org/v2-go-modules>Go Modules: v2 and Beyond</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>The article was updated on 2019-09-19</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href="//twitter.com/share?url=https%3a%2f%2fshuzang.github.io%2f2019%2f09%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25802-%25E5%2591%25BD%25E4%25BB%25A4%25E5%258C%2585%25E4%25B8%258E%25E6%25A8%25A1%25E5%259D%2597%2f&amp;text=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%802-%e5%91%bd%e4%bb%a4%e3%80%81%e5%8c%85%e4%b8%8e%e6%a8%a1%e5%9d%97&amp;via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshuzang.github.io%2f2019%2f09%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25802-%25E5%2591%25BD%25E4%25BB%25A4%25E5%258C%2585%25E4%25B8%258E%25E6%25A8%25A1%25E5%259D%2597%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fshuzang.github.io%2f2019%2f09%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25802-%25E5%2591%25BD%25E4%25BB%25A4%25E5%258C%2585%25E4%25B8%258E%25E6%25A8%25A1%25E5%259D%2597%2f&amp;title=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%802-%e5%91%bd%e4%bb%a4%e3%80%81%e5%8c%85%e4%b8%8e%e6%a8%a1%e5%9d%97" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/golang/><i class="fas fa-tag fa-fw"></i>&nbsp;Golang</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/2019/09/%E8%80%81%E8%88%8D%E5%B9%BD%E9%BB%98%E5%B0%8F%E8%AF%B4/ class=prev rel=prev title=老舍幽默小说><i class="fas fa-angle-left fa-fw"></i>老舍幽默小说</a>
<a href=https://shuzang.github.io/2019/09/%E5%BA%9F%E5%90%8D%E7%94%B0%E5%9B%AD%E5%B0%8F%E8%AF%B4/ class=next rel=next title=废名田园小说>废名田园小说<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io target=_blank>shuzang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>