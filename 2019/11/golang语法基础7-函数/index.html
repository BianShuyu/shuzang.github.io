<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Golang语法基础7-函数 | Shuzang&#39;s Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="shuzang's personal blog"><link rel=prev href=https://shuzang.github.io/2019/11/life-skills-6-medical-insurance-and-medical-treatment/><link rel=next href=https://shuzang.github.io/2019/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AB%98%E5%85%B3%E8%81%94%E5%BA%A6%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/><link rel=canonical href=https://shuzang.github.io/2019/11/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E5%87%BD%E6%95%B0/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang语法基础7-函数"><meta name=twitter:description content="1. 函数声明与定义 Go中有三种类型的函数： 普通的带有名字的函数 匿名函数 方法（Methods，在结构体部分介绍） 普通函数声明的基本格式为 func functionName(param1 type1, param2"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础7-函数","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2019\/11\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E5%87%BD%E6%95%B0\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Golang","wordcount":3700,"url":"https:\/\/shuzang.github.io\/2019\/11\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%807-%E5%87%BD%E6%95%B0\/","datePublished":"2019-11-25T00:00:00\x2b00:00","dateModified":"2019-11-25T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/css/lib/animate/animate.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=navbar-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">Golang语法基础7-函数</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://shuzang.github.io rel=author target=_blank><i class="fas fa-user-circle fa-fw"></i>shuzang
</a>&nbsp;<span class=post-category>included in&nbsp;<i class="far fa-folder fa-fw"></i><a href=https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-11-25>2019-11-25</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3700 words&nbsp;
<i class="far fa-clock fa-fw"></i>8 min&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#1-函数声明与定义>1. 函数声明与定义</a></li><li><a href=#2-函数调用>2. 函数调用</a></li><li><a href=#3-函数参数与返回值>3. 函数参数与返回值</a><ul><li><a href=#3-1-参数传递类型>3.1 参数传递类型</a></li><li><a href=#3-2-命名参数>3.2 命名参数</a></li><li><a href=#3-3-空白符>3.3 空白符</a></li><li><a href=#3-4-变长参数>3.4 变长参数</a></li><li><a href=#3-5-函数作为参数>3.5 函数作为参数</a></li></ul></li><li><a href=#4-内置函数>4. 内置函数</a></li><li><a href=#5-闭包>5. 闭包</a></li><li><a href=#6-defer和追踪>6. defer和追踪</a></li><li><a href=#7-编写规范>7. 编写规范</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#1-函数声明与定义>1. 函数声明与定义</a></li><li><a href=#2-函数调用>2. 函数调用</a></li><li><a href=#3-函数参数与返回值>3. 函数参数与返回值</a><ul><li><a href=#3-1-参数传递类型>3.1 参数传递类型</a></li><li><a href=#3-2-命名参数>3.2 命名参数</a></li><li><a href=#3-3-空白符>3.3 空白符</a></li><li><a href=#3-4-变长参数>3.4 变长参数</a></li><li><a href=#3-5-函数作为参数>3.5 函数作为参数</a></li></ul></li><li><a href=#4-内置函数>4. 内置函数</a></li><li><a href=#5-闭包>5. 闭包</a></li><li><a href=#6-defer和追踪>6. defer和追踪</a></li><li><a href=#7-编写规范>7. 编写规范</a></li></ul></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=1-函数声明与定义></a><h2>1. 函数声明与定义</h2><p>Go中有三种类型的函数：</p><ol><li>普通的带有名字的函数</li><li>匿名函数</li><li>方法（Methods，在结构体部分介绍）</li></ol><p>普通函数声明的基本格式为</p><pre><code class=language-go>func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...)
</code></pre><p>定义就需要添加大括号和函数体</p><pre><code class=language-go>func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...) {
    ...
}
</code></pre><p>两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。</p><p>当函数执行到代码块最后一行，也就是最后一个<code>}</code>之前，或者执行到<code>return</code>语句的时候就会退出。</p><p>main函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有init()函数会先执行该函数。</p><p>main函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main函数一旦返回就表示程序已成功执行并立即退出。同样，init()函数也没有返回值</p><a class=post-dummy-target id=2-函数调用></a><h2>2. 函数调用</h2><p>同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示</p><pre><code class=language-go>pack1.functionName(arg1, arg2, ..., argn)
</code></pre><p><code>pack1</code>是包名，<code>functionName</code>是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下</p><pre><code class=language-go>package main

func main() {
    println(&quot;In main before calling greeting&quot;)
    greeting()
    println(&quot;In main after calling greeting&quot;)
}

func greeting() {
    println(&quot;In greeting: Hi!!!!!&quot;)
}
//Output:
In main before calling greeting
In greeting: Hi!!!!!
In main after calling greeting
</code></pre><p>Go中不允许函数重载</p><a class=post-dummy-target id=3-函数参数与返回值></a><h2>3. 函数参数与返回值</h2><p>除了mian()和init()函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以<code>return</code>或<code>panic</code>语句结尾，<code>return</code>可以返回多个值，多值返回是Go的一大特性。</p><a class=post-dummy-target id=3-1-参数传递类型></a><h3>3.1 参数传递类型</h3><p>Go中的参数传递类型有两种：按值传递和按引用传递。</p><p>Go默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符&amp;，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。</p><p>函数调用时，切片、映射、接口、通道这些引用类型默认使用按引用传递</p><p>几乎在任何情况下，按引用传递的消耗都比按值传递小</p><p>按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用<code>return</code>返回</p><a class=post-dummy-target id=3-2-命名参数></a><h3>3.2 命名参数</h3><p>函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如<code>func f(int, int, float64)</code>，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下</p><pre><code class=language-go>package main

import &quot;fmt&quot;

var num int = 10
var numx2, numx3 int

func main() {
    numx2, numx3 = getX2AndX3(num)
    PrintValues()
    numx2, numx3 = getX2AndX3_2(num)
    PrintValues()
}

func PrintValues() {
    fmt.Printf(&quot;num = %d, 2x num = %d, 3x num = %d\n&quot;, num, numx2, numx3)
}

func getX2AndX3(input int) (int, int) {
    return 2 * input, 3 * input
}

func getX2AndX3_2(input int) (x2 int, x3 int) {
    x2 = 2 * input
    x3 = 3 * input
    // return x2, x3
    return
}
//Output:
num = 10, 2x num = 20, 3x num = 30    
num = 10, 2x num = 20, 3x num = 30 
</code></pre><p>命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的return语句（带参数也不会出错）。</p><p>当需要返回多个非命名返回值时，需要使用括号包围，如<code>(int, int)</code>，但对命名返回值，即使只有一个返回值，也要用括号包围。</p><a class=post-dummy-target id=3-3-空白符></a><h3>3.3 空白符</h3><p>空白符<code>_</code>用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。</p><a class=post-dummy-target id=3-4-变长参数></a><h3>3.4 变长参数</h3><p>如果函数最后一个参数是<code>...type</code>的形式，那么函数就可以处理一个变长的参数，这个长度可以是0，这样的函数称为变参函数</p><pre><code class=language-go>func myFunc(a, b, arg ...int) {}
</code></pre><p>变长参数的本质是一个切片，如下例</p><pre><code class=language-go>func Greeting(prefix string, who ...string)
Greeting(&quot;hello:&quot;, &quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;)
</code></pre><p>变量<code>who</code>的值为 <code>[]string{&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;}</code></p><p>如果参数本身就存在一个切片类型中，比如切片<code>slice1</code>，则可以通过<code>slice1...</code>的形式传递参数，之前的切片部分使用append函数时已经这样使用过</p><pre><code class=language-go>package main

import &quot;fmt&quot;

func main() {
	x := min(1, 3, 2, 0)
	fmt.Printf(&quot;The minimum is: %d\n&quot;, x)
	slice := []int{7,9,3,5,1}
	x = min(slice...)
	fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)
}

func min(s ...int) int {
	if len(s)==0 {
		return 0
	}
	min := s[0]
	for _, v := range s {
		if v &lt; min {
			min = v
		}
	}
	return min
}
//Output:
The minimum is: 0
The minimum in the slice is: 1
</code></pre><p>一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递</p><pre><code class=language-go>func F1(s ...string) {
	F2(s...)
	F3(s)
}

func F2(s ...string) { }
func F3(s []string) { }
</code></pre><a class=post-dummy-target id=3-5-函数作为参数></a><h3>3.5 函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要函数返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
)

func main() {
	callback(1, Add)
}

func Add(a, b int) {
	fmt.Printf(&quot;The sum of %d and %d is: %d\n&quot;, a, b, a+b)
}

func callback(y int, f func(int, int)) {
	f(y, 2) // this becomes Add(1, 2)
}
//Output:
The sum of 1 and 2 is: 3
</code></pre><a class=post-dummy-target id=4-内置函数></a><h2>4. 内置函数</h2><p>Go语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如len, cap, append，以下是内置函数列表</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real imag</td><td>用于创建和操作复数</td></tr></tbody></table><a class=post-dummy-target id=5-闭包></a><h2>5. 闭包</h2><p>当我们不希望给函数起名字时，可以使用匿名函数，例如<code>func(x, y int) int { return x + y }</code></p><p>这样一个函数不能独立存在，但可以被赋值给某个变量，如<code>fplus := func(x, y int) int { return x + y }</code>，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：<code>fplus(3, 4)</code></p><p>也可以直接调用匿名函数： <code>func(x, y int) int { return x + y } (3, 4)</code></p><p>下面是一个计算从 1 到 1 百万整数的总和的匿名函数：</p><pre><code class=language-go>func() {
	sum := 0
	for i := 1; i &lt;= 1e6; i++ {
		sum += i
	}
}()
</code></pre><p>表示参数列表的第一对括号必须紧挨着关键字 <code>func</code>，因为匿名函数没有名称。花括号 <code>{}</code> 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><p>匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中</p><pre><code class=language-go>func (u string) {
	fmt.Println(u)
	…
}(v)
</code></pre><p>使用闭包还可以将函数作为返回值</p><pre><code class=language-go>package main

import &quot;fmt&quot;

func main() {
	var f = Adder()
	fmt.Print(f(1), &quot; - &quot;)
	fmt.Print(f(20), &quot; - &quot;)
	fmt.Print(f(300))
}

func Adder() func(int) int {
	var x int
	return func(delta int) int {
		x += delta
		return x
	}
}
//Output:
1 - 21 - 321
</code></pre><p>上例还可以说明一个问题，即闭包函数会保存并积累其中的变量的值，不管 外部函数退出与否，它都能够继续操作外部函数中的局部变量。 如上例， 在多次调用中，变量 x 的值是被保留的，即 <code>0 + 1 = 1</code>，然后 <code>1 + 20 = 21</code>，最后 <code>21 + 300 = 321</code></p><p>这种返回值为另一个函数的函数可以被称之为工厂函数，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数：</p><pre><code class=language-go>func MakeAddSuffix(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}
</code></pre><p>现在可以生成如下函数</p><pre><code class=language-go>addBmp := MakeAddSuffix(&quot;.bmp&quot;)
addJpeg := MakeAddSuffix(&quot;.jpeg&quot;)
</code></pre><p>然后调用它们</p><pre><code class=language-go>addBmp(&quot;file&quot;) // returns: file.bmp
addJpeg(&quot;file&quot;) // returns: file.jpeg
</code></pre><a class=post-dummy-target id=6-defer和追踪></a><h2>6. defer和追踪</h2><p>关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数。之所以在return语句之后，是因为 <code>return</code> 语句同样可以包含一些操作，而不是单纯地返回某个值。</p><pre><code class=language-go>package main
import &quot;fmt&quot;

func main() {
	function1()
}

func function1() {
	fmt.Printf(&quot;In function1 at the top\n&quot;)
	defer function2()
	fmt.Printf(&quot;In function1 at the bottom!\n&quot;)
}

func function2() {
	fmt.Printf(&quot;Function2: Deferred until the end of the calling function!&quot;)
}
//Output:
In Function1 at the top
In Function1 at the bottom!
Function2: Deferred until the end of the calling function!
</code></pre><p>使用defer的语句同样可以接收参数</p><pre><code class=language-go>func a() {
	i := 0
	defer fmt.Println(i)
	i++
	return
}
</code></pre><p>多个defer会以逆序执行，即后进先出</p><pre><code class=language-go>func f() {
	for i := 0; i &lt; 5; i++ {
		defer fmt.Printf(&quot;%d &quot;, i)
	}
}
//Output:
4 3 2 1 0
</code></pre><p>defer关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如</p><ol><li><p>关闭文件流</p><pre><code class=language-go>//open a file
defer file.Close()
</code></pre></li><li><p>解锁一个加锁的资源</p><pre><code class=language-go>mu.Lock()
defer mu.Unlock()
</code></pre></li><li><p>打印最终报告</p><pre><code class=language-go>printHeader()
defer printFooter()
</code></pre></li><li><p>关闭数据库链接</p><pre><code class=language-go>//open a database connection
defer disconnectFromDB()
</code></pre></li></ol><p>一个综合模拟以上四种情况的代码如下</p><pre><code class=language-go>package main

import &quot;fmt&quot;

func main() {
	doDBOperations()
}

func connectToDB() {
	fmt.Println(&quot;ok, connected to db&quot;)
}

func disconnectFromDB() {
	fmt.Println(&quot;ok, disconnected from db&quot;)
}

func doDBOperations() {
	connectToDB()
	fmt.Println(&quot;Defering the database disconnect.&quot;)
	defer disconnectFromDB() //function called here with defer
	fmt.Println(&quot;Doing some DB operations ...&quot;)
	fmt.Println(&quot;Oops! some crash or network error ...&quot;)
	fmt.Println(&quot;Returning from function here!&quot;)
	return //terminate the program
	// deferred function executed here just before actually returning, even if
	// there is a return or abnormal termination before
}
//Output:
ok, connected to db
Defering the database disconnect.
Doing some DB operations ...
Oops! some crash or network error ...
Returning from function here!
ok, disconnected from db
</code></pre><p>使用defer语句还可以实现代码追踪，只要在进入和离开某个函数时打印相关消息，即可以提炼为下面两个函数</p><pre><code class=language-go>func trace(s string) { fmt.Println(&quot;entering:&quot;, s) }
func untrace(s string) { fmt.Println(&quot;leaving:&quot;, s) }
</code></pre><p>以下是调用这两个函数的例子</p><pre><code class=language-go>package main

import &quot;fmt&quot;

func trace(s string)   { fmt.Println(&quot;entering:&quot;, s) }
func untrace(s string) { fmt.Println(&quot;leaving:&quot;, s) }

func a() {
	trace(&quot;a&quot;)
	defer untrace(&quot;a&quot;)
	fmt.Println(&quot;in a&quot;)
}

func b() {
	trace(&quot;b&quot;)
	defer untrace(&quot;b&quot;)
	fmt.Println(&quot;in b&quot;)
	a()
}

func main() {
	b()
}
//Output:
entering: b
in b
entering: a
in a
leaving: a
leaving: b
</code></pre><p>进一步简化代码如下</p><pre><code class=language-go>package main

import &quot;fmt&quot;

func trace(s string) string {
	fmt.Println(&quot;entering:&quot;, s)
	return s
}

func un(s string) {
	fmt.Println(&quot;leaving:&quot;, s)
}

func a() {
	defer un(trace(&quot;a&quot;))
	fmt.Println(&quot;in a&quot;)
}

func b() {
	defer un(trace(&quot;b&quot;))
	fmt.Println(&quot;in b&quot;)
	a()
}

func main() {
	b()
}
</code></pre><p>最后，还可以使用defer来记录函数参数与返回值，这是一种在调试时使用defer语句的手法</p><pre><code class=language-go>package main

import (
	&quot;io&quot;
	&quot;log&quot;
)

func func1(s string) (n int, err error) {
	defer func() {
		log.Printf(&quot;func1(%q) = %d, %v&quot;, s, n, err)
	}()
	return 7, io.EOF
}

func main() {
	func1(&quot;Go&quot;)
}
//Output:
Output: 2011/10/04 10:46:11 func1(&quot;Go&quot;) = 7, EOF
</code></pre><a class=post-dummy-target id=7-编写规范></a><h2>7. 编写规范</h2><p>Go是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是Uber开源在github的编码规范，有两条主要规则</p><ol><li><p>函数应按粗略的调用顺序排序</p></li><li><p>同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于<code>newXYZ()</code>这样的新建某个类型的函数。一个简单的例子如下</p><pre><code class=language-go>type something struct{ ... }
   
func newSomething() *something {
   return &amp;something{}
}
   
func (s *something) Cost() {
 return calcCost(s.weights)
}
   
func calcCost(n []int) int {...}
</code></pre></li></ol><p>最后，main函数放在所有函数的最后。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>The article was updated on 2019-11-25</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href="//twitter.com/share?url=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25807-%25E5%2587%25BD%25E6%2595%25B0%2f&amp;text=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%807-%e5%87%bd%e6%95%b0&amp;via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25807-%25E5%2587%25BD%25E6%2595%25B0%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25807-%25E5%2587%25BD%25E6%2595%25B0%2f&amp;title=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%807-%e5%87%bd%e6%95%b0" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/golang/><i class="fas fa-tag fa-fw"></i>&nbsp;Golang</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/2019/11/life-skills-6-medical-insurance-and-medical-treatment/ class=prev rel=prev title=生活技能6-医保及就医><i class="fas fa-angle-left fa-fw"></i>生活技能6-医保及就医</a>
<a href=https://shuzang.github.io/2019/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AB%98%E5%85%B3%E8%81%94%E5%BA%A6%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/ class=next rel=next title=区块链高关联度文章收集>区块链高关联度文章收集<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io target=_blank>shuzang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>