<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Golang语法基础6-数组、切片与映射 | Shuzang&#39;s Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="shuzang's personal blog"><link rel=prev href=https://shuzang.github.io/2019/11/hugo-blog-themes-collection/><link rel=next href=https://shuzang.github.io/2019/11/life-skills-6-medical-insurance-and-medical-treatment/><link rel=canonical href=https://shuzang.github.io/2019/11/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E4%B8%8E%E6%98%A0%E5%B0%84/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang语法基础6-数组、切片与映射"><meta name=twitter:description content="基本的数据类型无法满足所有编程需要，通常情况下，我们还需要一些存储和处理大量数据的高级数据结构，称之为容器(container)。一般情况下"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础6-数组、切片与映射","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2019\/11\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E4%B8%8E%E6%98%A0%E5%B0%84\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Golang","wordcount":5350,"url":"https:\/\/shuzang.github.io\/2019\/11\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%806-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E4%B8%8E%E6%98%A0%E5%B0%84\/","datePublished":"2019-11-18T00:00:00\x2b00:00","dateModified":"2019-11-18T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/css/lib/animate/animate.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=navbar-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">Golang语法基础6-数组、切片与映射</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://shuzang.github.io rel=author target=_blank><i class="fas fa-user-circle fa-fw"></i>shuzang
</a>&nbsp;<span class=post-category>included in&nbsp;<i class="far fa-folder fa-fw"></i><a href=https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-11-18>2019-11-18</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 5350 words&nbsp;
<i class="far fa-clock fa-fw"></i>11 min&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#数组>数组</a></li><li><a href=#切片>切片</a></li><li><a href=#切片的一些常见操作>切片的一些常见操作</a><ul><li><a href=#1-重组>1. 重组</a></li><li><a href=#2-复制>2. 复制</a></li><li><a href=#3-追加>3. 追加</a></li><li><a href=#4-删除>4. 删除</a><ul><li><a href=#1-从开始位置删除>1）从开始位置删除</a></li><li><a href=#2-从中间位置删除>2）从中间位置删除</a></li><li><a href=#3-从末尾删除>3）从末尾删除</a></li></ul></li><li><a href=#5-插入>5. 插入</a></li></ul></li><li><a href=#映射>映射</a><ul><li><a href=#1-声明与初始化>1. 声明与初始化</a></li><li><a href=#2-访问与删除map中的元素>2. 访问与删除map中的元素</a></li><li><a href=#3-遍历map>3. 遍历map</a></li><li><a href=#4-map类型的切片>4. map类型的切片</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#数组>数组</a></li><li><a href=#切片>切片</a></li><li><a href=#切片的一些常见操作>切片的一些常见操作</a><ul><li><a href=#1-重组>1. 重组</a></li><li><a href=#2-复制>2. 复制</a></li><li><a href=#3-追加>3. 追加</a></li><li><a href=#4-删除>4. 删除</a><ul><li><a href=#1-从开始位置删除>1）从开始位置删除</a></li><li><a href=#2-从中间位置删除>2）从中间位置删除</a></li><li><a href=#3-从末尾删除>3）从末尾删除</a></li></ul></li><li><a href=#5-插入>5. 插入</a></li></ul></li><li><a href=#映射>映射</a><ul><li><a href=#1-声明与初始化>1. 声明与初始化</a></li><li><a href=#2-访问与删除map中的元素>2. 访问与删除map中的元素</a></li><li><a href=#3-遍历map>3. 遍历map</a></li><li><a href=#4-map类型的切片>4. map类型的切片</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><p>基本的数据类型无法满足所有编程需要，通常情况下，我们还需要一些存储和处理大量数据的高级数据结构，称之为<code>容器(container)</code>。一般情况下，容器包括数组、映射、链表三种，但在Go语言中，由于数组不够灵活，增加了切片(slice)类型。Go中切片是频繁使用的，相比来说，数组的使用频率要低得多。</p><p>基本的数据类型无法满足所有编程需要，通常情况下，我们还需要一些存储和处理大量数据的高级数据结构，称之为容器(container)。一般情况下，容器包括数组、映射、链表三种，但在Go语言中，由于数组不够灵活，增加了切片(slice)类型。Go中切片是频繁使用的，相比来说，数组的使用频率要低得多。</p><p>只有基本的数据类型无法适应所有的情况，当需要存储和处理大量数据时，通常会使用数组、映射、链表等数据结构，称之为容器(container)。在Go语言中，由于数组不够灵活，增加了切片(slice)类型，切片也是一种容器。</p><p>C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。</p><p>本篇只介绍数组和切片，映射类型放在下篇介绍，链表类型在数据结构中介绍。</p><a class=post-dummy-target id=数组></a><h2>数组</h2><p>数组是有限个相同类型的数据的集合，Go语言中数组声明的格式为</p><pre><code class=language-go>var identifier [len]type
</code></pre><p>数组元素可以是任意基本类型，数组本身，结构体甚至接口（空），当元素类型是数组本身时，即为二维或多维数组。</p><p>应注意，数组长度也是数组类型的一部分，<code>[5]int</code>和<code>[10]int</code>是两个不同类型。</p><p>数组元素通过索引来读取或修改，因此不同于字符串，数组是可变的。索引的范围从<code>0</code>到<code>len(arr)-1</code>，内置函数<code>len()</code>可用来获取数组长度，数组长度最大为2Gb。</p><p>声明数组时所有的元素都会被自动初始化为元素类型的零值，初始化的过程是按照数组元素的顺序进行的。</p><p>当数组元素较少时，可以在声明时直接进行初始化，一些表达方式如下</p><pre><code class=language-go>var arr1 = [3]int{1, 2, 3}
var arr2 = [10]int{1, 2, 3} //剩下的元素会自动补全，其值为0
var arr3 = [3]string{2:&quot;test&quot;}  //只有索引2被赋予了实际的值，其它元素都初始化为空字符串
</code></pre><p>数组长度的位置也可以使用省略号，此时数组长度会根据提供的值的个数自动推断</p><pre><code class=language-go>arr := [...]int{1, 2, 3}
fmt.Println(len(arr)) //3
</code></pre><p>数组元素较多时使用for循环初始化</p><pre><code class=language-go>var arr [100]int

//使用for循环初始化
for i:=0; i &lt; len(arr); i++ {
    arr[i] = i * 2
}
</code></pre><p>Go语言中数组是一种值类型，而不像C语言是指向首元素的指针，因此可以使用内置函数<code>new()</code>来创建数组（<code>new()</code>用来创建值类型，返回所创建类型的指针）</p><pre><code class=language-go>var arr1 = new([5]int)
</code></pre><p>这种方式和<code>var arr2 [5]int</code>的区别是，arr1的类型是<code>*[5]int</code>，而arr2的类型是<code>[5]int</code>，一个简单的式子可以帮助理解</p><pre><code class=language-go>arr2 := *arr1
</code></pre><p>当像上式这样进行赋值时，我们把arr1的值做了一次拷贝，因此修改arr2不会对arr1产生影响。同理，函数中数组作为参数传入时，传入值类型的数组不会改变原值，但是直接传入数组作为参数，当数组很大时会消耗很多内存，可以传入数组的指针或使用切片来解决。以下是传入指针的例子。</p><pre><code class=language-go>package main
import &quot;fmt&quot;
func f(a [3]int) { fmt.Println(a) }
func fp(a *[3]int) { fmt.Println(a) }

func main() {
    var ar = [3]int{1, 2, 3} 
	f(ar) 	// passes a copy of ar
	fp(&amp;ar) // passes a pointer to ar
}
</code></pre><p>数组可以组装成多维数组，一个二维数组可以理解为一个数组类型的数组，以下演示一个二维数组的声明</p><pre><code class=language-go>// 声明一个二维整型数组，两个维度的长度分别是 4 和 2
var array [4][2]int
// 声明并初始化数组中索引为 1 和 3 的元素
array = [4][2]int{1: {20, 21}, 3: {40, 41}}
// 声明并初始化数组中指定的元素
array = [4][2]int{1: {0: 20}, 3: {1: 41}}
</code></pre><a class=post-dummy-target id=切片></a><h2>切片</h2><p>在Go中，切片的使用比数组类型更加广泛。切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型。它在内存中的组织方式是一个有三个域的结构体：指向相关数组的指针，切片长度以及切片容量。以一个长度为 2，容量为 4 的切片y为例，多个切片可以表示同一个数组的片段，如图中x和y。</p><p><img src=https://user-images.githubusercontent.com/26682846/68194286-baeef580-ffef-11e9-822c-af854849d163.png alt="slice in memory"></p><p>切片声明的格式如下，基本就是去掉了数组声明中的长度</p><pre><code class=language-go>var identifier []type
</code></pre><p>未初始化的切片默认为nil，长度为0。切片的初始化格式为</p><pre><code class=language-go>var slice []type = arr[start:end]
</code></pre><p>表示slice是数组arr从start索引到end-1索引之间的元素构成的子集，切片的大小可以和数组相等，但应注意到终止索引的项并不包含在切片内。一些切片的方式如下</p><pre><code class=language-go>var arr = [5]int{1,2,3,4,5}

s := arr[:] 
s := arr[0:5] //这两个切片都等于整个数组

s := arr[:3]
s := arr[0:3] //这两式输出都是[1,2,3]

s := arr[2:] 
s := arr[2:5] //这两式输出都是[3,4,5]
</code></pre><p>切片是可索引的，但切片的索引与原数组的索引不一定相同，如上例最后一行，s[0] = arr[2]。</p><p>切片的长度在运行时可修改，最小为0最大为相关数组的长度，具体的长度值可通过<code>len()</code>函数获得。</p><p><code>cap()</code>函数可以计算切片的容量，也就是切片最长可以达到多少。举个例子，如果 s 是一个切片，<code>cap(s)</code> 就是从 <code>s[0]</code> 到数组末尾的数组长度。切片的长度永远不会超过它的容量。容量之所以从s[0]开始计数，是因为切片只能向后移动，任何试图获取切片第一个元素之前的数组元素的做法都会导致编译错误。</p><pre><code class=language-go>arr := [5]int{1, 2, 3, 4, 5}
s := arr[2:4] //len(s)为2，cap(s)为3
</code></pre><p>两个直接创建切片的例子如下</p><pre><code class=language-go>s := [3]int{1,2,3}[:]
x := []int{2,3,4,5,6}
</code></pre><p>但本质上这两者都是先创建的数组，然后取了与数组等长的切片。</p><p>注：切片本身已是引用，它没有指针，因此不要对它使用取地址符。</p><p>在上面的数组部分我们谈到当数组很大时，直接将数组作为参数传给函数会占用大量内存，因此我们介绍了如何传入数组的指针，这里我们再介绍如何传入切片：我们应当在函数中声明参数为切片类型，调用函数时，把数组分片，创建一个切片引用传递给该函数，示例如下</p><pre><code class=language-go>func sum(a []int) int {
	s := 0
	for i := 0; i &lt; len(a); i++ {
		s += a[i]
	}
	return s
}

func main() {
	var arr = [5]int{0, 1, 2, 3, 4}
	sum(arr[:])
}
</code></pre><p>数组作为值类型使用<code>new()</code>来创建，而切片作为引用类型，需要使用<code>make()</code>。</p><pre><code class=language-go>var slice []type = make([]type, len)
slice := make([]type, len) //简写形式
</code></pre><p>其中第二个参数len是数组的长度，也是slice的初始长度，例如定义<code>s1 := make([]int, 10)</code>，那么<code>cap(s1) == len(s1) == 10</code></p><p>也可以在声明时利用第三个参数指定切片容量</p><pre><code class=language-go>slice := make([]type, len, cap)
</code></pre><p>因此，下面两种方法可生成相同切片</p><pre><code class=language-go>make([]int, 50, 100)
new([100]int)[0:50]
</code></pre><p>字符串可以看作是一个不可变的字节数组，因此也可以切分为切片使用。</p><a class=post-dummy-target id=切片的一些常见操作></a><h2>切片的一些常见操作</h2><p>由于切片的灵活性，会经常使用切片进行一些操作，这里简单介绍几种。</p><a class=post-dummy-target id=1-重组></a><h3>1. 重组</h3><p>使用<code>make</code>创建切片的时候可以指定容量，因此必要时可以改变切片长度直到达到容量上限，改变切片长度的过程称为切片重组（reslice），如将切片扩展1位</p><pre><code class=language-go>s = s[0:len(s)+1] //len(s)+1 &lt;= cap(s)
</code></pre><a class=post-dummy-target id=2-复制></a><h3>2. 复制</h3><p>增加切片的容量必须创建一个新的更大的切片并把原分片的内容都拷贝过来。切片拷贝使用<code>copy()</code>函数，函数原型如下</p><pre><code class=language-go>copy(destSlice, srcSlice []T) int
</code></pre><p>作用是将 srcSlice 复制到 destSlice，两者类型必须一致，返回值为实际复制的元素个数。源地址和目标地址可能会有重叠。复制的元素个数是 srcSlice 和 dstSlice 的长度最小值。示例如下</p><pre><code class=language-go>sl_from := []int{1, 2, 3}
sl_to1 := make([]int, 5)
sl_to2 := make([]int, 2)
n1 := copy(sl_to1, sl_from) // n1 = 3, s1_to1 = [1,2,3,0,0]
n2 := copy(sl_to2, sl_from) // n2 = 2, s1_to2 = [1,2]
</code></pre><a class=post-dummy-target id=3-追加></a><h3>3. 追加</h3><p>追加也是一种切片扩容的方式，主要使用<code>append()</code>函数，函数原型是</p><pre><code class=language-go>func append(s []T, x ...T) []T
</code></pre><p>作用是将0个或多个具有相同类型T的元素追加到切片s后面病并回新的切片，追加的元素类型需要和原切片的元素同类型。如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。</p><pre><code class=language-go>sl3 := []int{1, 2, 3}
sl3 = append(sl3, 4, 5, 6) // sl2 = [1,2,3,4,5,6]
</code></pre><a class=post-dummy-target id=4-删除></a><h3>4. 删除</h3><p>删除切片元素没有专用语法，需要使用切片本身的特性。分为三种情况：从开始位置删除，从中间位置删除，从末尾删除</p><a class=post-dummy-target id=1-从开始位置删除></a><h4>1）从开始位置删除</h4><p>直接移动数据指针</p><pre><code class=language-go>a = []int{1, 2, 3}
a = a[1:] // 删除开头1个元素
a = a[N:] // 删除开头N个元素
</code></pre><p>不移动数据指针，而是将后面的数据向开头移动</p><pre><code class=language-go>a = []int{1, 2, 3}
a = append(a[:0], a[1:]...) // 删除开头1个元素
a = append(a[:0], a[N:]...) // 删除开头N个元素
</code></pre><p>使用<code>copy()</code>函数</p><pre><code class=language-go>a = []int{1, 2, 3}
a = a[:copy(a, a[1:])] // 删除开头1个元素
a = a[:copy(a, a[N:])] // 删除开头N个元素
</code></pre><a class=post-dummy-target id=2-从中间位置删除></a><h4>2）从中间位置删除</h4><p>对剩余的元素做一次整体移动，可以使用<code>copy()</code>或<code>append()</code></p><pre><code class=language-go>a = []int{1, 2, 3, ...}
a = append(a[:i], a[i+1:]...) // 删除中间1个元素
a = append(a[:i], a[i+N:]...) // 删除中间N个元素
a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素
a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素
</code></pre><a class=post-dummy-target id=3-从末尾删除></a><h4>3）从末尾删除</h4><pre><code class=language-go>a = []int{1, 2, 3}
a = a[:len(a)-1] // 删除尾部1个元素
a = a[:len(a)-N] // 删除尾部N个元素
</code></pre><p>删除开头和末尾都是删除中间的特殊情况</p><a class=post-dummy-target id=5-插入></a><h3>5. 插入</h3><p>插入的一般方式是使用两次<code>append()</code>函数</p><pre><code class=language-go>a = append(a[:i], append([]T{x}, a[i:]...)...) //在索引i的位置插入元素x
a = append(a[:i], append(make([]T, j), a[i:]...)...) //在索引i的位置插入长度为j的新切片
a = append(a[:i], append(b, a[i:]...)...) //在索引i的位置插入切片b的所有元素
</code></pre><p>映射(map)其实就是数据结构里的哈希表，但不少语言都已经把它作为了内置的数据类型。映射是元素对的无序集合，由键(key)和值(value)两部分构成，可以通过键快速查找值（比线性查找快，但实际上比通过数组或切片索引直接读取要慢）。</p><a class=post-dummy-target id=映射></a><h2>映射</h2><a class=post-dummy-target id=1-声明与初始化></a><h3>1. 声明与初始化</h3><p>Golang中的map是引用类型，声明方法如下</p><pre><code class=language-go>//声明模型
var mapname map[keytype]valuetype
//示例
var map1 map[string]int
//可以写作var map1 map[string] int，不会出错，但空格会被go fmt移除
</code></pre><p>map可以动态增长，声明时不关心长度，但应注意，map是有长度的，其长度使用内置函数<code>len()</code>获取。</p><p>未初始化的map值为nil，如果此时识图给map添加元素会导致运行时错误，因此添加元素必须首先初始化。</p><p>map初始化的方法有两种</p><ol><li><p>直接使用大括号，在数组与切片的初始化中已经见过这种方法，示例如下</p><pre><code class=language-go>var mapLit map[string]int
mapLit = map[string]int{&quot;one&quot;:1, &quot;two&quot;:2}
</code></pre></li><li><p>使用make，map是引用类型，因此使用make初始化，同为引用类型的切片也使用make初始化，但值类型的数组使用new来初始化</p><pre><code class=language-go>mapLit := make(map[string]int)
</code></pre></li></ol><p>以make方式初始化其实相当于<code>mapLit := map[string]int{}</code></p><p>学会了使用make初始化map后，我们可以在初始化时指定map容量。虽然map可以动态增长，没有长度限制，但是也可以在一开始标明其初始容量</p><pre><code class=language-go>mapLit := make(map[string]int, 100)
</code></pre><p>当map增长到容量上限后，继续增加新的键值对，map的大小会自动加1，因此容量对map并没有多大影响。</p><p>我们还比较关心一点，那就是键与值的类型。凡是可以用<code>==</code>或<code>!=</code>操作符比较的类型都可以作为<strong>键的类型</strong>，比如string、int、float、只包含内建类型的结构体、指针和接口，而数组、切片以及含有数组切片的结构体无法作为键类型。<strong>值的类型</strong>是任意的，当值类型是一些复杂结构时，往往有比较特殊的用途，比如</p><ol><li><p>函数。值类型为函数时可以视作分支结构，key用来选择要执行的函数。</p></li><li><p>空接口。我们可以用空接口作为值类型存储任意类型的值，只是在使用前需要做一次类型断言。</p></li><li><p>切片。通过将值类型定义为切片类型，应对一个Key对应多个值的情况，示例如下</p><pre><code class=language-go>mp1 := make(map[int][]int)
</code></pre></li></ol><a class=post-dummy-target id=2-访问与删除map中的元素></a><h3>2. 访问与删除map中的元素</h3><p>如果key1是map1的key，那么<code>map1[key1]</code>就是对应key1的值，map中与键对应的元素值就通过这种与数组索引类似的方式来查找。数组实际上也可以看作一种简单形式的map，其key是从0开始递增的整数。</p><pre><code class=language-go>val1 := map1[key1]
</code></pre><p>上式将key1对应的值赋给了val1，但反过来，也可以通过这种形式设置对应key1的值，如下</p><pre><code class=language-go>map1[key1] = val1
</code></pre><p>访问map中不存在的key会获得它所对应的值类型的空值，因此我们还需要有一种办法来判断键值对是否存在，这样才能区分到底是键值对本身不存在，还是值是空值。实际上通过键来访问值会返回两个结果，如下</p><pre><code class=language-go>val1, ok := map1[key1]
</code></pre><p>当键值对存在时，ok的值为true，而当键值对不存在时，ok的值为false。如果只想判断某个键值对是否存在，可以将返回的真正的值设置为匿名变量</p><pre><code class=language-go>_, ok := map1[key1]

</code></pre><p>map中元素的删除使用内置函数<code>delete()</code>，格式如下</p><pre><code class=language-go>delete(mapname, keyname)

</code></pre><p>示例如下，如果键值对不存在，删除操作不会产生错误</p><pre><code class=language-go>mapLit := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2}
delete(mapLit, &quot;one&quot;)

</code></pre><p>但Golang并没有提供清空map中所有元素的方法，清空map的唯一办法就是重新make一个新的map</p><pre><code class=language-go>mapLit := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2}
mapLit = make(map[string]int)

</code></pre><a class=post-dummy-target id=3-遍历map></a><h3>3. 遍历map</h3><p>for-range可用于遍历map</p><pre><code class=language-go>for key, value := range map1 {
	...
}

</code></pre><p>其中第一个返回值key是map中的key值，第二个返回值value则是key对应的value值。</p><p>如果只关心值，可以这么用</p><pre><code class=language-go>for _, value := range map1 {
	...
}

</code></pre><p>而如果只关心键，则这么用</p><pre><code class=language-go>for key := range map1 {
	fmt.Printf(&quot;key is: %d\n&quot;, key)
}

</code></pre><p>还需要知道的一点是，for-range结构虽然能遍历整个map，但我们并不知道map中键值对排列的顺序，并不是按key的顺序排列的，也不是按value的顺序排列。</p><p>如果想要为map排序，那么就需要先通过遍历将map的所有数据复制到切片中，再对切片排序，最后打印出来</p><pre><code class=language-go>// the telephone alphabet:
package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

var barVal = map[string]int{&quot;alpha&quot;: 34, &quot;bravo&quot;: 56, &quot;charlie&quot;: 23}

func main() {
	fmt.Println(&quot;unsorted:&quot;)
	for k, v := range barVal {
		fmt.Printf(&quot;Key: %v, Value: %v ; &quot;, k, v)
	}
	keys := make([]string, len(barVal))
	i := 0
	for k := range barVal {
		keys[i] = k
		i++
	}
	sort.Strings(keys)
	fmt.Println()
	fmt.Println(&quot;sorted:&quot;)
	for _, k := range keys {
		fmt.Printf(&quot;Key: %v, Value: %v ; &quot;, k, barVal[k])
	}
}
//Output:
unsorted:
Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; 
sorted:
Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; 

</code></pre><p>上例按key进行了排序并输出，如果想要更好的显示，可以使用结构体切片</p><pre><code class=language-go>type name struct {
	key string
	value int
}

</code></pre><a class=post-dummy-target id=4-map类型的切片></a><h3>4. map类型的切片</h3><p>map类型的切片是一个很有意思的结构，构造它需要使用两次<code>make()</code>函数，第一次分配切片，第二次分配切片中的每个map元素</p><pre><code class=language-go>package main
import &quot;fmt&quot;

func main() {
	// Version A:
	items := make([]map[int]int, 5)
	for i:= range items {
		items[i] = make(map[int]int, 1)
		items[i][1] = 2
	}
	fmt.Printf(&quot;Version A: Value of items: %v\n&quot;, items)

	// Version B: NOT GOOD!
	items2 := make([]map[int]int, 5)
	for _, item := range items2 {
		item = make(map[int]int, 1) // item is only a copy of the slice element.
		item[1] = 2 // This 'item' will be lost on the next iteration.
	}
	fmt.Printf(&quot;Version B: Value of items: %v\n&quot;, items2)
}
//Output:
Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]
Version B: Value of items: [map[] map[] map[] map[] map[]]

</code></pre><p>应该意识到，for-range结构中，value只是值的拷贝，对它做操作不会影响原值，因此上例中第二种写法是错误的，真正的map元素并没有得到初始化。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>The article was updated on 2019-11-18</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href="//twitter.com/share?url=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25806-%25E6%2595%25B0%25E7%25BB%2584%25E5%2588%2587%25E7%2589%2587%25E4%25B8%258E%25E6%2598%25A0%25E5%25B0%2584%2f&amp;text=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%806-%e6%95%b0%e7%bb%84%e3%80%81%e5%88%87%e7%89%87%e4%b8%8e%e6%98%a0%e5%b0%84&amp;via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25806-%25E6%2595%25B0%25E7%25BB%2584%25E5%2588%2587%25E7%2589%2587%25E4%25B8%258E%25E6%2598%25A0%25E5%25B0%2584%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25806-%25E6%2595%25B0%25E7%25BB%2584%25E5%2588%2587%25E7%2589%2587%25E4%25B8%258E%25E6%2598%25A0%25E5%25B0%2584%2f&amp;title=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%806-%e6%95%b0%e7%bb%84%e3%80%81%e5%88%87%e7%89%87%e4%b8%8e%e6%98%a0%e5%b0%84" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/golang/><i class="fas fa-tag fa-fw"></i>&nbsp;Golang</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/2019/11/hugo-blog-themes-collection/ class=prev rel=prev title=hugo搭建个人博客6-博客收集><i class="fas fa-angle-left fa-fw"></i>hugo搭建个人博客6-博客收集</a>
<a href=https://shuzang.github.io/2019/11/life-skills-6-medical-insurance-and-medical-treatment/ class=next rel=next title=生活技能6-医保及就医>生活技能6-医保及就医<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io target=_blank>shuzang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>