<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Golang语法基础5-字符串操作与输入输出 | Shuzang&#39;s Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="shuzang's personal blog"><link rel=prev href=https://shuzang.github.io/2019/11/%E5%88%A9%E7%94%A8onedrive%E5%90%8C%E6%AD%A5zotero%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B9/><link rel=next href=https://shuzang.github.io/2019/11/an-attribute-based-access-control-model-in-rfid-systems.../><link rel=canonical href=https://shuzang.github.io/2019/11/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang语法基础5-字符串操作与输入输出"><meta name=twitter:description content="本篇介绍字符串的相关操作，涉及string和strconv两个标准库，以及介绍输入输出的基本方法，涉及fmt和bufio两个标准库。 1. 字符串"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础5-字符串操作与输入输出","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2019\/11\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Golang","wordcount":3009,"url":"https:\/\/shuzang.github.io\/2019\/11\/golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%805-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA\/","datePublished":"2019-11-11T00:00:00\x2b00:00","dateModified":"2019-11-11T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/css/lib/animate/animate.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=navbar-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang&#39;s Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/life>Life</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">Golang语法基础5-字符串操作与输入输出</h1><div class=post-meta><div class=post-meta-main><a class=author href=https://shuzang.github.io rel=author target=_blank><i class="fas fa-user-circle fa-fw"></i>shuzang
</a>&nbsp;<span class=post-category>included in&nbsp;<i class="far fa-folder fa-fw"></i><a href=https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=post-meta-other><i class="far fa-calendar-alt fa-fw"></i><time datetime=2019-11-11>2019-11-11</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3009 words&nbsp;
<i class="far fa-clock fa-fw"></i>7 min&nbsp;</div></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#1-字符串操作>1. 字符串操作</a><ul><li><a href=#1-1-判断包含关系>1.1 判断包含关系</a></li><li><a href=#1-2-获取子字符串的位置>1.2 获取子字符串的位置</a></li><li><a href=#1-3-统计出现次数>1.3 统计出现次数</a></li><li><a href=#1-4-替换与重复>1.4 替换与重复</a></li><li><a href=#1-5-大小写转换>1.5 大小写转换</a></li><li><a href=#1-6-修剪与分割>1.6 修剪与分割</a></li><li><a href=#1-7-拼接>1.7 拼接</a></li></ul></li><li><a href=#2-输入输出>2. 输入输出</a><ul><li><a href=#2-1-读取用户输入>2.1 读取用户输入</a><ul><li><a href=#来自标准输入>来自标准输入</a></li><li><a href=#来自字符串>来自字符串</a></li><li><a href=#来自io-reader类型>来自io.Reader类型</a></li></ul></li><li><a href=#2-2-输出指定内容>2.2 输出指定内容</a></li><li><a href=#2-3-使用bufio包>2.3 使用bufio包</a><ul><li><a href=#bufio包原理>bufio包原理</a></li><li><a href=#读入>读入</a></li><li><a href=#写出>写出</a></li></ul></li><li><a href=#2-4-文件读写>2.4 文件读写</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><ul><li><a href=#1-字符串操作>1. 字符串操作</a><ul><li><a href=#1-1-判断包含关系>1.1 判断包含关系</a></li><li><a href=#1-2-获取子字符串的位置>1.2 获取子字符串的位置</a></li><li><a href=#1-3-统计出现次数>1.3 统计出现次数</a></li><li><a href=#1-4-替换与重复>1.4 替换与重复</a></li><li><a href=#1-5-大小写转换>1.5 大小写转换</a></li><li><a href=#1-6-修剪与分割>1.6 修剪与分割</a></li><li><a href=#1-7-拼接>1.7 拼接</a></li></ul></li><li><a href=#2-输入输出>2. 输入输出</a><ul><li><a href=#2-1-读取用户输入>2.1 读取用户输入</a><ul><li><a href=#来自标准输入>来自标准输入</a></li><li><a href=#来自字符串>来自字符串</a></li><li><a href=#来自io-reader类型>来自io.Reader类型</a></li></ul></li><li><a href=#2-2-输出指定内容>2.2 输出指定内容</a></li><li><a href=#2-3-使用bufio包>2.3 使用bufio包</a><ul><li><a href=#bufio包原理>bufio包原理</a></li><li><a href=#读入>读入</a></li><li><a href=#写出>写出</a></li></ul></li><li><a href=#2-4-文件读写>2.4 文件读写</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><p>本篇介绍字符串的相关操作，涉及<code>string</code>和<code>strconv</code>两个标准库，以及介绍输入输出的基本方法，涉及<code>fmt</code>和<code>bufio</code>两个标准库。</p><a class=post-dummy-target id=1-字符串操作></a><h2>1. 字符串操作</h2><p>对字符串的操作无论在什么语言里都是很重要的，因此在基本数据类型中介绍过字符串之后，这里仍然专门拿出一篇来介绍关于字符串的处理。</p><p>如我们之前所述，内置的字符串操作是字符串的拼接，通过拼接符<code>+</code>来完成。</p><pre><code class=language-go>s := &quot;hel&quot; + &quot;lo,&quot;
s += &quot;world!&quot;
fmt.Println(s) 
//Output: 
//hello, world!
</code></pre><p>但使用拼接符<code>+</code>并不是最高效的做法，同时，由于字符串是一种内容不可变的值类型，无法直接通过索引操作其内的任意字符。Go语言内置了<code>strings</code>包来提供对字符串的种种操作，方便我们使用，当然，很多时候也会使用<code>strconv</code>包，这个包的使用我们在类型转换部分提到过。</p><a class=post-dummy-target id=1-1-判断包含关系></a><h3>1.1 判断包含关系</h3><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：</p><pre><code class=language-go>strings.HasPrefix(s, prefix string) bool
</code></pre><p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：</p><pre><code class=language-go>strings.HasSuffix(s, suffix string) bool
</code></pre><p>示例如下</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	var str string = &quot;This is an example of a string&quot;
	fmt.Printf(&quot;T/F? Does the string \&quot;%s\&quot; have prefix %s? &quot;, str, &quot;Th&quot;)
	fmt.Printf(&quot;%t\n&quot;, strings.HasPrefix(str, &quot;Th&quot;))
}
//Output:
//T/F? Does the string &quot;This is an example of a string&quot; have prefix Th? true
</code></pre><p>更一般化的，<code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code>：</p><pre><code class=language-go>strings.Contains(s, substr string) bool
</code></pre><a class=post-dummy-target id=1-2-获取子字符串的位置></a><h3>1.2 获取子字符串的位置</h3><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的索引（<code>str</code> 的第一个字符的索引），-1 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p><pre><code class=language-go>strings.Index(s, str string) int
</code></pre><p><code>LastIndex</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引（<code>str</code> 的第一个字符的索引），-1 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p><pre><code class=language-go>strings.LastIndex(s, str string) int
</code></pre><p>如果需要查询非 ASCII 编码的字符在父字符串中的位置，使用以下函数来对字符进行定位：</p><pre><code class=language-go>strings.IndexRune(s string, r rune) int
</code></pre><p>示例如下</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	var str string = &quot;Hi, I'm Marc, Hi.&quot;

	fmt.Printf(&quot;The position of \&quot;Marc\&quot; is: &quot;)
	fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Marc&quot;))

	fmt.Printf(&quot;The position of the first instance of \&quot;Hi\&quot; is: &quot;)
	fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Hi&quot;))
	fmt.Printf(&quot;The position of the last instance of \&quot;Hi\&quot; is: &quot;)
	fmt.Printf(&quot;%d\n&quot;, strings.LastIndex(str, &quot;Hi&quot;))

	fmt.Printf(&quot;The position of \&quot;Burger\&quot; is: &quot;)
	fmt.Printf(&quot;%d\n&quot;, strings.Index(str, &quot;Burger&quot;))
}
/*Output:
The position of &quot;Marc&quot; is: 8
The position of the first instance of &quot;Hi&quot; is: 0
The position of the last instance of &quot;Hi&quot; is: 14
The position of &quot;Burger&quot; is: -1
*/
</code></pre><a class=post-dummy-target id=1-3-统计出现次数></a><h3>1.3 统计出现次数</h3><p><code>Count</code> 用于计算字符串 <code>str</code> 在字符串 <code>s</code> 中出现的非重叠次数：</p><pre><code class=language-go>strings.Count(s, str string) int
</code></pre><p>示例</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	var str string = &quot;Hello, how is it going, Hugo?&quot;
	var manyG = &quot;gggggggggg&quot;

	fmt.Printf(&quot;Number of H's in %s is: &quot;, str)
	fmt.Printf(&quot;%d\n&quot;, strings.Count(str, &quot;H&quot;))

	fmt.Printf(&quot;Number of double g's in %s is: &quot;, manyG)
	fmt.Printf(&quot;%d\n&quot;, strings.Count(manyG, &quot;gg&quot;))
}
/*Output:
Number of H's in Hello, how is it going, Hugo? is: 2
Number of double g’s in gggggggggg is: 5
*/
</code></pre><a class=post-dummy-target id=1-4-替换与重复></a><h3>1.4 替换与重复</h3><p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 则替换所有字符串 <code>old</code> 为字符串 <code>new</code>：</p><pre><code class=language-go>strings.Replace(str, old, new, n) string
</code></pre><p><code>Repeat</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p><pre><code class=language-go>strings.Repeat(s, count int) string
</code></pre><p>示例</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	var origS string = &quot;Hi there! &quot;
	var newS string

	newS = strings.Repeat(origS, 3)
	fmt.Printf(&quot;The new repeated string is: %s\n&quot;, newS)
}
//Output:
//The new repeated string is: Hi there! Hi there! Hi there!
</code></pre><a class=post-dummy-target id=1-5-大小写转换></a><h3>1.5 大小写转换</h3><p><code>ToLower</code> 将字符串中的 Unicode 字符全部转换为相应的小写字符：</p><pre><code class=language-go>strings.ToLower(s) string
</code></pre><p><code>ToUpper</code> 将字符串中的 Unicode 字符全部转换为相应的大写字符：</p><pre><code class=language-go>strings.ToUpper(s) string
</code></pre><p>示例</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	var orig string = &quot;Hey, how are you George?&quot;
	var lower string
	var upper string

	fmt.Printf(&quot;The original string is: %s\n&quot;, orig)
	lower = strings.ToLower(orig)
	fmt.Printf(&quot;The lowercase string is: %s\n&quot;, lower)
	upper = strings.ToUpper(orig)
	fmt.Printf(&quot;The uppercase string is: %s\n&quot;, upper)
}
/*Output:
The original string is: Hey, how are you George?
The lowercase string is: hey, how are you george?
The uppercase string is: HEY, HOW ARE YOU GEORGE?
*/
</code></pre><a class=post-dummy-target id=1-6-修剪与分割></a><h3>1.6 修剪与分割</h3><p>可以使用 <code>strings.TrimSpace(s)</code> 来剔除字符串开头和结尾的空白符号；</p><p>可以使用 <code>strings.Trim(s, &quot;cut&quot;)</code> 来将开头和结尾的指定字符串（<code>cut</code>）去除掉。</p><p>如果只想剔除开头或者结尾的字符串，则可以使用 <code>TrimLeft</code> 或者 <code>TrimRight</code> 来实现。</p><p><code>strings.Fields(s)</code> 将会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice。</p><p><code>strings.Split(s, sep)</code> 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。</p><p>因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理</p><a class=post-dummy-target id=1-7-拼接></a><h3>1.7 拼接</h3><p><code>Join</code> 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：</p><pre><code class=language-go>strings.Join(sl []string, sep string) string
</code></pre><p>示例</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	str := &quot;The quick brown fox jumps over the lazy dog&quot;
	sl := strings.Fields(str)
	fmt.Printf(&quot;Splitted in slice: %v\n&quot;, sl)
	for _, val := range sl {
		fmt.Printf(&quot;%s - &quot;, val)
	}
	fmt.Println()
	str2 := &quot;GO1|The ABC of Go|25&quot;
	sl2 := strings.Split(str2, &quot;|&quot;)
	fmt.Printf(&quot;Splitted in slice: %v\n&quot;, sl2)
	for _, val := range sl2 {
		fmt.Printf(&quot;%s - &quot;, val)
	}
	fmt.Println()
	str3 := strings.Join(sl2,&quot;;&quot;)
	fmt.Printf(&quot;sl2 joined by ;: %s\n&quot;, str3)
}
/*Output:
Splitted in slice: [The quick brown fox jumps over the lazy dog]
The - quick - brown - fox - jumps - over - the - lazy - dog -
Splitted in slice: [GO1 The ABC of Go 25]
GO1 - The ABC of Go - 25 -
sl2 joined by ;: GO1;The ABC of Go;25
*/
</code></pre><a class=post-dummy-target id=2-输入输出></a><h2>2. 输入输出</h2><p>编写程序进行数据的读写必不可少，一般会用到fmt, os和bufio三个包，下面对一些读写方式进行总结。</p><a class=post-dummy-target id=2-1-读取用户输入></a><h3>2.1 读取用户输入</h3><p>用户输入来自三种：标准输入，字符串，io.Reader类型</p><a class=post-dummy-target id=来自标准输入></a><h4>来自标准输入</h4><p>读取用户输入一般指的是读取用户的键盘（控制台）输入，定义为标准输入os.Stdin，最常用的方法是使用fmt包提供的Scan开头的函数。</p><pre><code class=language-go>func Scan(a ...interface{}) (n int, err error)
func Scanf(format string, a ...interface{}) (n int, err error)
func Scanln(a ...interface{}) (n int, err error)
</code></pre><p>Scan从标准输入扫描文本，将成功读取的空白分隔的值传递给函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。</p><p>Scanf从标准输入扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值传递给函数的参数。返回成功扫描的条目个数和遇到的任何错误。</p><p>Scanln类似Scan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。</p><p>一个示例程序如下：</p><pre><code class=language-go>package main
import &quot;fmt&quot;

var firstName, lastName string

func main() {
   fmt.Println(&quot;Please enter your full name: &quot;)
   fmt.Scanln(&amp;firstName, &amp;lastName)
   // fmt.Scanf(&quot;%s %s&quot;, &amp;firstName, &amp;lastName)
}
</code></pre><a class=post-dummy-target id=来自字符串></a><h4>来自字符串</h4><p>读取来自字符串的输入一般使用fmt包中SScan开头的函数</p><pre><code class=language-go>func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
</code></pre><p>SScan开头的函数基本和Scan相似，唯一的不同是多了第一个参数str，代表从字符串str扫描文本。一个示例程序如下：</p><pre><code class=language-go>package main

import &quot;fmt&quot;

func main() {
	var name string
	var age int
	n, err := fmt.Sscanf(&quot;Kim is 22 years old&quot;, &quot;%s is %d years old&quot;, &amp;name, &amp;age)
	if err != nil {
		panic(err)
	}
	fmt.Printf(&quot;%d: %s, %d\n&quot;, n, name, age)

}
//Output
2: Kim, 22
</code></pre><a class=post-dummy-target id=来自io-reader类型></a><h4>来自io.Reader类型</h4><p>主要是使用Fscan开头的函数</p><pre><code class=language-go>func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
</code></pre><p>同样，与Scan的不同是第一个参数r是io.Reader类型，示例程序如下：</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	var (
		i int
		b bool
		s string
	)
	r := strings.NewReader(&quot;5 true gophers&quot;) //返回一个io.Reader类型
	n, err := fmt.Fscanf(r, &quot;%d %t %s&quot;, &amp;i, &amp;b, &amp;s)
	if err != nil {
		fmt.Fprintf(os.Stderr, &quot;Fscanf: %v\n&quot;, err)
	}
	fmt.Println(i, b, s)
	fmt.Println(n)
}

5 true gophers
3
</code></pre><a class=post-dummy-target id=2-2-输出指定内容></a><h3>2.2 输出指定内容</h3><p>输出和读取输入基本是是相反的，各函数原型如下：</p><pre><code class=language-go>func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
func Sprint(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string
func Sprintln(a ...interface{}) string
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
</code></pre><p>示例程序如下：</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)


func main() {
	const name, age = &quot;Kim&quot;, 22
	fmt.Printf(&quot;%s is %d years old.\n&quot;, name, age)
    
	s := fmt.Sprintf(&quot;%s is %d years old.\n&quot;, name, age)
	io.WriteString(os.Stdout, s) // Ignoring error for simplicity.
	
    n, err := fmt.Fprintf(os.Stdout, &quot;%s is %d years old.\n&quot;, name, age)
	if err != nil {
		fmt.Fprintf(os.Stderr, &quot;Fprintf: %v\n&quot;, err)
	}
	fmt.Printf(&quot;%d bytes written.\n&quot;, n)
}
//Output
Kim is 22 years old.
Kim is 22 years old.
Kim is 22 years old.
21 bytes written.
</code></pre><a class=post-dummy-target id=2-3-使用bufio包></a><h3>2.3 使用bufio包</h3><p>使用fmt进行读写，读写次数比较多时，时间耗费极大。go提供了一个bufio包，使用该包可以大幅提高文件读写效率。</p><a class=post-dummy-target id=bufio包原理></a><h4>bufio包原理</h4><p>介绍来自<a href=https://zhuanlan.zhihu.com/p/73690883>茹姐-GO语言基础进阶教程：bufio包</a>。io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。</p><p><img src=https://pic3.zhimg.com/80/v2-eafcc5129ec4afd2ed89cecc5824c57e_hd.jpg alt=利用缓冲区读写文件></p><a class=post-dummy-target id=读入></a><h4>读入</h4><pre><code class=language-go>package main
import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
)

func main() {
    inputReader := bufio.NewReader(os.Stdin)
    fmt.Println(&quot;Please enter some input: &quot;)
    input, err := inputReader.ReadString('\n')
    if err == nil {
        fmt.Printf(&quot;The input was: %s\n&quot;, input)
    }
}

</code></pre><p><code>bufio.NewReader()</code> 构造函数的签名为：<code>func NewReader(rd io.Reader) *Reader</code></p><p><code>inputReader</code> 是一个指向 <code>bufio.Reader</code> 的指针。<code>inputReader := bufio.NewReader(os.Stdin)</code> 这行代码，将会创建一个读取器，并将其与标准输入绑定。返回的读取器对象提供一个方法 <code>ReadString(delim byte)</code>，该方法从输入中读取内容，直到碰到 <code>delim</code> 指定的字符，然后将读取到的内容连同 <code>delim</code> 字符一起放到缓冲区。在上面的例子中，我们会读取键盘输入，直到回车键（\n）被按下。</p><a class=post-dummy-target id=写出></a><h4>写出</h4><pre><code class=language-go>package main

import (
    &quot;os&quot;
    &quot;fmt&quot;
    &quot;bufio&quot;
)

func main() { 
     w1 := bufio.NewWriter(os.Stdout)

     for i:=1;i&lt;=1000;i++{
        w1.WriteString(fmt.Sprintf(&quot;%d:hello&quot;,i))
     }
     w1.Flush()
}

</code></pre><a class=post-dummy-target id=2-4-文件读写></a><h3>2.4 文件读写</h3><p>主要是使用os.Open函数打开文件，以及defer关键字和close方法在程序结束时关闭文件。</p><pre><code class=language-go>package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
)

func main() {
    inputFile, inputError := os.Open(&quot;input.dat&quot;)
    if inputError != nil {
        fmt.Printf(&quot;An error occurred on opening the inputfile\n&quot; +
            &quot;Does the file exist?\n&quot; +
            &quot;Have you got acces to it?\n&quot;)
        return // exit the function on error
    }
    defer inputFile.Close()

    inputReader := bufio.NewReader(inputFile)
    for {
        inputString, readerError := inputReader.ReadString('\n')
        fmt.Printf(&quot;The input was: %s&quot;, inputString)
        if readerError == io.EOF {
            return
        }      
    }
}

</code></pre><p>未完待续&hellip;</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>The article was updated on 2019-11-11</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href="//twitter.com/share?url=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25805-%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E6%2593%258D%25E4%25BD%259C%25E4%25B8%258E%25E8%25BE%2593%25E5%2585%25A5%25E8%25BE%2593%25E5%2587%25BA%2f&amp;text=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%805-%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%93%8d%e4%bd%9c%e4%b8%8e%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba&amp;via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25805-%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E6%2593%258D%25E4%25BD%259C%25E4%25B8%258E%25E8%25BE%2593%25E5%2585%25A5%25E8%25BE%2593%25E5%2587%25BA%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fshuzang.github.io%2f2019%2f11%2fgolang%25E8%25AF%25AD%25E6%25B3%2595%25E5%259F%25BA%25E7%25A1%25805-%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E6%2593%258D%25E4%25BD%259C%25E4%25B8%258E%25E8%25BE%2593%25E5%2585%25A5%25E8%25BE%2593%25E5%2587%25BA%2f&amp;title=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%805-%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%93%8d%e4%bd%9c%e4%b8%8e%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/golang/><i class="fas fa-tag fa-fw"></i>&nbsp;Golang</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/2019/11/%E5%88%A9%E7%94%A8onedrive%E5%90%8C%E6%AD%A5zotero%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B9/ class=prev rel=prev title=利用onedrive同步zotero数据文件夹><i class="fas fa-angle-left fa-fw"></i>利用onedrive同步zotero数据文件夹</a>
<a href=https://shuzang.github.io/2019/11/an-attribute-based-access-control-model-in-rfid-systems.../ class=next rel=next title="An Attribute-Based Access Control Model in RFID Systems...">An Attribute-Based Access Control Model in RFID Systems...<i class="fas fa-angle-right fa-fw"></i></a></div></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt<i class="far fa-heart fa-fw"></i></a></div><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io target=_blank>shuzang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>