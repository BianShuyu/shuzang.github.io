# 区块链实验7-信誉机制设计


本文介绍信誉机制设计的思路来源，具体的想法和公式定义，以及对合约结构所作的调整。

<!--more-->

## 1. 参考论文

整体思路来自于下面论文的 Section III，B. Credit-Based PoW Mechanism，所作的调整会在本文第二部分详细解释。

> J. Huang, L. Kong, G. Chen, M.-Y. Wu, X. Liu, and P. Zeng, “Towards Secure Industrial IoT: Blockchain System With Credit-Based Consensus Mechanism,” *IEEE Trans. Ind. Inf.*, vol. 15, no. 6, pp. 3680–3689, Jun. 2019, doi: [10.1109/TII.2019.2903342](https://doi.org/10.1109/TII.2019.2903342).

作者设计了一个基于信誉的 PoW 共识机制来取得效率与安全的平衡。首先为节点 $i$ 设置一个信誉值属性 $Cr_i$，该值会随着节点的行为实时的变化。正常的行为，如遵守系统规则发送交易，会随着时间的推移使信誉值逐步增加，与之相反，节点产生异常行为会导致信誉值下降。PoW机制的难度根据每个节点的信誉值自调整，信誉值越低，运行 PoW 算法花费的时间越长。因此，诚实的节点消耗的资源更少，恶意节点攻击所需的花费更多。

这里首先声明两种系统中可能存在的恶意行为

1. Lazy Tips：懒惰的节点指那些总是验证固定的以前的交易，而不去验证最新的交易的节点。例如，恶意实体可以通过发出许多验证固定交易对的交易来人为地扩大[提示]^(tips)的数量。这会使其它节点有更高的概率选中这些提示，而丢弃属于诚实节点的提示
2. Double-spending：通过在前一次花费被验证之前提交多个交易，恶意节点希望将一枚代币花费两次或多次，这就是双花问题。尽管这样的行为会被共识机制检测到并撤销，但它降低了系统效率，因为其它相关的交易也会被撤销重新执行。

### 1.1 信誉值定义

因此，根据节点 $i$ 的行为，我们将其信誉值 $Cr_i$ 划分为两部分，公式如下
$$
Cr_i = \lambda_1 Cr_i^P + \lambda_2 Cr_i^N
$$
其中 $Cr_i^P$ 代表正面影响部分，$Cr_i^P$ 代表负面影响部分。$\lambda_1$ 和 $\lambda_2$ 分别代表各部分的权重系数，调节这两个值就可以调整两部分所占权重，比如，如果我们想要严格的惩罚策略，应该令 $\lambda_2$ 更大一点。

$Cr_i^P$ 与节点 $i$ 单位时间内正常的交易数量成正相关，即通过节点活跃程度定义，表示如下
$$
Cr_i^P = \frac{\sum_{k=1}^{n_i} \omega_k} {\Delta T}
$$
其中 $n_i$ 代表节点 $i$ 在最近的单位时间内有效交易的数量，$\Delta T$ 代表单位时间，$\omega_k$ 代表第 $k$ 个交易的权重，交易的权重指的是该交易被验证的次数。也就是说，如果节点 $i$ 在一段时间内保持活跃，$Cr_i^P$ 将根据活跃程度不断调整，保证活跃节点可以使用更少的算力更快地发布交易。如果节点 $i$ 在一段时间内没有发布交易，就认为它是不活跃的，甚至是不可信节点，所以系统不会为它降低 PoW 的难度，即 $Cr_i^P = 0$。

$Cr_i^N$ 与节点 $i$ 的恶意行为数量成负相关，可以表示为
$$
Cr_i^N = -\sum_{k=1}^{m_i} \alpha(\beta) · \frac{\Delta T}{t-t_k}
$$
其中 $m_i$ 表示节点 $i$ 的恶意行为总数，$t$ 表示当前时间，$t_k$ 表示节点 $i$ 造成的第 $k$ 个恶意行为的时间点，$\alpha(\beta)$ 表示恶意行为 $\beta$ 的惩罚系数，该系数定义如下，其中 $\alpha_l$ 和 $\alpha_d$ 可以根据对恶意行为敏感度的要求进行调整。
$$
\alpha(\beta) = \begin{cases} \alpha_l&\text{if β is lazy tips behavior;}  \\\ \alpha_d & \text{if β is double-spending behavior} \end{cases}
$$
从$Cr_i^N$ 的公式中我们可以发现，随着时间的推移，恶意行为对节点的影响在逐渐减小，但不同于 $Cr_i^P$，它无法减小到0，也就是完全消除。当一个恶意行为发生的时候，$Cr_i^N$ 的绝对值会很大，由于 PoW 难度巨大，攻击将无法持续，通过这种方式我们可以及时阻止恶意行为。

该机制正常运行的需求是我们可以获取每个节点相关的所有交易，这样就可以计算出交易权重 $\omega$ 和 恶意行为记录 $\alpha(\beta)$，从而可以独立地计算出 $Cr_i^P$ 和 $Cr_i^N$，最终得到信誉值。作者在论文中将信誉值与 PoW 难度关联，具体来说，这两种成反比，定义公式为 $Cr_i = \delta \frac 1{D_i}$，其中 $D_i$ 为节点 $i$ 的 PoW 难度，$\delta$ 为比例系数。这样，信誉值高的难度低，信誉值低的难度高，难度的调整通过控制前缀0的最小长度完成，整个系统得以实现。

### 1.2 参数设置

具体的实验中以上公式中的相关参数如何设置，作者给出了一些描述。交易权重 $\omega$ 可以直接计算，两个权重系数设置为 $\lambda_1 = 1,\lambda_2 = 0.5$，因为 $Cr_i^N$ 的值可能相对比较大，如果想要更严厉的惩罚措施，$\lambda_2$ 可以设置的更大。考虑到 IIoT 系统的请求频率，单位时间设置为 $\Delta T = 30s$，一个不是太长的间隔。对于 lazy tips，设置 $\alpha(\beta) = 0.5$，对于 double-spending，设置 $\alpha(\beta) = 1$，因为双花对系统造成的损害更严重。

 ## 2. 设计细节

### 2.1 惩罚

我们取信誉值的负面影响部分 $Cr_i^N$ 定义为惩罚函数，惩罚函数的值与恶意行为的数量和类型有关，每个恶意行为的影响随着时间的推移逐渐减小，但不可以变为0，具体的函数如下
$$
Cr_i^N = \sum_{k=1}^{m_i} \alpha(\beta) · \frac{\gamma}{t-t_k}
$$
其中 $m_i$ 表示设备 $i$ 的恶意行为总数，$t$ 表示当前时间，$t_k$ 表示设备 $i$ 造成的第 $k$ 个恶意行为的时间点，$\alpha(\beta)$ 表示恶意行为 $\beta$ 的惩罚系数，在0-1内取值，该系数定义如下，可以根据对恶意行为敏感度的要求进行调整。
$$
\alpha(\beta) = \left \lbrace 
\begin{array}{ll}
\alpha_1 & \text{如果 β 代表非法的属性或策略修改请求 ;}  \\\ 
\alpha_2 & \text{如果 β 非法的访问控制请求; } \\\ 
\alpha_3& \text{如果 β 代表短时间发起大量请求} 
\end{array} \right.
$$
我们采取的惩罚是阻塞设备的访问请求，意思是计算一个阻塞时间，从当前时间开始的这一段时间内，来自该设备的所有访问请求都被拒绝。阻塞时间根据如下指数函数来计算，可以看出，惩罚函数的值越大，阻塞时间越长。
$$
T_{Blocked} = 2^{Cr_i^N}
$$
惩罚函数中的 $\gamma$ 用来控制恶意行为频率，因为在 $\gamma = 1$ 的情况下，惩罚函数的值总是小于 1 的，这就意味着随之计算得到的阻塞时间会比较小。如果将 $\gamma$ 调大，比如 5，就意味着一旦两次恶意行为的间隔小于 5s （$t-t_k \lt 5$），函数的值会大于1，从而计算得到的阻塞时间会呈指数增长。

每一次恶意行为记录的提交都会触发惩罚函数和阻塞时间的计算，将当前时间加上阻塞时间会得到一个惩罚终止时间，这个终止时间是设备的一个属性，信誉合约需要对其进行更新。所有的 ACC 在进行访问请求判定时，会读取设备该属性判断是否在阻塞期。

### 2.2 奖励

对合法的行为可以做出奖励，即减少阻塞时间。奖励函数可以利用信誉值的正面影响部分 $Cr_i^P$ 表示。$Cr_i^P$ 应与合法的行为数量有关，可以简单定义为 $Cr_i^P = \delta_1 N$，其中 $N$ 为合法行为数量。这里的合法行为可以包括

1. 普通的增删改操作行为。比如对设备、设备属性、策略等的增删改，这些操作执行完成后，行为记录会发送给信誉合约进行计算。增(Register or Add)、改(Update)、删(Delete)三个操作行为的 ID 分别定义为1，2，3.
2. 访问控制。当设备发起的访问控制通过时，信誉合约接收行为记录并计算信誉值，访问控制通过的行为 ID 为 4

我们对四种不同的行为设置不同的权重，最终的 $Cr_i^P$ 定义如下，其中 $\omega_k$ 代表第 $k$ 种操作的权重，$n_k$ 代表第 $k$ 种操作的数量

$$
Cr_i^P = \sum_{k=1}^4 \omega_k n_k
$$

$Cr_i^P$到奖励时间的转换应该是线性的，因为我们认为合法行为的累积不应当导致奖励时间迅速增加，我们在此给出一个合法行为数量上限 $N_{max}$，则奖励时间 $T_{Reward}$ 定义如下
$$
T_{Reward} = \frac{Cr_i^P}{N_{max}} \times T_{Blocked}
$$
注意，计算 $T_{Reward}$ 前需要判定 $Cr_i^P$，若其值大于 $N_{max}$，则置为 $N_{max}$，否则奖励时间就会大于阻塞时间，这是不合适的。

每一次合法行为的提交都会更新合法行为列表，但只有当前设备处于阻塞期，才会计算奖励时间，然后从惩罚终止时间种减去奖励时间，从而使设备的惩罚更早的结束。这里需要注意的是，产生恶意行为并做出惩罚时，并不会立即根据历史行为计算奖励时间，而是在下一次合法行为产生时进行计算。奖励时间计算完毕后，要清空当前的合法行为记录，因为它们以及起到了自己的作用。与之相对的，恶意行为记录永远不会清空，虽然它们产生的影响随着时间的推移变小，但不可能消失，因此每次惩罚函数计算都会读取所有恶意行为。

### 2.3 参数设置

我们暂时将参数设置为

1. 惩罚函数中，$\alpha_1 = 0.5, \alpha_2 = 0.5, \alpha_3 = 1$，因为第三种恶意行为影响更恶劣；
2. 惩罚函数中，$\gamma = 5$，这是直觉判断，需要后续更正；
3. 奖励函数中，$\omega_1 = 0.5, \omega_2 = 0.5, \omega_3 = 0.5, \omega_4 = 1$，因为访问控制通过是主要的合法行为
4. 奖励时间中，$N_{max} = 10$，也是一个直觉判断，需要后续更正

**曾思考过的问题**

1. 设备信誉值不应当与设备活跃程度有关，某种设备可能短时间一次请求都不发起，但这种情况不应当对设备信誉值产生影响
2. 如果设备一直遵守规则，信誉值会保持不断增长，最终可能导致超限。因此需要为信誉值设置上限和下限
3. 设备前期累积的信誉值不应当与设备产生的特定恶意行为抵消，也就是说，设备产生了某种特别恶劣的行为，即时它前期积累了很高的信誉，也必须惩罚

## 3. 智能合约实现

### 3.1 合约结构

系统中共有三种合约：管理合约（Management Contract, MC），访问控制合约（Access Control Contract, ACC），信誉合约（Reputation Contract, RC），相互间的调用关系如下图

![合约架构](/images/区块链实验7-信誉机制设计/合约架构.png)

管理合约（Management Contract, MC），负责管理合约和设备属性。在设备属性中新增TimeofUnblock 字段，用于设置阻塞终止时间，该字段只能被信誉合约更新。MC中各种操作行为会产生日志并提交给信誉合约

访问控制合约（Access Control Contract，ACC），负责管理资源属性、策略和执行访问控制。在执行访问控制判断时，会首先从 MC 读取 TimeofUnblock 字段，查看是否大于当前时间，如果大于则阻塞请求，否则通过。同样，ACC 中的所有行为记录也会提交到 RC

信誉合约（Reputation Contract, RC），负责根据 MC 和 ACC 提交的记录计算信誉函数的值，并根据该值计算阻塞终止时间，最后调用 MC 的相关函数更新设备的 TimeofUnblock 字段。

### 3.2 合约测试

首先明确各部分部署的先后顺序

1. 系统管理者部署 MC，获得合约地址 mc
2. 监管机构部署 RC，传入参数 mc，并获得合约地址 rc
3. 系统管理者调用 setRC()  进行设置，传入 rc 和 监管机构的区块链账户地址
4. 设备管理者部署 ACC，传入 mc, rc 和 设备管理者地址
5. 设备管理者调用 MC 中的 deviceRegister() 函数，注册设备相关属性

此外，测试前的准备工作还有

1. 设备管理者调用 ACC 中的 addPolicy()  添加针对某个资源的策略
2. 将要发起请求的设备在 MC 中注册自身

接下来就可以执行测试了，Subject 首先根据设备的区块链地址从 MC 中获取设备的 ACC 合约地址，或者直接从网络获取设备管理者公布的 设备 ACC 合约地址，然后发起调用 accessControl() 函数，传入参数为要访问的资源和要执行的操作。返回的结果为 true 或 false，同时，调用者地址、结果、结果说明、访问时间等会通过事件发送出去，可以在 Js 中通过调用事件查看。

## 4. 实验设计

之前的实验中没有得到更具体的实验结果，而且手动编辑配置文件、创建节点、组建网络实在是一件耗费时间而且错误率较高的事情，现有的 Quorum 网络浏览器也都不支持直接建立在宿主机的Quorum网络上，而是建立在 Docker 集群上。所以，为了更好的进行实验和得到结果，新的实验使用 Docker 集群建立 Quroum 网络，使用开源工具 [quorum-maker](https://github.com/synechron-finlabs/quorum-maker/tree/master/lib) 可以简化网络搭建的流程。

利用 quorum-maker 建立基于 Docker 的 Quorum 网络，由于该工具暂时不支持 IBFT 共识算法，我们只能使用 Raft 共识。树莓派作为轻节点加入已有 Quorum 网络，职责是普通 IoT 设备的代理。同时，quorum-maker 提供了 Web UI  作为区块链浏览器，可查询关于区块、交易和合约的相关信息，满足我们的基本需求。

接下来确认我们需要测量的值

1. 智能合约部署的 Gas 消耗和时间消耗：这些值看起来测量没有意义，但作为一种常用测量值和人们通常关注的方面，简单的给出结果；
2. 惩罚函数的值随时间的变动：虽然没有想通的一件事是函数给出后，变动曲线可以随之画出来，其趋势是可知的，为什么还要测量具体的值。但别的论文都这么做而且绘制图表，看起来是大家都关心的方面，所以作为待测量的一个方面；
3. 进行一次访问控制的时间消耗：这是最重要也最有必要的一件事，我们可以确定 ABAC 模型相比于传统的 ACL 是更加物联网友好的，但对于同样的 ABAC 设计实现，究竟哪种结构实施访问控制比较快，还有待验证，这也是做物联网访问控制人们最关心的一件事。

合约部署消耗很容易可以得到，关于惩罚函数的值在确定相关权重值后也可以得到，而访问控制的时间消耗，我们可以将其看作调用 AccessControl() 合约函数的交易执行时间。现有的难点是网络搭建方面的，即树莓派如何连接到 宿主机 Docker 集群构成的 Quorum 网络的问题。

简单的进行接下来的时间规划

1. 完善现有合约设计，实现惩罚函数（两周）
2. 使用 quorum-maker 基于 Docker 搭建 Quorum 网络，并将树莓派作为轻节点连接（两周）
3. 部署合约并获得相关测量结果
