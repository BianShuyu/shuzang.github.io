---
title: 操作系统-存储空间和堆栈
date: 2020-07-12T09:22:00+08:00
lastmod: 2020-07-12
tags: [操作系统, Golang]
categories: [爱编程爱技术的孩子]
slug: memory stack and heap
typora-root-url: ..\..\..\static
---

本节介绍计算机堆栈的概念，并顺便介绍计算机存储空间。

<!--more-->

## 1. 存储器组织

关于计算机存储器组织的相关问题，在汇编的课程中。

尽管现在计算机采用 Cache—主存—辅存 的三级结构，但为了解释起来简单，我们将前两者统称为主存。主存的物理实体就是我们常说的内存条（事实上还有一些其它的存储器），主要作用是保存正在运行的指令与数据，注意，这里的关键是**正在运行**，这也意味着计算机关机后主存数据将会被清除，这一点也是主存与外存的区别。

计算机运行时会不断地执行各种指令，指令从主存中读取，执行指令过程中需要的数据也从主存读取，这里读取的含义其实是取数据副本，在新的数据写入前，原本的数据不会被主动擦除。因此，与存储器相关的最基本的操作是写入和读出数据，完成这一工作我们首先需要对主存进行编址，这样才能在需要时找到对应的指令和数据。

### 1.1 存储单元

现代计算机系统存储的基本单位是一个二进制位（bit，比特），每位可存储一个二进制数 0 或 1，一般用小写字母 b 表示。8 个二进制位组成一个字节（Byte），用大写字母 B 表示。

对主存进行编址时，其基本单位叫做存储单元，为每一个存储单元分配一个顺序号码，就是该存储单元的地址。现代计算机一个存储单元一般就是一个字节，称为字节编址（Byte Addressable），所以，通过任何一个存储器地址可以访问到一个字节的信息。主存的总容量就是这些存储单元的集合，为了表达比字节更大的存储空间，人们分配了一些常用的单位，如下表

| 英文符号 | 中英文名称       | 二进制倍数关系           |
| -------- | ---------------- | ------------------------ |
| K        | 千（Kilo）       | 1KB=$2^{10}B$=1024B      |
| M        | 兆（Mega）       | 1MB=$2^{10}KB$=$2^{20}B$ |
| G        | 千兆，吉（Giga） | 1GB=$2^{10}MB$=$2^{30}B$ |
| T        | 兆兆，太（Tera） | 1TB=$2^{10}GB$=$2^{40}B$ |

### 1.2 地址

明白了编址方式，我们还需要明白CPU如何访问主存，在物理上，CPU通过总线来访问主存。总线分为三种：地址总线，数据总线和控制总线，分别用来传输数据地址、数据和控制信号。所以，与寻址相关的是地址总线，直接决定了计算机可直接寻址的空间大小。

最初的8位机地址总线为16位，可寻址空间最大 64KB。6位机地址总线20位，可寻址空间最大1MB。32位机的地址总线也是32位，可寻址的空间上限就只有 $2^{32}B = 4GB$，所以一个32位计算机最大只支持4GB的内存。现在计算机普遍都是64位，采用地址总线位数暂时不太清楚，不过，所支持的最大内存通常是128G，足以满足我们的需要。

主存地址的编号习惯上用十六进制数表达，一个4GB 的内存对应二进制的32位，1个16进制数是4位，所以可以用8位十六进制数表达一个 4GB 的内存的物理空间：00000000H~FFFFFFFFH

但是，计算机的寄存器通常是16位的，可以表达的存储大小上限为 64KB（$2^{16}B$），于是，计算机会将主存分成许多不超过 64KB 的区域进行管理，这种区域被称为（区）段（Segment），计算机原理和程序设计中也常被称为逻辑段。所以，计算机的寻址在逻辑上实际上是两级的，先在主存中找到逻辑段的地址（叫做段基地址），然后以段基地址为起点，偏移一定的量找到指令或数据（这个偏移量叫做偏移地址）。

最后，根据所存数据类型的不同，计算机设计了4种类型的逻辑段，有4个段寄存器分别保存对应段的段基地址，如下表

| 段名称 | 段的作用                     | 段基地址 | 偏移地址 |
| ------ | ---------------------------- | -------- | -------- |
| 代码段 | 存放程序的指令序列           | CS       | IP       |
| 堆栈段 | 确定堆栈所在的主存区域       | SS       | SP       |
| 数据段 | 存放当前运行程序所用的数据   | DS       | EA       |
| 附加段 | 附加的数据段，也用于保存数据 | ES       | EA       |

程序的指令代码必须存放在代码段，否则将无法正常执行。程序利用代码段寄存器 CS获得当前代码段的段基地址，指令指针寄存器IP保存代码段中指令的偏移地址。处理器利用CS:IP取得下一条要执行的指令。

程序使用的堆栈（临时存放数据的区域）一定在堆栈段。程序利用SS获得当前堆栈段的段基地址，堆栈指针寄存器SP保存堆栈栈顶的偏移地址。处理器利用SS:SP操作堆栈数据。

一个程序可以使用多个数据段，便于安全有效地访问不同类型的数据。例如，程序的主要数据存放在一个数据段，只读的数据存放在另一个数据段，动态分配的数据安排在第3个数据段。

段基地址的低4位均为0，因为一个段最大不超过64KB，下面是一个分段管理的简单例子

![](/images/操作系统-存储空间与堆栈/epub_773370_14.jpg)

注：上述的讨论基本都是基于8086，64位机不是很清楚内部机理，主要因为现有的教材基本都是介绍的8086。但是已知的，64位系统的寄存器是64位的。

## 2. 虚拟地址空间

这部分知识位于操作系统课程。

一个进程的执行过程中，大部分的程序和数据并不经常访问，所以被放到外存中，需要时才会调入内存。用户编写的程序，在编译后才能形成 CPU 可执行的目标代码，显然，不同程序段的目标代码会有不同的地址。

有两种办法安排这些目标代码的地址，一种是按照前面所述的寻址方式赋予实际的物理地址，这样做的好处是CPU执行目标代码时速度会比较快。但是，由于内存的容量限制，同时装入内存并发执行的进程数量必然会受到极大的限制，甚至对于某些进程，当所需求的容量超过内存容量，将会无法执行。另外，编译程序也必须知道内存当前的空闲部分的地址，并且把一个进程的不同程序段连续地存放起来，因此编译程序将比较复杂。

另一种方法是编译链接程序将用户源程序编译后链接到一个以 0 为起始地址的虚拟地址空间，每个进程都拥有这样一个空间，每个指令或数据单元都在该空间中有个确定的地址，称为虚拟地址。最后通过设定虚拟地址到物理地址的转换方式，计算机同样可以访问目标指令和数据。

每个进程的虚拟地址空间也成为进程空间或虚空间，不受物理存储器的限制，只与计算机位数有关。例如，16位计算机进程空间大小为 $2^{16}$，64位计算机进程空间大小为 $2^{64}$。程序的执行都在进程空间内进行，用户程序、进程的各种控制表格等都按一定的结构排列在进程空间中。

对于 UNIX 和 Linux 等操作系统，进程空间还被划分为用户空间和系统空间两部分，用户程序在用户空间执行，操作系统内核程序在系统空间执行。另外，为了防止用户程序访问系统空间，造成错误，计算机系统还通过程序状态寄存器设置了用户模式和系统模式两种执行模式，这两种模式通常也被称为用户态和系统态。

网上的一些文章通常把用户空间叫做内核空间，下面是一个32位系统的Linux进程空间示意图，其中0-3G被划分为用户空间，3-4G被划分为内核空间。

![](/images/操作系统-存储空间与堆栈/091011_1614_Linux2.png)

## 3. 堆栈

数据结构中栈满足后入先出的特性，在计算机系统中，也有一块满足该特性的动态内存区域，程序可以将数据压入栈中已经将数据从栈中弹出，从而使栈动态的增大或减小。通常，栈是向下增长的，即入栈操作使得栈顶地址减小，出栈操作使得栈顶地址增加。

除此之外，堆也是计算机中的一中内存区域。堆与栈的区别如下

1. 栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放
2. 栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量，实际上，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面
3. 栈的访问速度相对比堆快
4. 一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。
5. stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。

在C/C++中，程序员申请的内存空间使用完毕后需要自己释放，在Java、Go等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。

## 4. Go跟踪堆栈

我们理解堆栈主要是为了更好的理解程序，所以，这里介绍如何在Go调试的时候查看堆栈跟踪信息及识别传递的参数。

测试使用的版本是Go 1.14.3

示例程序如下

```go
package main

import (
	"runtime/debug"
)

func main() {
	slice := make([]string, 2, 4)
	Example(slice, "hello", 10)
}
func Example(slice []string, str string, i int) {
	debug.PrintStack()
}
```

在程序中我们使用了 runtime/debug 下的 PrintStack() 函数将调用栈的返回信息打印到标准错误输出，如下所示

```go
goroutine 1 [running]:
runtime/debug.Stack(0x0, 0x0, 0x0)
	c:/go/src/runtime/debug/stack.go:24 +0xa8
runtime/debug.PrintStack()
	c:/go/src/runtime/debug/stack.go:16 +0x29
main.Example(0xc000077f38, 0x2, 0x4, 0x4a8534, 0x5, 0xa)
	f:/Gotest/main.go:13 +0x2e
main.main()
	f:/Gotest/main.go:9 +0xb1
Process exiting with code: 0
```

注意，在其它编程语言如C中，运行一个程序会启动一个线程来执行，在Go中，启动的是一个 Goroutine。上面第一行就说明了启动了一个 Goroutine，Goroutine ID 为1，其后各行是不同层次的调用，最深的调用最先打印，最浅的调用最后打印。各行说明如下

第8、9行：main package 的 main 函数，代码文件路径为 `f:/Gotest/main.go`，调用出现在 main.go 文件的第9行

第6、7行：main 函数调用 Example 函数

第4、5行：Example 函数调用 debug.PrintStack 函数

第2，3行：debug.PrintStack 函数调用 debug.Stack 函数

Example 函数传参信息如下

```go
// 调用
slice := make([]string, 2, 4)
Example(slice, "hello", 10)
// 栈追踪
main.Example(0xc000077f38, 0x2, 0x4, 0x4a8534, 0x5, 0xa)
```

堆栈跟踪信息中，前三个参数分别代表切片的指针、长度、容量，第4和第5个参数代表字符串的指针和大小，最后一个参数指向整型数值

```go
// 切片
Pointer: 0xc000077f38
Length: 0x2
Capacity: 0x4
// 字符串
Pointer: 0x4a8534
Length: 0x5
// 整数
base 16: 0xa
```

如果是调用方法，跟踪信息会显示接收者

```go
// 程序
package main

import (
   "fmt"
   "runtime/debug"
)

type trace struct{}

func main() {
   slice := make([]string, 2, 4)
   var t trace
   t.Example(slice, "hello", 10)
}
func (t *trace) Example(slice []string, str string, i int) {
   fmt.Printf("Receiver Address: %p\n", t)
   debug.PrintStack()
}
// 堆栈信息
Receiver Address: 0x5781c8
goroutine 1 [running]:
runtime/debug.Stack(0x15, 0xc000071ef0, 0x1)
	C:/Go/src/runtime/debug/stack.go:24 +0xae
runtime/debug.PrintStack()
	C:/Go/src/runtime/debug/stack.go:16 +0x29
main.(*trace).Example(0x5781c8, 0xc000071f48, 0x2, 0x4, 0x4c04bb, 0x5, 0xa)
	D:/gopath/src/example/example/main.go:17 +0x7c
main.main()
	D:/gopath/src/example/example/main.go:13 +0x9a
```

传递的参数全部为值类型时，可能会防止一个32位的字中

```go
// 程序
import (
   "runtime/debug"
)

func main() {
   Example(true, false, true, 25)
}
func Example(b1, b2, b3 bool, i uint8) {

   debug.PrintStack()
}
// 堆栈信息
goroutine 1 [running]:
runtime/debug.Stack(0x4, 0xc00007a010, 0xc000077f88)
	C:/Go/src/runtime/debug/stack.go:24 +0xae
runtime/debug.PrintStack()
	C:/Go/src/runtime/debug/stack.go:16 +0x29
main.Example(0xc019010001)
	D:/gopath/src/example/example/main.go:12 +0x27
main.main()
	D:/gopath/src/example/example/main.go:8 +0x30
```

可以看到 Example 的参数只有一个，实际上底层四个参数放在一个字中

```go
// Parameter values
true, false, true, 25

// Word value
Bits    Binary      Hex   Value
00-07   0000 0001   01    true
08-15   0000 0000   00    false
16-23   0000 0001   01    true
24-31   0001 1001   19    25
```

关于在Go中，变量究竟是放在堆还是栈里，官方有这么一段解释

> 只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。
>
> 在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。
>
> 总之，分配在堆还是栈完全由编译器确定。

通过 `go tool compile` 命令可以反编译代码为汇编代码

```go
package main

import "fmt"

func main() {
	var a [1]int
	c := a[:]
	fmt.Println(c)
}

```

反编译

```bash
$ go tool compile -S main.go
...   
        0x0028 00040 (main.go:6)        PCDATA  $0, $1
        0x0028 00040 (main.go:6)        PCDATA  $1, $0
        0x0028 00040 (main.go:6)        LEAQ    type.[1]int(SB), AX
        0x002f 00047 (main.go:6)        PCDATA  $0, $0
        0x002f 00047 (main.go:6)        MOVQ    AX, (SP)
        0x0033 00051 (main.go:6)        CALL    runtime.newobject(SB)
        0x0038 00056 (main.go:6)        PCDATA  $0, $1
        0x0038 00056 (main.go:6)        MOVQ    8(SP), AX
        0x003d 00061 (main.go:8)        PCDATA  $0, $0
        0x003d 00061 (main.go:8)        MOVQ    AX, (SP)
        0x0041 00065 (main.go:8)        MOVQ    $1, 8(SP)
        0x004a 00074 (main.go:8)        MOVQ    $1, 16(SP)
...
```

其中有调用 runtime.newobject 就说明 main.go 第6行 的数组变量 a 分配在堆上。反之，如果没有发现 runtime.newobject 调用，就说明分配在栈上。



## 参考

[1] [Go堆栈的理解](https://segmentfault.com/a/1190000017498101)

[2] 阮一峰，[栈的三种含义](http://www.ruanyifeng.com/blog/2013/11/stack.html)

[3] [官方关于变量分配在堆还是栈上的说明](https://golang.org/doc/faq)