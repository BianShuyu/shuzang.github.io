---
title: 数据结构-图
date: 2020-03-16
lastmod: 2020-03-16
tags: [数据结构与算法]
categories: [爱编程爱技术的孩子]
slug: data structure graph
---

链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。

## 1. 图的定义

用 V(Vertex) 表示顶点的集合，用 E(Edge) 表示边的集合，则图可以看作由一个非空的有限顶点集合V和一个有限边的集合组成，记作G(V, E)。其中

- 边可以表示为顶点对：(v, w) ∈ E，其中 v, w ∈ V
- 小括号包含的两个顶点表示无向边，有向边可以用 <v, w> 表示
- 不考虑重边和自回路

因为图涉及的概念比较多，因此我们不会像树那样一次性全部列出来，而是用到的时候进行解释，下面是一个图的例子和上面提到的几个概念。

![](https://s1.ax1x.com/2020/03/16/8Y0u9K.png)

关于图的操作集有很多，但最基本的如下

- Create()：建立并返回空图
- InsertVertex(Graph G, Vertex V)：将顶点 V 插入图 G
- InsertEdge(Graph G, Edge E)：将边 E 插入图 G
- DFS(Graph G, Vertex V)：从顶点 V 出发深度优先遍历图 G
- BFS(Graph G, Vertex V)：从顶点 V 出发广度优先遍历图 G
- ShortestPath(Graph G, Vertex V, int Dist[])：计算图 G 中顶点 V 到任意其它顶点的最短距离
- MST(Graph G)：计算图的最小生成树

## 2. 图的表示

图的表示有**很多种方法**，但最常用的是邻接矩阵和邻接表

### 2.1 邻接矩阵

通过邻接矩阵$G[N] [N]$表示图，首先将 N 个顶点从0到 N-1 编号，然后按如下公式填入数值，即如果两个顶点有边连接，填入0，如果没有边，则填入
$$
G[N][N] = \begin{cases} 0& 若<v_i,v_j>是G中的边 \\\ 1& 否则 \end{cases}
$$
以第一部分的示例无向图为例，其邻接矩阵形式如下图

![图的邻接矩阵表示](https://s1.ax1x.com/2020/03/16/8Y03Bd.png)

实际编程时，通常使用二维数组的形式存储。但对于无向图，邻接矩阵是对称的，通过只存储下三角矩阵或上三角矩阵的形式，可以节省一半的存储空间。

![下三角邻接矩阵](https://s1.ax1x.com/2020/03/16/8Y0U9f.png)

对于有向图来讲，邻接矩阵并不是对称的，因此不能采用这种方式。

下面介绍一个新的概念：顶点的度。对于无向图，顶点连接的边的数量称作顶点的度，对有向图来讲，从顶点发出的边数称作「出度」，指向该点的边数称作「入度」。对应到邻接矩阵中

- 无向图：度是对应行（或列）非0元素的个数
- 有向图：对应行非0元素的个数是「出度」，对应列非0元素的个数是「入读」

### 2.2 邻接表

如果是稠密图（边很多），使用邻接矩阵比较合适。如果是稀疏图（点很多而边很少），存在大量的无效元素，使用邻接矩阵会浪费大量的存储空间，这种情况可以使用邻接表来存储。

将所有顶点用一个指针数组$G[N]$表示，指向该顶点所有相邻顶点构成的链表（顺序不重要，可以随意），同样以第一部分的示例无向图为例，邻接表如下

![邻接表](https://s1.ax1x.com/2020/03/16/8Y0DBj.png)

对于网络，链表节点中需要增加表示权重的域。邻接表方便寻找任一顶点的所有邻接点，可以节省存储空间，但对有向图无法计算顶点的出度，需要构造「逆邻接表」

## 3. 图的构建

我们以邻接表形式存储，定义图的结构体如下

```go
type Vertex struct {
	Value     int  //顶点值
	isVisited bool //遍历算法中用来表示是否被访问过

}

//一张图包含一个顶点集和一张邻接表
type Graph struct {
	Vertices []*Vertex             //一个指针数组，每个元素指向一个顶点
	AdjList  map[*Vertex][]*Vertex //每个结点关联一个顶点集
}
```

为了方便测试，不建立 CreateVertex() 和 CreateEdge() 函数，而是直接对结构体进行初始化从而创建图

```go
func CreateGraph() *Graph {
	g := &Graph{}
	g.Vertices = []*Vertex{&Vertex{0, false}, &Vertex{1, false}, &Vertex{2, false}, &Vertex{3, false}, &Vertex{4, false}, &Vertex{5, false}}
	g.AdjList = map[*Vertex][]*Vertex{}
	g.AdjList[g.Vertices[0]] = []*Vertex{g.Vertices[1], g.Vertices[2], g.Vertices[3]}
	g.AdjList[g.Vertices[1]] = []*Vertex{g.Vertices[0], g.Vertices[4]}
	g.AdjList[g.Vertices[2]] = []*Vertex{g.Vertices[0], g.Vertices[4]}
	g.AdjList[g.Vertices[3]] = []*Vertex{g.Vertices[0]}
	g.AdjList[g.Vertices[4]] = []*Vertex{g.Vertices[1], g.Vertices[2], g.Vertices[5]}
	g.AdjList[g.Vertices[5]] = []*Vertex{g.Vertices[4]}
	return g
}
```

## 4. 图的遍历

有深度优先（Depth First Search, DFS）和广度优先（Breadth First Search, BFS）两种，前者类似于树的先序遍历，后者类似于树的层次遍历

### 4.1 深度优先遍历

递归解法的程序实现如下

```go
func DepthFirstSearch(g *Graph, v *Vertex) {
	v.isVisited = true
	for _, vertex := range g.AdjList[v] {
		if !(*vertex).isVisited {
			DepthFirstSearch(g, vertex)
		}
	}
}
```

非递归解法的程序实现如下

```go
func DepthFirstSearch(g *Graph, v *Vertex) {
	v.isVisited = true
	stack := list.New()
	stack.PushBack(v)
	for stack.Len() != 0 {
		v := stack.Back().Value.(*Vertex)
		hasNewVertex := false
		for _, vertex := range g.AdjList[v] {
			if !(*vertex).isVisited {
				(*vertex).isVisited = true
				hasNewVertex = true
				stack.PushBack(vertex)
			}
		}
		if !hasNewVertex {
			stack.Remove(stack.Back())
		}
	}
}
```

### 4.2 广度优先遍历

```go
func BreadthFirstSearch(g *Graph, v *Vertex) {
	v.isVisited = true
	queue := list.New()
	queue.PushBack(v)
	for queue.Len() != 0 {
		v := queue.Remove(queue.Front()).(*Vertex)
		for _, vertex := range g.AdjList[v] {
			if !(*vertex).isVisited {
				(*vertex).isVisited = true
				queue.PushBack(vertex)
			}
		}
	}
}
```

未完待续……