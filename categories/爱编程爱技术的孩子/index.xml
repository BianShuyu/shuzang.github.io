<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>爱编程爱技术的孩子 - 分类 - Shuzang's Blog</title><link>https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/</link><description>爱编程爱技术的孩子 - 分类 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 18 Oct 2020 10:16:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/" rel="self" type="application/rss+xml"/><item><title>计算机基础-实数在计算机中的存储</title><link>https://shuzang.github.io/storage-of-reals-in-computers/</link><pubDate>Sun, 18 Oct 2020 10:16:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/storage-of-reals-in-computers/</guid><description><![CDATA[<p>最近在智能合约中实现信誉算法，但是 Solidity 不支持浮点数赋值和运算，好在有人写了一个库实现了 IEEE 754 浮点数标准，只不过输入输出都是二进制，所以回过头来仔细理解一下实数在计算机中的存储。</p>
<h2 id="1-实数">1. 实数</h2>
<p>实数就是带有整数部分和小数部分的数字。</p>
<h2 id="2-实数的定点表示">2. 实数的定点表示</h2>
<p>定点表示就是固定小数点的表示法，比如 23.75，就可以表示为 $(10111.11)_2$
$$
23.75 = 23 + 0.75 = (2^4 + 2^2 + 2^1 + 2^0) + (2^{-1} + 2^{-2})
$$
但是，由于不确定整数部分和小数部分各需要多少位来存储，很容易出现精度的丢失。</p>
<ul>
<li>小数部分精度受损：用 16 位二进制数表示一个实数，其中整数部分 14 位，小数部分 2 位，此时存储十进制数 1.00234 就会损失精度，最终存储在计算机中的结果是 1.00</li>
<li>整数部分精度受损：用 16 位二进制数表示一个实数，其中整数部分 2 位，小数部分 14 位，此时存储十进制数 10.00234 就会损失精度，最终存储在计算机中的结果是 2.00234</li>
</ul>
<p>因此，为了维持精度，在计算机中存储实数通常采用的是浮点表示法。</p>
<h2 id="3-实数的浮点表示">3. 实数的浮点表示</h2>
<p>浮点的意思是允许小数点浮动，比如，当我们表示十进制数 7500.24 时，采用科学计数法可以将小数点左移 3 位，从而表示为 $7.50024 \times 10^3$，写作 +7.50024E3。通过这种方式我们就可以控制小数点左右任一部分的数字个数，从而便于存储，一般情况我们会在小数点左边仅保留 1 位。</p>
<h3 id="31-规范化">3.1 规范化</h3>
<p>科学计数法用于十进制数，当这种小数点浮动的方法用于二进制数时，就叫做浮点表示法。</p>
<p>以上面的数字 23.75 为例，其二进制表示为 $(10111.11)_2$，采用浮点表示法，可以表示为 $1.011111 \times 2^4$。我们通常将这样一个数字划分为三部分：<code>符号 Sign</code>，<code>指数 Exponent</code> 和 <code>尾数 Mantissa</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">+       2^4   ×   1.011111      // 浮点表示
--------------------------
+        <span class="m">4</span>         <span class="m">011111</span>       // 拆分
↑        ↑            ↑
sign  Exponent    Mantissa      // 含义
</code></pre></td></tr></table>
</div>
</div><p>符号位用一个二进制位表示，0 表示正，1 表示负；尾数指的是小数点右侧的二进制数，定义了该数的精度，小数点和小数点左侧的 1 没有存储，它们是隐含的；指数是小数点移动的位数，使用余码表示法存储，下面进行介绍。</p>
<p>余码表示法的出现是因为指数也有符号，比如 $(10111.11)_2$ 的浮点表示为 $1.011111 \times 2^4$，此时指数为正整数 4，但是$(0.00101)_2$ 的浮点表示为 $1.01 \times 2^{-3}$，此时指数为负整数 -3。如果不想在指数部分使用一个额外的符号位，就要想一种别的表示法，这就是<strong>余码表示法</strong>。下面我们通过一个例子来介绍它。</p>
<p>4 位的二进制数可以表示 16 个整数，即 -7 到 8，我们采用对它们统一加一个偏移量的方法来把这些数字全部变成非负整数，这个例子中，我们对所有的数字统一 +7，这样十六个整数就变成了 0 到 15，如下图</p>
<p></p>
<p>这种加一个偏移量的方法并没有改变数字之间的相对位置，因此当我们得到这样一个数字，又知道了它的偏移量，是可以转换回原本的数字的，这种方法就叫做余码表示法。上例中，偏移量为 7，所以更具体一点可以称为余7码。</p>
<h3 id="32-ieee-754标准">3.2 IEEE 754标准</h3>
<p>IEEE 制定的 754 标准是关于计算机软硬件浮点数表示和运算的标准，被各大硬件厂商和编程语言所采用。该标准的内容其实就是浮点表示法的三部分各占多少位，如下表</p>
<table>
<thead>
<tr>
<th></th>
<th>单精度(Single Precision)</th>
<th>双精度(Double Precision)</th>
<th>四精度(Quadruple Precision)</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字位数</td>
<td>32</td>
<td>64</td>
<td>128</td>
</tr>
<tr>
<td>符号位数</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>指数位数</td>
<td>8</td>
<td>11</td>
<td>15</td>
</tr>
<tr>
<td>尾数位数</td>
<td>23</td>
<td>52</td>
<td>112</td>
</tr>
<tr>
<td>偏移量</td>
<td>127</td>
<td>1023</td>
<td>16383</td>
</tr>
</tbody>
</table>
<ul>
<li>精度：当用 32 位二进制数表示时，我们称为单精度，当用 64 位表示时，我们称为双精度。</li>
<li>偏移量：偏移量的计算方法为 $2^{m-1}-1$，$m$ 是指数位数。偏移量是多少，就是余多少码，比如，单精度偏移量为 127，就是余127码。</li>
</ul>
<p>一个实数转换为浮点数表示的步骤为</p>
<ol>
<li>确定符号位 S；</li>
<li>将数的绝对值转换为二进制数；</li>
<li>规范化二进制数；</li>
<li>确定指数 E 和尾数 M，尾数不足在右侧补0；</li>
<li>将 SEM 相连。</li>
</ol>
<p>下面用一些例子来说明该过程，以及给定一个浮点数的二进制表示表示如何反向计算出这个实数。</p>
<p><strong>Example 1</strong>：写出十进制数 -0.0234375 的余127码（单精度）表示法</p>
<ol>
<li>
<p>S = 1（符号位为负）</p>
</li>
<li>
<p>十进制转换二进制：$0.0234375 = (0.0000011)_2$</p>
</li>
<li>
<p>规范化：$(0.0000011)_2 = (1.1)_2 \times 2^{-6}$</p>
</li>
<li>
<p>指数 $E = -6 + 127 = 121 = (01111001)_2$，尾数 $M = (1)_2$</p>
</li>
<li>
<p>连接 SEM：$(10111100110000000000000000000000)_2$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">1   01111001   10000000000000000000000
S       E                  M
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p><strong>Example 2</strong>：位模式 $(11001010000000000111000100001111)_2$ 以余127码格式存储于内存中. 求该数字十进制计数法的值.</p>
<ol>
<li>
<p>拆分：首位 S，接下来 8 位为 E，剩下的 23 位为 M</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">1   10010100   00000000111000100001111
S       E                  M
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>符号为负号</p>
</li>
<li>
<p>指数 = E - 127 = 148 - 127 = 21</p>
</li>
<li>
<p>将 $(1.00000000111000100001111)_2 \times 2^{21}$ 去规范化得到 $(1000000001110001000011.11)_2$</p>
</li>
<li>
<p>得到的二进制数化为十进制为 2104378.75</p>
</li>
<li>
<p>最终的数字为 -2104378.75</p>
</li>
</ol>
<p><strong>Example 3</strong>：实数 0.0 的存储，这是特例，规定这种情况符号、指数和尾数都为0</p>
<hr>
<p>后记：所找的的库实现 IEEE 754 标准时，输入输出都是二进制，因此，还需要自行实现两个算法从而实现和十进制实数的相互转换，算法就是上面两个例子的步骤。</p>]]></description></item><item><title>Mysql学习补充-临时表与派生表</title><link>https://shuzang.github.io/mysql-learning-supplement-temporary-table-and-derived-table/</link><pubDate>Tue, 13 Oct 2020 19:15:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/mysql-learning-supplement-temporary-table-and-derived-table/</guid><description><![CDATA[<p>区分 MySQL 中临时表与派生表的概念，明确它们的用途。</p>
<h2 id="1-临时表">1. 临时表</h2>
<p>本节参考 <a href="https://www.yiibai.com/mysql/temporary-table.html" target="_blank" rel="noopener noreffer">易百教程-MySQL临时表</a></p>
<h3 id="11-简介">1.1 简介</h3>
<p>就像它的名字，临时表是一个临时的结果集，一般在多表连接时使用，存储一个临时的结果以便另一个查询来处理。</p>
<p>临时表的一些注意如下</p>
<ul>
<li>在 <code>CREATE</code> 和 <code>TABLE</code> 中间添加 <code>TEMPORARY</code> 关键字来创建临时表，即 <code>CREATE TEMPOPARY TABLE</code>；</li>
<li>连接结束时，临时表会被自动删除，当然，也可以使用 DROP TABLE 显式删除。注意，这里的连接结束指的是数据库连接，当开发时使用连接池或者持久连接时，无法保证临时表在程序终止时自动删除，因为程序结束时连接不一定结束，而是会放到连接池；</li>
<li>临时表只能被创建它的客户端看到和访问，因此不同的客户端可以创建具有相同名称的临时表，不会导致冲突；</li>
<li>临时表可以与数据库中的普通表（永久表）具有相同的名称，但会屏蔽掉永久表，只有临时表被删除后永久表才能再次访问。但不建议这样做，因为如果服务器断线重连，将无法区分临时表和永久表，此时发起 DELETE TABLE 可能会删除掉永久表。</li>
</ul>
<h3 id="12-创建">1.2 创建</h3>
<p>如上所述，使用 <code>CREATE TEMPORARY TABLE</code> 创建临时表。下例中创建了一个临时表，按照收入存储前 10 名客户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="n">TEMPORARY</span> <span class="k">TABLE</span> <span class="n">top10customers</span>
<span class="k">SELECT</span> <span class="n">p</span><span class="p">.</span><span class="n">customerNumber</span><span class="p">,</span> 
       <span class="n">c</span><span class="p">.</span><span class="n">customerName</span><span class="p">,</span> 
       <span class="nf">FORMAT</span><span class="p">(</span><span class="nf">SUM</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">amount</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span> <span class="n">total</span>
<span class="k">FROM</span> <span class="n">payments</span> <span class="n">p</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customers</span> <span class="n">c</span> <span class="k">ON</span> <span class="n">c</span><span class="p">.</span><span class="n">customerNumber</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">customerNumber</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">p</span><span class="p">.</span><span class="n">customerNumber</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">total</span> <span class="k">DESC</span>
<span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>从创建的临时表中查询数据如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">top10customers</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="13-删除">1.3 删除</h3>
<p>使用 <code>DROP TEMPORARY TABLE</code> 删除临时表，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">DROP</span> <span class="n">TEMPORARY</span> <span class="k">TABLE</span> <span class="n">top10customers</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>关键词 <code>TEMPORARY</code> 可以省略，但为了避免删除永久表的错误，最好还是加上该关键词。</p>
<h2 id="2-派生表">2. 派生表</h2>
<p>本节参考 <a href="https://www.yiibai.com/mysql/derived-table.html" target="_blank" rel="noopener noreffer">易百教程-MySQL派生</a></p>
<p>当在 SELECT 语句的 FROM 子句中使用独立子查询时，将其称为派生表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="n">column_list</span>
<span class="k">FROM</span> <span class="p">(</span> <span class="c1"># 圆括号中的子查询结果即为派生表
</span><span class="c1"></span>	<span class="k">SELECT</span> <span class="n">column_list</span>
    <span class="k">FROM</span> <span class="n">table_1</span>
<span class="p">)</span> <span class="n">derived_table_name</span> <span class="c1"># 派生表必须具有别名
</span><span class="c1"></span><span class="k">WHERE</span> <span class="n">derived_table_name</span><span class="p">.</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>派生表必须具有别名，以便在稍后的查询中引用，否则，MySQL 将给出如下错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">Every</span> <span class="n">derived</span> <span class="k">table</span> <span class="n">must</span> <span class="n">have</span> <span class="n">its</span> <span class="n">own</span> <span class="n">alias</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><p>所以，我们可以看到，派生表不需要像临时表那样需要创建。</p>]]></description></item><item><title>win10效率优化7-终端和winget</title><link>https://shuzang.github.io/efficient-use-of-win10-7-windows-terminal-and-winget/</link><pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/efficient-use-of-win10-7-windows-terminal-and-winget/</guid><description><![CDATA[<p>Windows terminal 的安装配置和 winget 的基本使用，主要原因是 Powershell 不好看。</p>
<h2 id="1-windows-terminal">1. Windows terminal</h2>
<p>界面友好的终端应用，凡是命令行程序都可以用它启动，可以将 win10 下的 cmd、Powershell 和 git bash 都集中在一起，当然，最重要的是好看。</p>
<p>基本上有什么问题都可以从 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/" target="_blank" rel="noopener noreffer">官方教程</a> 里查到，这里只是介绍我的配置过程。</p>
<h3 id="11-安装">1.1 安装</h3>
<p>我选择从 <a href="https://aka.ms/terminal" target="_blank" rel="noopener noreffer">Microsoft Store</a> 安装 Windows terminal。初始界面如下</p>
<p></p>
<h3 id="12-快捷键启动">1.2 快捷键启动</h3>
<p>右键菜单已经有 git bash 了，不需要把它添加进去。</p>
<p>快捷键启动我没有采用网上流传的教程，而是把 Windows terminal 固定在了任务栏第一个，然后使用  <code>Win+1</code> 键打开。</p>
<h3 id="13-添加-git-bash">1.3 添加 git bash</h3>
<p>默认添加的应用包括 Powershell、cmd、Azure Cloud Shell 和我之前安装的 WSL（Ubuntu 20.04）。</p>
<p></p>
<p>这里将 git bash 添加进去，并设置为启动时默认使用的应用（之前启动 Windows termianl 默认打开 Powershell），并设置起始目录。最终效果如上图</p>
<ol>
<li>
<p>点击标题栏的下箭头，点击「设置」，可以在上图中看到；</p>
</li>
<li>
<p>在打开的配置文件中 <code>list</code> 部分添加如下内容。其中，<code>guid</code> 是唯一标识符，注意不要和已有的四个应用相同即可；<code>name</code> 是应用名；<code>commandline</code> 设置 git bash 路径，根据自己的安装位置设置；<code>icon</code> 设置上图中显示的缩略图，自己从 <a href="https://gitforwindows.org/img/gwindows_logo.png" target="_blank" rel="noopener noreffer">网上</a> 下载放到合适的位置并设置；<code>startingDirectory</code> 设置起始目录，我这里设置了我最常打开的目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;guid&#34;</span><span class="p">:</span> <span class="s2">&#34;{b453ae62-4e3d-5e58-b989-0a998ec441b9}&#34;</span><span class="p">,</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Git-bash&#34;</span><span class="p">,</span>
    <span class="nt">&#34;commandline&#34;</span><span class="p">:</span> <span class="s2">&#34;C:\\Program Files\\Git\\bin\\bash.exe&#34;</span><span class="p">,</span>
    <span class="nt">&#34;icon&#34;</span><span class="p">:</span> <span class="s2">&#34;C:\\Program Files\\Git\\gwindows_logo.png&#34;</span><span class="p">,</span>
    <span class="nt">&#34;startingDirectory&#34;</span><span class="p">:</span> <span class="s2">&#34;F:\\OneDrive\\博客&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>修改全局字段（在配置文件的最前面几行中找）中的 <code>defaultProfile</code> 为 <code>Git-bash</code>，这里可以使用上面的 <code>name</code> 或 <code>guid</code> 字段</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;defaultProfile&#34;</span><span class="err">:</span> <span class="s2">&#34;Git-bash&#34;</span><span class="err">,</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h3 id="14-配色及背景图">1.4 配色及背景图</h3>
<p>大部分人用 Windows terminal 就是因为它可定制，所以出现了各种各样好看的配色和主题。</p>
<p></p>
<p>我从 <a href="https://windowsterminalthemes.dev/" target="_blank" rel="noopener noreffer">主题网站</a> 选择了 Builtin Tango Light 主题，配置代码如下，需要将这段代码复制到配置文件的 <code>schemes</code> 字段中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Builtin Tango Light&#34;</span><span class="p">,</span>
    <span class="nt">&#34;black&#34;</span><span class="p">:</span> <span class="s2">&#34;#000000&#34;</span><span class="p">,</span>
    <span class="nt">&#34;red&#34;</span><span class="p">:</span> <span class="s2">&#34;#cc0000&#34;</span><span class="p">,</span>
    <span class="nt">&#34;green&#34;</span><span class="p">:</span> <span class="s2">&#34;#4e9a06&#34;</span><span class="p">,</span>
    <span class="nt">&#34;yellow&#34;</span><span class="p">:</span> <span class="s2">&#34;#c4a000&#34;</span><span class="p">,</span>
    <span class="nt">&#34;blue&#34;</span><span class="p">:</span> <span class="s2">&#34;#3465a4&#34;</span><span class="p">,</span>
    <span class="nt">&#34;purple&#34;</span><span class="p">:</span> <span class="s2">&#34;#75507b&#34;</span><span class="p">,</span>
    <span class="nt">&#34;cyan&#34;</span><span class="p">:</span> <span class="s2">&#34;#06989a&#34;</span><span class="p">,</span>
    <span class="nt">&#34;white&#34;</span><span class="p">:</span> <span class="s2">&#34;#d3d7cf&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightBlack&#34;</span><span class="p">:</span> <span class="s2">&#34;#555753&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightRed&#34;</span><span class="p">:</span> <span class="s2">&#34;#ef2929&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightGreen&#34;</span><span class="p">:</span> <span class="s2">&#34;#8ae234&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightYellow&#34;</span><span class="p">:</span> <span class="s2">&#34;#fce94f&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightBlue&#34;</span><span class="p">:</span> <span class="s2">&#34;#729fcf&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightPurple&#34;</span><span class="p">:</span> <span class="s2">&#34;#ad7fa8&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightCyan&#34;</span><span class="p">:</span> <span class="s2">&#34;#34e2e2&#34;</span><span class="p">,</span>
    <span class="nt">&#34;brightWhite&#34;</span><span class="p">:</span> <span class="s2">&#34;#eeeeec&#34;</span><span class="p">,</span>
    <span class="nt">&#34;background&#34;</span><span class="p">:</span> <span class="s2">&#34;#ffffff&#34;</span><span class="p">,</span>
    <span class="nt">&#34;foreground&#34;</span><span class="p">:</span> <span class="s2">&#34;#000000&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在 <code>defaults</code> 字段中添加</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;colorScheme&#34;</span><span class="err">:</span> <span class="s2">&#34;Builtin Tango Light&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>为了不打扰正式内容的显示，我决定将背景图放在右下角，同时，由于终端主体颜色是白色，背景图除了主体的人或物，其它颜色也应该是白色，正好我有一张谏山黄泉的图是这样的。</p>
<p>由于要放在右下角，还要在图片左边和上边扩展大量的白色区域。我选择的方法是打开 Microsoft Whiteboard 应用，将背景颜色设置为白色，然后将图片放在右下角，导出此时的白板。</p>
<p>将导出的图片放在合适的位置，在配置文件的 <code>defaults</code> 字段中添加如下内容（和主体设置在一起），第一行设置背景图路径，第二行设置不透明度。此时打开终端发现图片显示可能有问题，无法正好在右下角显示整个人物，这时候通过裁剪背景图上方和左边的空白，不断调整和预览，可以获得想要的效果，最终效果就是本小节开头的图片。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;backgroundImage&#34;</span><span class="err">:</span> <span class="s2">&#34;F:\\OneDrive\\图片\\收藏\\谏山黄泉-背景图.png&#34;</span><span class="err">,</span>
<span class="s2">&#34;backgroundImageOpacity&#34;</span><span class="err">:</span> <span class="mf">0.8</span>
</code></pre></td></tr></table>
</div>
</div><p>注1：不少人喜欢下面这种标签式的效果，叫做 Powerline，但我没感觉，所以没添加，想使用可以参考 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/custom-terminal-gallery/powerline-in-powershell" target="_blank" rel="noopener noreffer">Windows 终端的 PowerShell 主题中的 Powerline</a></p>
<p></p>
<p>注2：官方提供了几种不错的主题，包括 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/custom-terminal-gallery/frosted-glass-theme" target="_blank" rel="noopener noreffer">毛玻璃效果</a> 和 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/custom-terminal-gallery/raspberry-ubuntu" target="_blank" rel="noopener noreffer">Raspberry Ubuntu</a> 我都很喜欢，效果如下</p>
<p></p>
<p></p>
<h2 id="2-winget">2. winget</h2>
<p>win10 预览版用户直接就可以使用，是系统自带的，非预览版用户从 <a href="https://github.com/microsoft/winget-cli" target="_blank" rel="noopener noreffer">github仓库</a> 自行下载安装。使用说明可以参考 <a href="https://docs.microsoft.com/zh-cn/windows/package-manager/winget/" target="_blank" rel="noopener noreffer">官方文档</a>，安装后可以直接在终端使用</p>
<p></p>
]]></description></item><item><title>算法-时间复杂度和空间复杂度</title><link>https://shuzang.github.io/algorithm-time-and-space-complexity/</link><pubDate>Fri, 18 Sep 2020 20:37:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-time-and-space-complexity/</guid><description><![CDATA[<p>时间和空间复杂度的分析是编制程序的一个基本能力，不过平时基本都是脑子里简单的估计，本篇文章打算回忆一下大 O 表示法和具体的时间复杂度的推导过程。</p>
<h2 id="1-时间复杂度">1. 时间复杂度</h2>
<p>算法的时间复杂度指的是算法运行所需要的时间的量，这个时间量不应该依赖外部因素，而应当只和问题规模 N、输入 I 以及算法 A 本身相关。如果用 T 表示时间复杂度，那么表达式为</p>
<p>$$
T = T(N,I,A)
$$
由于算法是通过一个或几个函数实现的，算法 A 本身通常就会隐含在函数名中，这样表达式可以简化为
$$
T = T(N,I)
$$
如果算法连输入都不依赖，那么表达式就可以进一步简化为 $T(N)$，但我们通常用 N 的小写形式，写作 $T(n)$</p>
<p>那么我们如何来计算这个时间的量呢，通常，我们假设算法中每条语句的执行时间均为单位时间，这样，算法运行的总时间就是所有语句执行时间之和。以顺序查找为例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 返回第一个与 k 相同的元素的下标，否则返回-1
</span><span class="c1"></span><span class="n">Search</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mf">0.</span><span class="p">..</span><span class="n">n</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>                         <span class="c1">// c1=1
</span><span class="c1"></span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span> <span class="k">do</span>  <span class="c1">// c2
</span><span class="c1"></span>        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>                 <span class="c1">// c3
</span><span class="c1"></span>    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> 
        <span class="k">return</span> <span class="n">i</span>             	  <span class="c1">// c4=1
</span><span class="c1"></span>    <span class="k">else</span> 
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>                 <span class="c1">// 或c5=1
</span></code></pre></td></tr></table>
</div>
</div><p>注释中列出了每条语句的执行时间 $c_i$，那么 $\sum_{i=1}^{n}c_i$ 就是算法运行的总时间。</p>
<p>但是，算法运行的总时间并不是算法的时间复杂度，我们通常说的时间复杂度完整的叫法应该是算法的渐进时间复杂度，是考虑当问题规模充分大时，算法运行时间的表达式在渐进意义下的阶。定义如下</p>
<blockquote>
<p>设 $T(n)$ 是关于算法 A 的复杂性函数，如果存在 t(n)，使得 $\lim\limits_{N\to\infty} \frac{T(n)-t(n)}{T(n)} = 0 $，则 t(n) 是 T(n) 是当 $n\to\infty$ 时的渐进表达式，也可以直接称作其渐进时间复杂度</p>
</blockquote>
<p>具体而言，对于给定的 $T(n)$ 的表达式，算法的渐进时间复杂度是略去低阶项和常数因子留下的主项。例如，给定 $T(n) = 3n^3 + 90n^2 - 5n + 6040$，略去低阶项和常数因子，得到渐进时间复杂度 $t(n) = n^3$</p>
<h3 id="11-大o表示法">1.1 大O表示法</h3>
<p>通常用渐进上界 O 来表示渐进时间复杂度，也就是我们常说的大 O 表示法，其定义是
$$
O(g(n)) = {f(n) | 存在正常数 c 和 n_0使得对所有 n \ge n_0 有：0 \le f(n) \le cg(n)}
$$
</p>
<p>举个例子，$f(n) = 2n+3 = O(n)$，因为当 $n\ge 3$ 时，$2n+3 \le 3n$，这里的含义就是，当 $n \ge 3$ 时，算法步骤不会超过 $3n$</p>
<p>第二个例子，$f(n) = 10n^2 + 4n + 2 = O(n^2)$，因为当 $n \ge 5$ 时，$10n^2 + 4n + 2 \le 11n^2$</p>
<p>最后给一个矩阵乘法的实例，总时间 $T(n) = 2n^3 + n^2 + 2n$，这样渐进时间复杂度就是 $O(n^3)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>                <span class="c1">// n
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>            <span class="c1">// n
</span><span class="c1"></span>        <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>                     <span class="c1">// n^2
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>        <span class="c1">// n^3
</span><span class="c1"></span>            <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">k</span><span class="p">]</span><span class="o">*</span><span class="nx">b</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>  <span class="c1">// n^3
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后声明两个大 O 的运算规则</p>
<ol>
<li>$O(f) + O(g) = O(max(f,g))$</li>
<li>$O(f)O(g) = O(fg)$</li>
</ol>
<p>此外，有时候也会见到渐进下界 $\Omega$ 和 渐进准确界 $\Theta$，但很少或几乎用不到</p>
<h3 id="12-对输入实例的依赖">1.2 对输入实例的依赖</h3>
<p>有些时候需要考虑某类有代表性的输入实例，比如最坏情况、最好情况、平均情况，这几种情况的复杂度是不一样的，通常用如下符号表示</p>
<ul>
<li>最好情况 $T_{min}(n)$</li>
<li>最坏情况 $T_{max}(n)$</li>
<li>平均情况 $T_{avg}(n)$</li>
</ul>
<p>对于前面提到的查找算法，第一个与 k 相同的元素可能是最后一个元素，这时循环执行 n 次，是最坏情况；也可能是第一个元素，这时循环只执行 1 次，是最好情况。</p>
<p>理解这三种情况下的算法性能都很重要，但应注意：</p>
<ol>
<li>很多算法最好情况下的性能都差不多，O(1) 或者 O(n)，没有太大的影响，不能说明哪种算法更好；</li>
<li>算法的平均情况往往不是那么容易分析；</li>
<li>最坏情况可以告诉我们算法性能的上限，从而保证任何情况都不会比它差。</li>
</ol>
<h3 id="13-复杂度分析的步骤">1.3 复杂度分析的步骤</h3>
<p>复杂度分析的步骤如下</p>
<ol>
<li>确定表示问题规模的变量；</li>
<li>确定占运行时间最大比例的语句；</li>
<li>确定算法是否依赖输入实例（决定了是否分最坏、最好、平均三种情况考虑）；</li>
<li>计算语句执行总次数；</li>
<li>确定时间复杂度；</li>
</ol>
<p>以选择排序为例，用伪代码描述如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">SelectionSort</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mf">0.</span><span class="p">..</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span> <span class="k">do</span> 
	    <span class="n">min</span> <span class="o">=</span> <span class="n">i</span>
	    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="k">do</span> 
	        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="p">{</span>
		        <span class="n">min</span> <span class="o">=</span> <span class="n">j</span>	
    <span class="n">swap</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>问题规模为数组长度 n</li>
<li>占运行时间最大比例的语句是 $min = j$</li>
<li>算法只依赖问题规模，不依赖输入实例</li>
<li>语句执行总次数 $T(n) = \sum_{i=1}^{n}i = \frac{n(n-1)}{2}$</li>
<li>时间复杂度为 $O(n^2)$</li>
</ol>
<p>一个依赖输入实例的例子是插入排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">InsertSort</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mf">0.</span><span class="p">..</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span><span class="o">--</span>
    <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>问题规模为数组长度 n</li>
<li>占运行时间最大比例的语句是 $A[j] &gt; a$</li>
<li>算法依赖输入实例</li>
<li>语句执行总次数：
<ul>
<li>最坏情况：$T(n) = \frac{n(n-1)}{2}$</li>
<li>最好情况：$T(n) = n-1$</li>
</ul>
</li>
<li>时间复杂度
<ul>
<li>最坏情况：$T(n)=O(n^2)$</li>
<li>最好情况：$T(n) = O(n)$</li>
</ul>
</li>
</ol>
<h3 id="14-常见时间复杂度">1.4 常见时间复杂度</h3>
<p>常见时间复杂度总结如下表</p>
<table>
<thead>
<tr>
<th>复杂度</th>
<th>出现情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>几乎不存在</td>
</tr>
<tr>
<td>logn</td>
<td>不能考虑全部输入</td>
</tr>
<tr>
<td>n</td>
<td>遍历、扫描全部输入</td>
</tr>
<tr>
<td>nlogn</td>
<td>许多分治算法</td>
</tr>
<tr>
<td>$n^2$</td>
<td>两层循环</td>
</tr>
<tr>
<td>$n^3$</td>
<td>三层循环</td>
</tr>
<tr>
<td>$2^n$</td>
<td>一个集合的所有子集</td>
</tr>
<tr>
<td>$n!$</td>
<td>一个集合中的元素的所有排列</td>
</tr>
</tbody>
</table>
<p>我们可以按这些时间复杂度把算法分为两类</p>
<ul>
<li>多项式时间算法
<ul>
<li>用多项式对运行时间限界的算法</li>
<li>$O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3)$</li>
</ul>
</li>
<li>指数时间算法
<ul>
<li>用指数函数对运行时间限界的算法</li>
<li>$O(2^n) &lt; O(n!) &lt; O(n^n)$</li>
</ul>
</li>
</ul>
<p>对指数时间的算法应尽可能优化。</p>
<h2 id="2-空间复杂度">2. 空间复杂度</h2>
<p>空间复杂度是对算法所消耗的额外存储单元进行计数，这里注意是<strong>额外</strong>的存储单元，不包括</p>
<ol>
<li>为容纳输入数据而分配的存储空间，比如输入数组 A[0&hellip;n] 占用的空间</li>
<li>实现该算法的程序代码和常数占用的空间</li>
</ol>
<p>额外的意思是算法所需要的工作空间，比如交换两个变量值时分配了一个临时变量，这个变量占用的空间就属于空间复杂度分析的范围，再比如实现栈时为栈申请的空间也属于空间复杂度的分析范围，最后，递归函数使用的内部栈也属于空间复杂度的分析范围。</p>
<p>在很多问题中，时间和空间是一个对立面。为算法分配更多的空间，可以使算法运行的更快，反之，当空间是一个重要因素时，需要用算法的运行时间去换取空间。一个运行时间短、所需存储空间小、其它性能也好的算法是很难做到的。因此我们要根据具体情况进行算法设计。</p>
<ul>
<li>对于使用次数较少的程序，力求算法简单易懂；</li>
<li>对于反复多次使用的程序，尽可能选用快速的算法；</li>
<li>若待解决的问题数据量极大，机器的存储空间较小，则相应算法主要考虑如何节省空间。</li>
</ul>]]></description></item><item><title>Mysql学习补充-语句执行顺序</title><link>https://shuzang.github.io/mysql-learning-supplement-statement-execution-order/</link><pubDate>Sun, 13 Sep 2020 16:08:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/mysql-learning-supplement-statement-execution-order/</guid><description><![CDATA[<p>这篇文章用来仔细思考 MySQL 查询语句的执行顺序。</p>
<p>手写 MySQL  语句的顺序通常如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">&lt;</span><span class="n">select_list</span><span class="o">&gt;</span>
<span class="k">from</span> <span class="o">&lt;</span><span class="n">table_name</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">join_type</span><span class="o">&gt;</span> <span class="k">join</span> <span class="o">&lt;</span><span class="n">join_table</span><span class="o">&gt;</span> <span class="k">on</span> <span class="o">&lt;</span><span class="n">join_condition</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="o">&lt;</span><span class="n">where_condition</span><span class="o">&gt;</span>
<span class="k">group</span> <span class="k">by</span> <span class="o">&lt;</span><span class="n">group_by_list</span><span class="o">&gt;</span>
<span class="k">having</span> <span class="o">&lt;</span><span class="n">having_condition</span><span class="o">&gt;</span>
<span class="k">order</span> <span class="k">by</span> <span class="o">&lt;</span><span class="n">order_by_condition</span><span class="o">&gt;</span>
<span class="k">limit</span> <span class="o">&lt;</span><span class="n">limt_number</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>MySQL 语句的执行顺序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">from</span> <span class="o">&lt;</span><span class="k">left</span> <span class="k">table</span><span class="o">&gt;</span>
<span class="k">on</span> <span class="o">&lt;</span><span class="n">on_condition</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">join_type</span><span class="o">&gt;</span> <span class="k">join</span> <span class="o">&lt;</span><span class="n">join_table</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="o">&lt;</span><span class="n">where_condition</span><span class="o">&gt;</span>
<span class="k">group</span> <span class="k">by</span> <span class="o">&lt;</span><span class="n">group_by_list</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nf">sum</span><span class="p">()</span><span class="nf">avg</span><span class="p">()</span><span class="err">等聚合函数</span><span class="o">&gt;</span>
<span class="k">having</span> <span class="o">&lt;</span><span class="n">having_condition</span><span class="o">&gt;</span>
<span class="k">select</span> <span class="o">&lt;</span><span class="n">select_list</span><span class="o">&gt;</span>
<span class="k">distinct</span>
<span class="k">order</span> <span class="k">by</span> <span class="o">&lt;</span><span class="n">order_by_condition</span><span class="o">&gt;</span>
<span class="k">limit</span> <span class="o">&lt;</span><span class="n">limit_number</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>下面做一下解释</p>
<p><strong>第一步</strong>：如果有连接运算，加载 from 子句指定的表中的前两个计算笛卡尔积，生成虚拟表 vt1；</p>
<p><strong>第二步</strong>：对虚拟表 vt1 执行 on 表达式，筛选符合条件的元组，生成虚拟表 vt2，如果是外连接，基表中的数据会全部保留；</p>
<p><strong>第三步</strong>：如果 from 子句中的表数量大于 2，则重复前两部，直至所有的表都连接完成，得到虚拟表 vt3；</p>
<p><strong>第四步</strong>：执行 where 表达式，筛选符合条件的数据生成 vt4；</p>
<p><strong>第五步</strong>：执行 group by 子句。group by 子句执行过后，会对子句组合成唯一值并且对每个唯一值只包含一行，生成 vt5,。一旦执行group by，后面的所有步骤只能得到 vt5 中的列（group by的子句包含的列）和聚合函数。</p>
<p><strong>第六步</strong>：执行聚合函数，生成 vt6；</p>
<p><strong>第七步</strong>：执行 having 表达式，筛选 vt6 中的数据，生成vt7。having是唯一一个在分组后的条件筛选;</p>
<p><strong>第八步</strong>：执行 select 语句，从 vt7 中筛选列，生成 vt8；</p>
<p><strong>第九步</strong>：执行 distinct，对 vt8 去重，生成 vt9。如果执行过 group by 就没必要再去执行 distinct，因为分组后，每组只会有一条数据，并且每条数据都不相同。</p>
<p><strong>第十步</strong>：对 vt9 进行排序，此处返回的不是一个虚拟表，而是一个游标，记录了数据的排序顺序，此处可以使用别名；</p>
<p><strong>第十一步</strong>：执行 limit 语句，将结果返回给客户端。</p>
<hr>
<p><strong>参考</strong></p>
<p>[1] 樱桃mayue，51CTO博客，<a href="https://blog.51cto.com/13593129/2357192?source=dra" target="_blank" rel="noopener noreffer">MySql学习笔记（二）：SQL执行顺序</a>，2019.03.02</p>]]></description></item><item><title>Mysql学习补充-关系数据理论</title><link>https://shuzang.github.io/mysql-learning-supplement-relational-data-theory/</link><pubDate>Fri, 11 Sep 2020 19:30:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/mysql-learning-supplement-relational-data-theory/</guid><description><![CDATA[<p>MySQL 作为关系数据库，关系数据理论是基础，本文进行补充学习，主要包括关系模型、关系代数和范式的相关知识。</p>
<h2 id="1-关系模型">1. 关系模型</h2>
<h3 id="11-简介">1.1 简介</h3>
<p>模型就是描述数据的概念的集合。</p>
<p>数据库的本质作用是存储抽象自现实世界的数据，这一过程可以分为两个阶段</p>
<ol>
<li>对现实世界进行抽象，强调语义的表达，这一阶段称为<strong>概念模型</strong>，一般使用线条、图形、文字等来进行描述，是用户和数据库设计人员的沟通语言，比如 E-R 图。</li>
<li>用计算机可理解的方式进行二次抽象，强调数据描述的确定性，这一阶段称作<strong>数据模型</strong>，包括遵循的数据结构、对数据的各种操作和数据的约束条件三部分。</li>
</ol>
<p>关系模型正是当前广泛使用的一种数据模型，使用关系模型的数据库称为关系型数据库，MySQL 正是广为使用的一种关系型数据库。</p>
<h3 id="12-基本概念">1.2 基本概念</h3>
<p><strong>域</strong>：域是一组具有相同类型值的集合，比如 MAN = {王兵，李平} 就是一个域，WOMAN = {丁梅，吴芳} 也是一个域。</p>
<p><strong>笛卡尔积</strong>：给定一组域 $D_1,D_2,&hellip;,D_n$，它们的笛卡尔积就定义为
$$
D_1 \times D_2 \times &hellip; D_n={(d_1,d_2,&hellip;,d_n)|d_i \in D_i,i=1,2,&hellip;,n}
$$
以上面的 MAN 和 WOMEN 域为例，$MAN \times WOMEN = {(王兵,丁梅),(王兵,吴芳),(李平,丁梅),(李平,吴芳)}$，一个笛卡尔积可以表示为一个二维表，如下</p>
<table>
<thead>
<tr>
<th>MAN</th>
<th>WOMAN</th>
</tr>
</thead>
<tbody>
<tr>
<td>王兵</td>
<td>丁梅</td>
</tr>
<tr>
<td>王兵</td>
<td>吴芳</td>
</tr>
<tr>
<td>李平</td>
<td>丁梅</td>
</tr>
<tr>
<td>李平</td>
<td>吴芳</td>
</tr>
</tbody>
</table>
<p><strong>元组</strong>：笛卡尔积中的每个元素叫做一个元组，也就是二维表中的一行。</p>
<p><strong>关系</strong>：$D_1 \times D_2 \times &hellip; D_n$ 的子集叫做在域 $D_1,D_2,&hellip;,D_n$ 上的一个关系，可以表示为 $R(D_1,D_2,&hellip;,D_n)$，n 叫做关系的目/度。关系是关系模型最核心的概念，一个关系数据库就是一组关系的集合，而一个关系就是一张二维表（笛卡尔积所代表的二维表的一个子集），比如，我们假设王兵的妻子是丁梅，李平的妻子是吴芳，则取笛卡尔积的一个子集就可以构造出一个关系 FAMILY</p>
<table>
<thead>
<tr>
<th>husband</th>
<th>wife</th>
</tr>
</thead>
<tbody>
<tr>
<td>王兵</td>
<td>丁梅</td>
</tr>
<tr>
<td>李平</td>
<td>吴芳</td>
</tr>
</tbody>
</table>
<p>关系具有一些规定（性质）</p>
<ol>
<li>关系中不能存在完全相同的两个元组</li>
<li>关系中元组行的序不重要</li>
<li>关系中列的序不重要</li>
</ol>
<p><strong>属性</strong>：关系的每一列都有一个自己的名字，称为属性。这一，上面的关系就可以表示为 $FAMILY = {husband,wife}$</p>
<p><strong>候选码</strong>：能够唯一标识一个元组的最小属性组叫做候选码，在上面的例子中，需要丈夫和妻子两个人的名字才能区分每一对夫妻，因此其候选码为 (husband,wife)，但在其它例子比如学生名单中，学生学号可以唯一标识学生，因此学号可以单独作为候选码。</p>
<p><strong>主属性</strong>：候选码中的属性叫做主属性。</p>
<p><strong>非码属性</strong>：不包含在任何候选码中的属性叫做非码属性。</p>
<p><strong>关系模式</strong>：对关系进一步抽象，表示所有关系的一个通用方法就是关系模式，表达为 $R(U,D,dom,F)$，其中 R 为关系名，U 是组成该关系的属性名集合，D 是属性组 U 中属性来自的域，dom 是属性到域的映射集合，F 为属性间数据的依赖关系集合。通常我们会简写为 $R(U)$，所以才有了上面的 $FAMILY = {husband,wife}$ 这种表示。</p>
<h2 id="2-关系代数">2. 关系代数</h2>
<p>一个数据模型，不仅包含表达数据的数据结构，还包含可对数据进行的操作。关系模型中，每个关系看作一个集合，对关系的操作可以就归纳为对集合的操作，这就是本节要介绍的关系代数。</p>
<p>关系代数的运算分为：传统的集合运算和专门的关系运算。</p>
<h3 id="21-集合运算">2.1 集合运算</h3>
<p>就是指求<strong>交集</strong>、<strong>并集</strong>和<strong>差集</strong>，要求运算的两个关系具有相同的目，且相应的属性取自同一个域。</p>
<p>还有一个特别的集合运算叫做<strong>广义笛卡尔积</strong>。假设两个关系 R 和 S 分别为 n 和 m 目，则其广义笛卡尔积是一个 n + m 列的元组的集合。若 R 有 k1 个元组，S 有 k2 个元组，则广义笛卡尔积有 $k1 × k2$ 个元组，记作 $R \times S$。通常我们在描述时一般直接称为笛卡尔积运算。</p>
<p>假设 R 关系如下</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
</tbody>
</table>
<p>S 关系如下</p>
<table>
<thead>
<tr>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>d1</td>
<td>e1</td>
</tr>
<tr>
<td>d2</td>
<td>e2</td>
</tr>
<tr>
<td>d3</td>
<td>e3</td>
</tr>
</tbody>
</table>
<p>则 $R \times S$ 如下</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>d1</td>
<td>e1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>d2</td>
<td>e2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>d3</td>
<td>e3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>d1</td>
<td>e1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>d2</td>
<td>e2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>d3</td>
<td>e3</td>
</tr>
</tbody>
</table>
<h3 id="22-关系运算">2.2 关系运算</h3>
<p><strong>选择</strong>：选择运算是在关系 R 中选择满足给定条件的元组，记作 $\sigma_F(R) = {t \in R \and F(t) = true}$，其中 $\sigma$ 为选择运算符，$F$ 为选择条件</p>
<p>选择运算 $\sigma_{A=&lsquo;a1&rsquo;}(R)$ 的结果为</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
</tbody>
</table>
<p><strong>投影</strong>：投影运算是在关系 R 中选出若干属性列组成新的关系，记作 $\pi_A(R) = {t[A]|t \in R}$，其中 $\pi$ 为投影运算符，$A$ 为选择的属性列名。需要注意的是，投影运算可能缩减元组个数，因为要去重。</p>
<p>投影运算 $\pi_{A,B}(R)$ 的结果为</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
</tr>
</tbody>
</table>
<p><strong>连接</strong>：连接运算是从两个关系的笛卡尔积中选取属性间满足一定条件的元组，称为θ连接，记作 $R \bowtie S$，$\bowtie$ 下面应该有个θ连接的表达式，比如 $A = B$，当θ为等号时称作<strong>等值连接</strong>。</p>
<p>连接运算可以理解为笛卡尔积和选择两个运算的结合，下面是一个等值连接的例子</p>
<p></p>
<p>当等值连接中等于号的两端是相同的属性组时，称为自然连接，上图同时也是一个<strong>自然连接</strong>，可以直接表示为 $R \bowtie S$</p>
<p><strong>左连接</strong>：左连接的意思是左表的记录会全部显示出来，而右表只会显示符合搜索条件的记录，右表记录不足的填充 NULL。</p>
<p><strong>右连接</strong>：与左连接相反，右表的记录全部显示出来，左表只会显示符合搜索条件的记录，左表记录不足的填充 NULL。</p>
<p>象集：给定一个关系 R(X,Y)，X和Y为属性组，当 t[X]=x时，x在R中的象集为：$Y_x={t[Y]|t \in R, t[X]=x}$</p>
<p>除：给定关系 R(X,Y) 和 S(Y,X)，其中 X,Y,Z 为属性组。R中的Y和S中的Y可以有不同的名字，但必须取自同一个域，R与S除得到一个新关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X分量值x的象集$Y_x$包含S在Y上投影的集合，记作：$R \div S = {t_r[X]|t_r \in R \land \pi_y(S) \subseteq Y_x }$</p>
<p></p>
<h2 id="3-约束">3. 约束</h2>
<p>数据的约束条件是一组完整性规则的集合，这些规则用来限定数据模型中的数据，使其符合某种特征，比如对学生年龄的限定，奖金必须低于基本工资等。</p>
<p>关系模型的完整性约束主要包括</p>
<ol>
<li>实体完整性：主码中的属性不可取空值</li>
<li>参照完整性：关系中的某个属性列与另一个关系的主码对应</li>
<li>用户自定义完整性：类似于学生年龄取值这种符合现实特征的</li>
</ol>]]></description></item><item><title>Windows、Linux、Unix和 macOS</title><link>https://shuzang.github.io/windows-linux-unix-and-macos/</link><pubDate>Wed, 02 Sep 2020 21:15:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/windows-linux-unix-and-macos/</guid><description><![CDATA[<p>目前主流的操作系统就是 Windows、Linux 和 macOS，有时候我们也常听到 Unix。今天查一下资料看一看它们的区别。</p>
<p>详细的历史演进可以阅读脚本之家的 <a href="https://www.jb51.net/os/other/159236.html" target="_blank" rel="noopener noreffer">操作系统Unix、Windows、Mac OS、Linux的故事</a> 这篇文章。</p>
<p>基本的关系可以看下图</p>
<p></p>
<p>Unix 可以算作操作系统的鼻祖，macOS 是 FreeBSD 的衍生，Linux 是 AT&amp;T System V 的衍生，Windows 和 Unix 没有什么关系，是另外一个派系，只是借鉴了一些特性。</p>
<p>类 Unix 系统是指继承 UNIX 的设计风格演变出来的系统，都相当程度地继承了原始 UNIX 的特性，并且都在一定程度上遵守POSIX规范，但是它们却并不含有UNIX的源代码，因为 UNIX 的源代码为 SCO公司所有，属于商业软件。</p>
<p>由于 UNIX 标准认定价格昂贵，目前只有苹果的 MacOS 获得了认定，可以称作 Unix 系统，Linux 只能称作类 Unix 操作系统。</p>]]></description></item><item><title>正则表达式与通配符</title><link>https://shuzang.github.io/regular-expression-basic-syntax/</link><pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/regular-expression-basic-syntax/</guid><description><![CDATA[<p>正则表达式在字符串处理时使用的非常普遍，这次来学习正则的相关知识，分别结束通配符、正则及它们的区别。</p>
<h2 id="1-通配符">1. 通配符</h2>
<p>首先明确场景，通配符和正则表达式都是做匹配的，匹配常见的场景有</p>
<ol>
<li>Office 系列，尤其是 Word 中的查找和替换；</li>
<li>常用的文本编辑器中的查找和替换，比如 Win10 下的记事本、VSCode、Typora 等</li>
<li>Win10 或 Linux 命令行输入各种命令时使用</li>
<li>编程时进行字符串匹配使用</li>
</ol>
<p><strong>Office 系列</strong>的查找和替换默认都是正则表达式，但可以在选项中勾选使用通配符，而且 Office 系列的通配符很简单，只有三种：问号（？）、星号（*）、波形符（~）。</p>
<ul>
<li>使用问号（？）查找任何单个字符，例如 s?t 找到 &ldquo;sat&rdquo; 和 &ldquo;set&rdquo;。</li>
<li>使用星号（*）查找任意数量的字符，例如 s*d 可以找到 &ldquo;sad&rdquo;。</li>
<li>使用波形符（~），后跟？、* 或 ~ 查找问号、星号或其他波形符，其实就是用来转义。</li>
</ul>
<p><strong>常见的文本编辑器</strong>在尝试后发现基本都只能使用全字匹配，VSCode 可以勾选使用正则表达式。</p>
<p><strong>命令输入</strong>是典型的通配符使用场景，比较出名的是 Linux 下的 glob，用来匹配文件路径名。glob 的语法也很简单</p>
<ul>
<li>？ 匹配任意单个字符</li>
<li>* 匹配任意字符串，包括空串</li>
<li>[&hellip;] 匹配方括号中任意一个字符，比如[abc]匹配字符a, b, c中任意一个，方括号中不可为空。同时，可以使用 - 放在方括号中表示范围，使用! 放在方括号中表示非</li>
</ul>
<p>基本上 glob 通配符可以算作正则的简化。</p>
<h2 id="2-正则表达式">2. 正则表达式</h2>
<p>正则的目的是字符串模式匹配，实现查找与替换，正则的基本原理是有限状态自动机。</p>
<p>一个正则表达式的基本组成元素包括字符和元字符</p>
<ul>
<li>字符就是普通的计算机字符，比如字母、数字等</li>
<li>元字符是某类有特定含义的字符，比如 ^ 和 *  等</li>
</ul>
<h3 id="21-字符">2.1 字符</h3>
<p>单个的字符比如字母、数字等，是它们原本的含义。</p>
<p>一些功能字符无法直接表示，比如换行、回车等，需要在普通字符前面加上转义元字符 <code>\</code> 来表示，比如</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>字符描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>[\b]</td>
<td>回退符，之所以使用[]符号是避免和\b重复</td>
</tr>
</tbody>
</table>
<p>还有一部分是正则表达式特殊的规定，在普通字符前面使用转移字符表达特定含义，如下表</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\w</td>
<td>任意一个字母或数字或下划线</td>
</tr>
<tr>
<td>\W</td>
<td>任意一个字母或数字或下划线以外的字符</td>
</tr>
<tr>
<td>\s</td>
<td>空白字符，比如空格、tab、换行、换页</td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符，0~9</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符</td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界</td>
</tr>
</tbody>
</table>
<p>这里解释一下单词边界的含义，一般情况，单词指的是字母、数字、下划线构成的字符串，边界指的是一个具体的位置，而不是一个字符，比如对于字符串 <code>example:a+b=3</code>，用 | 表示位置，如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">|e|x|a|m|p|l|e|:|a|+|b|=|3|
</code></pre></td></tr></table>
</div>
</div><p>单词边界指的就是下面几个位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">|example|:|a|+|b|=|3|
</code></pre></td></tr></table>
</div>
</div><p>非单词边界就更好理解了，不是单词边界的就是非单词边界</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">e|x|a|m|p|l|e:a+b=3
</code></pre></td></tr></table>
</div>
</div><h3 id="22-元字符">2.2 元字符</h3>
<p>元字符是具有特定语义的字符，比如上面的转义字符 <code>\</code> 就是一个元字符，用于改变普通字符的含义。正则表达式中定义的常用元字符包括</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除了换行符外的任意一个字符</td>
</tr>
<tr>
<td>？</td>
<td>匹配同一个字符出现 0 次或 1 次</td>
</tr>
<tr>
<td>+</td>
<td>匹配同一个字符出现 1 次或多次</td>
</tr>
<tr>
<td>*</td>
<td>匹配同一个字符出现 0 次或 1 次或多次</td>
</tr>
</tbody>
</table>
<h4 id="量词">量词</h4>
<p><code>?</code>, <code>+</code>, <code>*</code>三个元字符我们通常称作量词，因为它们的作用是表示某个字符出现了多少次，除此之外，还可以声明更具体的出现次数</p>
<ul>
<li>{n} 表示字符出现 n 次，比如a{2}，匹配aa</li>
<li>{m,n} 表示字符出现最少 m 次，最多 n 次，比如a{1,3}，可以匹配aaa、aa、a</li>
<li>{m,} 表示字符出现 m-∞次，优先匹配∞次，比如a{1,}，可以匹配 aaaa&hellip;</li>
</ul>
<p>注意正则默认是贪婪的，凡是表示范围的量词，都优先匹配上限而不是下限。比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">a{1, 3} // 匹配字符串&#39;aaa&#39;的话，会匹配aaa而不是a
</code></pre></td></tr></table>
</div>
</div><p>取消贪婪模式可以在量词后加 ？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">a{1, 3}? // 匹配字符串&#39;aaa&#39;的话，会匹配a而不是aaa
</code></pre></td></tr></table>
</div>
</div><h4 id="边界">边界</h4>
<p>边界的匹配是一个很重要的需求，主要包括三种</p>
<ol>
<li>使用 <code>^</code> 匹配开头，比如 <code>^abc</code> 表示以 abc 为开头的字符串</li>
<li>使用 <code>$</code> 匹配结尾，比如 <code>abc$</code> 表示以 abc 为结尾的字符串</li>
<li>使用 <code>\b</code> 匹配单词边界，比如我们想搜索单词 cat，结果 scattered 也会被搜索到，这时候就可以使用 <code>\b</code> 表示单词边界，使用方法为 <code>\bcat\b</code></li>
</ol>
<h4 id="集合">集合</h4>
<p>很多时候我们还需要匹配一个字符集合，比如，匹配 a,b,c 这三个字符中的任意一个，这种需求通过一对方括号实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[abc]
</code></pre></td></tr></table>
</div>
</div><p>使用连字符可以表示一个范围</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[0-9] // 等于[0123456789]
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>^</code> 可以表示除了方括号中的字符以外的其它字符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[^abc] // 表示除了 a,b,c 以外的其它字符
</code></pre></td></tr></table>
</div>
</div><p>字符串的选择通过 <code>|</code> 来表达，实际上就是或的概念，比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">123|456  // 表示匹配 123 或者匹配456
</code></pre></td></tr></table>
</div>
</div><h4 id="修饰符">修饰符</h4>
<p>在正则表达式的末尾添加修饰符可以更改某些正则默认的规则</p>
<ul>
<li>i ，正则默认区分大小写，i 可以忽略大小写</li>
<li>g，正则遇到第一个匹配的字符串就会结束，g 可以匹配所有符合条件的字符串</li>
<li>m，正则默认遇到换行结束，不匹配多行文本，m 可以匹配多行文本</li>
</ul>
<p>举一个多行匹配的例子，在下面的文本中匹配 <code>I am scq000</code> 这个句子，使用的正则表达式为 <code>/^I am scq000\.$/m</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">I am scq000.
I am scq000.
I am scq000.
</code></pre></td></tr></table>
</div>
</div><h3 id="23-子表达式">2.3 子表达式</h3>
<p>利用上面的语法可以构成基本的正则表达式，通过对基本正则表达式的组合，可以推导出无限复杂的正则表达式，使用的基本思想是嵌套递归和自身引用，涉及的概念包括分组、回溯引用、预搜索。</p>
<h4 id="分组">分组</h4>
<p>就是利用成对的小括号 <code>()</code> 将一个正则表达式包围，包围以后就表示这是一个子表达式，子表达式是构成复杂正则表达式的基本单位。</p>
<p>一个简单的分组使用如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">(abc){2} // 匹配abcabc
</code></pre></td></tr></table>
</div>
</div><h4 id="回溯引用">回溯引用</h4>
<p>回溯引用指的是整个正则表达式后面的部分引用前面子表达式匹配到的字符串，类似于将前面的子表达式看作了一个变量。基本结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">(子表达式1)(子表达式2)(子表达式3)\1\2\3
</code></pre></td></tr></table>
</div>
</div><p><code>\1</code>代表第一个子表达式、<code>\2</code>代表第二个子表达式、<code>\3</code>代表第三个子表达式。以此类推，<code>\0</code> 一般表示整个表达式。</p>
<p>注：有些语言（比如JS）使用 <code>$</code> 而不是 <code>\</code></p>
<p>比如要在一段文本里匹配两个连续相同的单词，用简单的正则只能保证两个单词符号相同的规则，但不能保证它们相同</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Hello what what is the first thing, and I am am scq000.
</code></pre></td></tr></table>
</div>
</div><p>使用回溯就可以很容易的获得结果： <code>\b(\w+)\s\1\b</code>，后面的 <code>\1</code> 会再一次匹配前面的字符串本身。</p>
<p>如果某个子表达式不想被引用，可以使用 <code>(?:regex)</code>这样的表达方式，比如 <code>\b(?=\w+)\s\1\b</code> 这样的表达式就无法匹配到之前获得的结果了</p>
<h4 id="预搜索">预搜索</h4>
<p>预搜索是为了应对四种情况</p>
<ol>
<li>
<p>要求字符串前面必须是另一个字符串，比如要求 <code>ple</code> 前面必须是 <code>ap</code>，正则表达式为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">(?&lt;=ap)ple
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>要求字符串前面不能是另一个字符串，比如要求 <code>ple</code> 前面不能是 <code>ap</code>，正则表达式为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">(?&lt;!ap)ple // 可能匹配到 people
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>要求字符串后面必须是另外一个字符串，比如要求 <code>happ</code> 后面必须是 <code>ily</code>，正则表达式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">happ(?=ily)
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>要求字符串后面不能是另外一个字符，使用 <code>!</code> 表示非的含义即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">happ(?!ily) // 表示happy 不能是 ily，可能匹配到 happy
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>还有一些正则可能用到的工具</p>
<ul>
<li><a href="https://jex.im/regulex/#!flags=&amp;re=" target="_blank" rel="noopener noreffer">Regulex</a>：用有限状态自动机可视化正则表达式</li>
<li><a href="https://oktools.net/regex" target="_blank" rel="noopener noreffer">OKTools</a>：在线正则表达式测试</li>
</ul>
<h2 id="3-区别">3. 区别</h2>
<p>通配符和正则表达式的区别比较明显，</p>
<ol>
<li>通配符语法比正则表达式简单很多</li>
<li>通配符一般用于文件路径名匹配，正则表达式一般用于字符串匹配</li>
</ol>
<p>所以在命令行中，与路径相关的命令，比如 cp, ls, find 等，都使用通配符；而与字符串匹配相关的命令，比如 grep，使用正则表达式。</p>
<p>Office 或者编程基本上是对字符串的匹配，因此一般使用正则表达式。</p>
<h2 id="参考">参考</h2>
<p>[1] Office 支持，<a href="https://support.microsoft.com/zh-cn/office/%e5%9c%a8%e6%90%9c%e7%b4%a2%e4%b8%ad%e4%bd%bf%e7%94%a8%e9%80%9a%e9%85%8d%e7%ac%a6%e5%ad%97%e7%ac%a6-ef94362e-9999-4350-ad74-4d2371110adb" target="_blank" rel="noopener noreffer">在搜索中使用通配符</a></p>
<p>[2] 掘金，<a href="https://juejin.im/post/6844903845227659271" target="_blank" rel="noopener noreffer">正则表达式不要背</a></p>
<p>[3] 知乎，<a href="https://zhuanlan.zhihu.com/p/28672572" target="_blank" rel="noopener noreffer">正则表达式教程-语法篇</a></p>
<p>[4] CSDN，<a href="https://blog.csdn.net/weini1111/article/details/72896874" target="_blank" rel="noopener noreffer">通配符和正则表达式的区别</a></p>]]></description></item><item><title>算法-字符串类问题</title><link>https://shuzang.github.io/algorithm-stings/</link><pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-stings/</guid><description><![CDATA[<p>做 Leetcode 每日一题的时候遇到了子串判断类的问题，想起一直没仔细的去看过 KMP 等字符串常用的算法，所以这里学习一下。</p>
<!---more-->
<h2 id="1-重复的子字符串">1. 重复的子字符串</h2>
<p>这就是今天遇到的题目，题目描述为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:
输入: &#34;abab&#34;
输出: True
解释: 可由子字符串 &#34;ab&#34; 重复两次构成。

示例 2:
输入: &#34;aba&#34;
输出: False

示例 3:
输入: &#34;abcabcabcabc&#34;
输出: True
解释: 可由子字符串 &#34;abc&#34; 重复四次构成。 (或者子字符串 &#34;abcabc&#34; 重复两次构成。)
</code></pre></td></tr></table>
</div>
</div><p>首先确认边界条件</p>
<ol>
<li>字符串长度满足：0 &lt; len(s) &lt;= 10000，所以不需要考虑空字符串</li>
<li>字符串的子串不包括自己，也就是说，「一个字符串由自己重复 1 次构成」这种说法不成立，可由示例2得出</li>
</ol>
<p>然后确认基本思路</p>
<ol>
<li>遍历所有可能的子串长度，从 1 到 len(s)/2，然后判断这个长度的子串是否可能为结果。取 len(s)/2 是因为超过字符串长度一半的子串不可能通过重复构成原字符串；</li>
<li>字符串的长度一定是子串长度的倍数，否则也不可能是结果；</li>
<li>考虑如何取给定长度的子串，由于字符串由子串重复构成，那么只需要从第一个字符开始取即可，长度为 n 的子串就从第一个字符开始取 n 个字符构成子串；</li>
</ol>
<p>最后根据该思路编写代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">repeatedSubstringPattern</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 字符串长度可能是1到len(s)/2
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 只有 len(s) 是子字符串长度的倍数才有可能
</span><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 子串为 s[:i]，然后对字符串的其它部分进行判断
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">flag</span> <span class="kt">bool</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">j</span> <span class="o">+=</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">:</span><span class="nx">j</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 中途没有跳出才说明整个字符串由子串重复构成
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 所有长度的子串都无法重复构成原字符串
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码编写完成后要考虑最后一件事，就是条件和循环的边界条件，这是最容易产生错误的地方</p>
<ol>
<li>
<p><code> i &lt;= len(s)/2</code>：当 <code>i == len(s)/2</code> 的时候，子串为 <code>s[:len(s)/2]</code>，以字符串 <code>abab</code> 为例，子串为 <code>ab</code>，因为 Go 的切片不会取最后一个字符，所以必须添加 <code>=</code> 号，不然会漏掉一种情况；</p>
</li>
<li>
<p><code>j &lt; len(s)</code>：我们考虑最后一次循环的 j，此时 <code>s[j:j+i]</code> 中 <code>j+i</code> 可能会越界超出 len(s)，导致 panic。遇到这种情况我们最常用的做法是修改条件为 <code>j + i &lt; len(s)</code>，然后我们来考虑边界条件。</p>
<p>当 <code>j + i == len(s)</code> 的时候， <code>s[j:j+i]</code> 其实原本想表达的含义是最后一个字符串，是应该取的，但是 j + i 产生越界，所以要额外处理。</p>
</li>
</ol>
<p>修改后的程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">repeatedSubstringPattern</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 字符串长度可能是1到len(s)/2
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 只有 len(s) 是子字符串长度的倍数才有可能
</span><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 子串为 s[:i]，然后对字符串的其它部分进行判断
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">flag</span> <span class="kt">bool</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">j</span> <span class="o">+=</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">tmp</span> <span class="kt">string</span>
            <span class="k">if</span> <span class="nx">j</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">tmp</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">:]</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="nx">tmp</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">:</span><span class="nx">j</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 中途没有跳出才说明整个字符串由子串重复构成
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 所有长度的子串都无法重复构成原字符串
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-模式匹配bf算法">2. 模式匹配BF算法</h2>
<p>上面的问题可以使用 KMP 算法解决，但解释 KMP 算法之前必须先了解 BF 算法。</p>
<p>模式匹配问题为：假设有两个字符串 S 和 T，设 S 为主串，判断 T 是否为 S 的子串，如果是，返回子串在主串中第一个出现的位置，如果不是，返回 -1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">示例 1:
输入: haystack = &#34;hello&#34;, needle = &#34;ll&#34;
输出: 2

示例 2:
输入: haystack = &#34;aaaaa&#34;, needle = &#34;bba&#34;
输出: -1
</code></pre></td></tr></table>
</div>
</div><p>最笨的办法，也就是暴力法，是穷举 S 所有的子串，判断是否和 T 相同，该算法就称为 BF（Brute Force）算法。为了介绍通用的算法，这里放弃 Go 切片的优势，采用逐个字符匹配的方式。代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// 子串为空，返回0
</span><span class="c1"></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>

    <span class="c1">// = 号是考虑子串等于主串的情况
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">flag</span> <span class="kt">bool</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-模式匹配kmp算法">3. 模式匹配KMP算法</h2>
<p>实际上，没有必要从主串 S 的每一个字符开始穷举每种情况。Knuth、Morris、Pratt 对该算法进行了改进，提出了 KMP 算法。</p>
<p>设 <code>S = abaabaabeca，T = abaabe</code>，KMP 的流程如下</p>
<p>从S第1个字符开始：i=1, j=1，比较两个字符是否相等，如果相等，则 i++, j++；等到第一次匹配不相等的时候，BF算法会继续从 S 第 2个字符开始和 T 第一个字符进行比较，但 BMP 的做法是：S 的索引不需要移动，T 的索引回退 3 个，如下图</p>
<p></p>
<p>这样做的原因是 T 串中 j 索引前面的两个字符和 S 串中 i 索引前面的两个字符相同，都是 <code>ab</code>，所以现在的关键变成了我们怎么知道 i 前面的字符和 j 前面的字符相同，有几个字符相同（这决定了 j 回退几个位置）</p>
<p>直观的想法是进行第二次的比较，比较 T 开头的字符和 i 前面的字符，但其实不需要，因为在 j 回退之前，i 前面的字符必然和 j 前面的字符相同，如下</p>
<p></p>
<p>所以问题转化成了 T 内部字符的比较，假设 T 中当前 j 指向的前面的所有字符为 $T'$，上图中 $T' = abaab$，那么只需要比较 $T'$ 的前缀和后缀即可。判断其前缀后缀是否相等，并寻找相等前缀后缀的最大长度。</p>
<ol>
<li>长度为1：前缀 a，后缀 b，不相等</li>
<li>长度为2：前缀 ab，后缀 ab，相等</li>
<li>长度为3：前缀 aba，后缀 aab，不相等</li>
<li>长度为4：前缀 abaa，后缀 baab，不相等</li>
</ol>
<p>相等前缀后缀的最大长度为 2，则 j 可以回到 2+1=3 个位置继续比较。如果将这个回退的位置表示为 next[j]，令 $T' = t_1t_2&hellip;t_{j-1}$，则可得公式</p>
<p></p>
<p>由于字符串 T 的长度有限，next[] 其实是一个固定的数组</p>
<table>
<thead>
<tr>
<th>j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>e</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>假设 next[j] = k，$T' = t_1t_2&hellip;t_{j-1}$，那么 T 的相等前缀、后缀最大长度为 k-1</p>
<p></p>
<p>我们在求 next[j+1] 的时候可以考虑动态规划递推的办法</p>
<ol>
<li>
<p>$t_k = t_j$：那么 next[j+1] = k+1，即相等前缀和后缀的长度比 next[j] 多1，如下图</p>
<p></p>
</li>
<li>
<p>$t_k \neq t_j$：那么回退找 next[k] = k' 的位置，比较 $t_{k'}$ 和 $t_j$ 是否相等</p>
<p></p>
<p>如果相等，则 next[j+1] = k'' + 1，如果不相等，继续向前找，直到找到 next[i] = 0 停止</p>
<p></p>
</li>
</ol>
<p>求解 next 的代码实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getNext</span><span class="p">(</span><span class="nx">T</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">next</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">j</span><span class="p">,</span><span class="nx">k</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
    <span class="nx">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">T</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">T</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">j</span><span class="p">,</span><span class="nx">k</span> <span class="p">=</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span>
            <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">k</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">k</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>KMP 算法的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">KMP</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span><span class="nx">T</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pos</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">i</span><span class="p">,</span><span class="nx">j</span> <span class="o">:=</span> <span class="nx">pos</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">S</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">S</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">T</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">i</span><span class="o">++</span>
            <span class="nx">j</span><span class="o">++</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">j</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">i</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>HTTP方法</title><link>https://shuzang.github.io/http-method/</link><pubDate>Thu, 20 Aug 2020 19:38:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/http-method/</guid><description><![CDATA[<p>理解不同的 HTTP 方法的区别，主要参考 <a href="https://tools.ietf.org/html/rfc7231#section-4.3" target="_blank" rel="noopener noreffer">RFC 7231</a></p>
<h2 id="1-方法的特性">1. 方法的特性</h2>
<p>首先是方法的三个属性：安全性、幂等性和可缓存。</p>
<h3 id="11-安全性">1.1 安全性</h3>
<p>安全性，safe，指的是该方法在语义上是只读的，不会修改服务器的数据。但即使是安全的方法，服务器也可以更改自己的数据，比如记录此次请求的日志。安不安全仅意味着客户端不需要服务端修改数据，因此不用考虑会对服务端造成危害。</p>
<p>安全的方法也不一定知识对服务端静态资源的请求，服务端可以在请求的时候返回即时生成的资源，只要生成资源的脚本保证是安全的即可：也就是说生成资源的时候没有额外影响。就像在一个电商网站添加删除购物车里的物品一样。</p>
<p>安全的方法有 GET，HEAD，OPTIONS，TRACE。</p>
<h3 id="12-幂等性">1.2 幂等性</h3>
<p>幂等性，Idempotent，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说，幂等方法不应该具有副作用。</p>
<p>PUT、DELETE 是幂等的，所有安全的方法都是幂等的</p>
<p>幂等只与后端服务器的实际状态有关，比如，DELETE 删除资源后，第二次调用不应当删除另一个资源，否则服务器的状态将不一致，第一次调用会返回 200，但后续的调用就会返回 404。POST 则不一样，连续调用多次，会增加多个相同的资源。</p>
<h3 id="13-可缓存">1.3 可缓存</h3>
<p>可缓存，Cacheable，指的是可以存储对这些方法的响应以便将来重用。GET、HEAD、POST 方法是可缓存的，不过一般只实现前两个。</p>
<h2 id="2-get">2. GET</h2>
<p>GET 方法用于请求指定的资源，并且只用于获取数据。</p>
<p>使用 GET 方法时请求报文没有实体部分，但成功的响应有实体部分。</p>
<p>GET 方法是安全的、幂等的、可缓存的。浏览器会主动缓存 GET 方法的响应，如果下一次传输的数据相同，就返回缓存中的内容，以求更快的展示。</p>
<p>GET 方法请求的数据一般附在 URL 之后，以 ？分割 URL 和传输数据，多个参数以 &amp; 连接。由于 URL 一般有长度限制，所以即使 HTTP 并未规定 GET 请求的长度，但实际上受 URL 的长度限制。</p>
<h2 id="3-head">3. HEAD</h2>
<p>HEAD 方法请求资源的头部信息，该头部信息与 GET 方法请求返回时的一致。常见的使用场景是在下载一个大文件前先获取其大小再决定是否下载，以此节约带宽资源。</p>
<p>如果 HEAD 请求的结果显示上一次 GET 请求后缓存的资源已过期，那么即使没有再次发出 GET 请求，该缓存也会失效。</p>
<p>HEAD 方法是安全的、幂等的、可缓存的。</p>
<h2 id="4-post">4. POST</h2>
<p>POST 方法发送数据给服务器，因此请求和响应报文都有实体部分，请求报文实体的类型由 <code>Content-Type</code> 首部指定。</p>
<p>POST  请求通常通过表单来发送，此时 <code>content-type</code> 类型是通过在 <code>&lt;form&gt;</code> 元素中设置正确的 <code>enctype</code> 属性, 或是在 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素中设置 <code>formenctype</code> 属性来选择的</p>
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
<p>如果 POST 请求不是通过表单发送，那么实体部分可以是任意类型。</p>
<p>POST 方法不符合安全性和幂等性，但却可以是可缓存的。</p>
<p>由于 POST 方法将提交的数据放在报文的实体部分，因此没有长度的限制。</p>
<p>GET 与 POST 的区别很多都是由于 GET 拼接 URL，POST 传实体部分造成的，包括</p>
<ol>
<li>收藏书签：GET可以，POST不可以，因为 URL 可收藏</li>
<li>保留浏览器历史记录：GET可以，POST不可以，因为 URL 可记录</li>
<li>安全性：GET 稍低，因为 URL 直接可见，可能被劫持</li>
</ol>
<h2 id="5-put">5. PUT</h2>
<p>PUT 方法使用请求报文中的实体部分创建或替换目标资源。它的请求报文有实体部分，但响应报文没有。</p>
<p>PUT 和 POST 的区别在于 PUT 是幂等的，即调用一次与连续调用多次是等价的。举个例子，对于订单提交，多次调用 POST 方法会重复产生多个订单，PUT 方法不会，而是会覆盖掉前一个订单。</p>
<p>使用 PUT 方法时，如果目标资源不存在，则服务器创建一份，并返回 201（Created），通知客户端已创建。如果目标资源已存在，则进行更新，服务器返回 200（OK）或者 204（No Content）表示请求处理成功。</p>
<h2 id="6-delete">6. DELETE</h2>
<p>DELETE 方法用于删除指定的资源，它是幂等的，第一次调用会返回指定资源，第二次会返回 404（Not Found），不会删除另一个资源。</p>
<h2 id="7-connect">7. CONNECT</h2>
<p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p>
<p>例如，CONNECT 可以用来访问采用了 HTTPS 协议的站点。客户端要求代理服务器将 TCP 连接作为通往目的主机隧道。之后该服务器会代替客户端与目的主机建立连接。连接建立好之后，代理服务器会面向客户端发送或接收 TCP 消息流。</p>
<h2 id="8-options">8. OPTIONS</h2>
<p>OPTIONS 方法用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。</p>
<p>比如，检测服务器所支持的请求方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">curl -X OPTIONS http://example.org -i
</code></pre></td></tr></table>
</div>
</div><p>响应报文首部的 <code>Allow</code> 字段值汇报课该服务器支持的所有 HTTP 方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST
Cache-Control: max-age=604800
Date: Thu, 13 Oct 2016 11:45:00 GMT
Expires: Thu, 20 Oct 2016 11:45:00 GMT
Server: EOS (lax004/2813)
x-ec-custom-error: 1
Content-Length: 0
</code></pre></td></tr></table>
</div>
</div><h2 id="9-trace">9 .TRACE</h2>
<p>TRACE 方法使请求的接收者原样返回它收到的消息，一般用于测试或诊断</p>
<h2 id="10-patch">10. PATCH</h2>
<p>PATCH 用于资源的部分修改，不同于 PUT，它是非幂等的，连续多个相同请求会产生不同的效果。</p>
<p>要判断一台服务器是否支持 <code>PATCH </code>方法，那么就看它是否将其添加到了响应首部 <code>Allow</code>或者 <code>Access-Control-Allow-Methods</code>（在跨域访问的场合，CORS）的方法列表中 。</p>]]></description></item></channel></rss>