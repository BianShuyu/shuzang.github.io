<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>研究生的区块链学习之路 - 分类 - Shuzang's Blog</title><link>https://shuzang.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</link><description>研究生的区块链学习之路 - 分类 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 18 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://shuzang.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" rel="self" type="application/rss+xml"/><item><title>浮点数处理</title><link>https://shuzang.github.io/math-in-solidity/</link><pubDate>Sun, 18 Oct 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/math-in-solidity/</guid><description><![CDATA[<p>对 Solidity 中如何进行浮点数的处理做说明。</p>
<p>首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。</p>
<ol>
<li>来自 <a href="https://ethereum.stackexchange.com/questions/83785/what-fixed-or-float-point-math-libraries-are-available-in-solidity" target="_blank" rel="noopener noreffer">ethereum stackexchange</a> 中的回答，介绍了一些可用的库；</li>
<li><a href="https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md" target="_blank" rel="noopener noreffer">ABDK Math Quad</a>，包含两个合约库，一个支持定点数，一个支持浮点数；</li>
<li>Mikhail Vladimirov 的 <a href="https://medium.com/coinmonks/math-in-solidity-part-1-numbers-384c8377f26d" target="_blank" rel="noopener noreffer">Math in Solidity</a> 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。</li>
</ol>]]></description></item><item><title>交易池底层实现</title><link>https://shuzang.github.io/transaction-and-txpool/</link><pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/transaction-and-txpool/</guid><description><![CDATA[<p>起源于老师提出的一个问题：区块链是如何处理同时发起的多个请求的。想了想觉得核心是交易池机制，因此准备看一下交易池的原理和实现。</p>
<p>针对这个问题其实我们要找以下几个问题的答案：</p>
<ol>
<li>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</li>
<li>产生的交易如果不能被及时处理，是如何进入交易池的；</li>
<li>本地产生的交易和从网络中接收到的交易进入交易池是否有区别；</li>
<li>交易池的基本数据结构是怎么样的（优先队列？）</li>
<li>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）</li>
</ol>
<p>入手主要是通过登链社区的 <a href="https://learnblockchain.cn/2019/06/03/eth-txpool/" target="_blank" rel="noopener noreffer">以太坊交易流程及交易池 Txpool 分析</a> 这篇文章，通过它快速找到了源码中的相关函数，因为主要使用的是 Quorum，所以看的是 Quorum 的源码。</p>
<p>注：网络中很多文章提到内存池，指的也是txpool</p>
<h2 id="1-交易形成">1. 交易形成</h2>
<p>我们的交易请求最终会赋值到 SendTxArgs 结构体的一个实例中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SendTxArgs</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">PrivateTxArgs</span> <span class="c1">// Quorum
</span><span class="c1"></span>
	<span class="nx">From</span>     <span class="nx">common</span><span class="p">.</span><span class="nx">Address</span>  <span class="s">`json:&#34;from&#34;`</span>
	<span class="nx">To</span>       <span class="o">*</span><span class="nx">common</span><span class="p">.</span><span class="nx">Address</span> <span class="s">`json:&#34;to&#34;`</span>
	<span class="nx">Gas</span>      <span class="o">*</span><span class="nx">hexutil</span><span class="p">.</span><span class="nx">Uint64</span> <span class="s">`json:&#34;gas&#34;`</span>
	<span class="nx">GasPrice</span> <span class="o">*</span><span class="nx">hexutil</span><span class="p">.</span><span class="nx">Big</span>    <span class="s">`json:&#34;gasPrice&#34;`</span>
	<span class="nx">Value</span>    <span class="o">*</span><span class="nx">hexutil</span><span class="p">.</span><span class="nx">Big</span>    <span class="s">`json:&#34;value&#34;`</span>
	<span class="nx">Nonce</span>    <span class="o">*</span><span class="nx">hexutil</span><span class="p">.</span><span class="nx">Uint64</span> <span class="s">`json:&#34;nonce&#34;`</span>
	<span class="nx">Data</span>  <span class="o">*</span><span class="nx">hexutil</span><span class="p">.</span><span class="nx">Bytes</span> <span class="s">`json:&#34;data&#34;`</span>
	<span class="nx">Input</span> <span class="o">*</span><span class="nx">hexutil</span><span class="p">.</span><span class="nx">Bytes</span> <span class="s">`json:&#34;input&#34;`</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个实例被传递给 <code>quorum/internal/ethapi/api.go</code> 的 <code>SendTransaction</code> 函数用来创建一个交易。创建交易的过程如下</p>
<ol>
<li>根据 From 字段找到当前账户</li>
<li>设置交易默认参数</li>
<li>对交易进行序列化，变为可存储和传输的形式。</li>
<li>根据 To 字段决定是创建部署合约交易还是调用合约交易</li>
<li>对交易进行 RLP 编码并根据之前获得的账户密钥对交易进行签名</li>
<li>提交交易到交易池</li>
</ol>
<p>序列化主要处理 SendTxArgs 结构中的 Data 和 Input 字段，Data 字段主要用于向前兼容，应尽量使用 Input 字段。当部署合约的时候，Input 是合约代码，当发送交易的时候，Input 是交易的内容。</p>
<h2 id="2-交易添加到交易池">2. 交易添加到交易池</h2>
<p>SendTransaction 最后调用 <code>SubmitTransaction</code> 函数将交易提交到交易池，不过，更底层的调用是 <code>quourm/core/tx_pool.go</code> 的 AddLocals 函数，这里还应该提到，来自网络的交易会调用 AddRemotes 函数。</p>
<p>需要注意的是，调用这两个函数之前都应该验证交易的有效性。同时，这两个函数底层都调用 addTxs 函数，最终的调用是 add 函数。不过在介绍 add 函数前先了解一下交易池的结构。</p>
<p>交易池是一个非常复杂的结构体，但最核心的字段只有两个 <code>pending</code> 和 <code>queue</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TxPool</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">pending</span> <span class="kd">map</span><span class="p">[</span><span class="nx">common</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="o">*</span><span class="nx">txList</span>   <span class="c1">// All currently processable transactions
</span><span class="c1"></span>	<span class="nx">queue</span>   <span class="kd">map</span><span class="p">[</span><span class="nx">common</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="o">*</span><span class="nx">txList</span>   <span class="c1">// Queued but non-processable transactions
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/ConsenSys/quorum/blob/d51931173bde132243a87e7a2adadef4abe58470/core/tx_pool.go#L601" target="_blank" rel="noopener noreffer">add</a> 函数比较复杂，但添加交易到交易池的逻辑很简单</p>
<ol>
<li>验证交易的有效性</li>
<li>如果 nonce 已存在，且 pending 中旧交易的 price 没有新交易高，会被新交易替换掉</li>
<li>如果 nonce 不存在，不可以替换 pending 中的任何交易，此时将新的交易插入 queue 的末尾</li>
</ol>
<p>注：交易中的 nonce 指的是 from 账户发出交易的次数, 从0开始递增，同一账户的交易会被依次确认，所以同一个 nonce 代表是同一个交易，会优先选择 price 更高的交易。</p>
<h2 id="3-清理交易池">3. 清理交易池</h2>
<p>交易池是完全存在内存中的，因此有大小限制，每当超过一定的阈值就需要清理。实际实现时，pending 的缓冲区容量默认为 4096，queue 的缓冲区容量默认为 1024。</p>
<p>清理的时机是交易池满的时候，清理的原则是价格较低的最先清理</p>
<p>调用清理函数依然是在 add 函数中</p>
<h2 id="4-重构交易池">4. 重构交易池</h2>
<p>作为一个分布式系统，总是会出现一种情况：本地节点已经挑选好最优的交易，并准备好广播给整个网络，结果这个时候矿工已经打包好了一个区块，这时候本地节点的区块头就是旧的了，筛选好的交易也已经可能被打包，此时再广播这些交易就没了意义。</p>
<p>为了避免上述情况的发生，本地节点要随时监听是否有新区块产生，当监听到新区块产生这个事件后，无论是本地节点领先，还是网络上其它节点领先，都回退一个区块号，</p>
<p></p>
<p>本地节点回退时，把撤销的交易保持到 discarded 切片中，网络上其他节点的撤销交易保存在 <code>included</code> 切片中。</p>
<p>当区块号一致的时候，还需要进一步的比较区块的 <code>Hash</code> 来进一步确认区块里面的交易是否一致，如果不一致一致回退到区块 Hash 为止，回退撤销的交易依旧保存在 <code>discarded</code> 和 <code>included</code> 切片中。</p>
<p>等完全确认本地和网络的链没有分叉的时候，就需要比较 discarded 和 included 里面的交易，因为网络上区块的生成优先级高于本地，所以需要剔除 <code>discarded</code> 中 <code>inclueded</code> 的交易，生成 <code>reinject</code> 切片，剔除完以后还需要对 <code>TXpool</code> 按照网络新生成区块的信息设置世界状态等信息，设置完以后，重新将 <code>reinject</code> 加入 <code>TXpool</code>，加入以后在进行验证清理等流程。</p>
<h2 id="5-问题回答">5. 问题回答</h2>
<p>回答文章开头提出的几个问题</p>
<ol>
<li>
<p>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</p>
<p>所有与交易请求相关的参数被赋值到一个结构体中，然后进行序列化转变为可存储和传输的形式，最后生成交易并进行签名</p>
</li>
<li>
<p>产生的交易如果不能被及时处理，是如何进入交易池的</p>
<p>最终是调用一个 add 函数，添加到了一个队列里</p>
</li>
<li>
<p>本地产生的交易和从网络中接收到的交易进入交易池是否有区别；</p>
<p>没有区别，底层都是调用 add 函数</p>
</li>
<li>
<p>交易池的基本数据结构是怎么样的（优先队列？）</p>
<p>交易池是一个结构体，核心是 pending 和 queue 两个 map，map 的键是一个地址，值是一个交易链表形成的队列</p>
</li>
<li>
<p>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）</p>
<p>price 越高优先级越大</p>
</li>
</ol>
<p>我们可以理解为区块链底层利用交易池对并发产生的请求做了异步化，交易产生的时刻和交易被打包的时刻是随机的。</p>
<p>这里面我们可以视作有一个排队论的问题，相关度比较高的论文有两篇</p>
<p>[1] J. Li, Y. Yuan, S. Wang and F. Wang, &ldquo;<a href="https://ieeexplore.ieee.org/document/8500403" target="_blank" rel="noopener noreffer">Transaction Queuing Game in Bitcoin BlockChain</a>,&rdquo; <em>2018 IEEE Intelligent Vehicles Symposium (IV)</em>, Changshu, 2018, pp. 114-119, doi: 10.1109/IVS.2018.8500403.</p>
<p>[2] Memon RA, Li JP, Ahmed J. <a href="https://www.mdpi.com/2079-9292/8/2/234#cite" target="_blank" rel="noopener noreffer">Simulation Model for Blockchain Systems Using Queuing Theory</a>. <em>Electronics</em>. 2019; 8(2):234.</p>
<p>后注1：在实现 TXpool 的时候为了保证数据的一致性会使用大量的锁</p>
<p>后注2：总结以下可以发现交易池中交易的顺序与以下几方面有关</p>
<ol>
<li>交易费</li>
<li>交易哈希（重构交易池时区块相同会进行比较）</li>
<li>在交易池中的时间（时间过长可能会被清除）</li>
</ol>
<h2 id="6-时间">6. 时间</h2>
<p>更全面的描述可以参考 <a href="https://learnblockchain.cn/books/geth/part2/txpool.html" target="_blank" rel="noopener noreffer">以太坊技术与实现：交易池</a></p>
<p>我们关心发起交易的时间和智能合约执行并返回结果的时间是否有区别</p>]]></description></item><item><title>符合泊松分布的事件模拟到达时间生成</title><link>https://shuzang.github.io/generate-random-timings-for-a-poisson-process/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/generate-random-timings-for-a-poisson-process/</guid><description><![CDATA[<p>我们要进行的仿真是在随机的时间执行随机的事件，这个时间就叫做事件到达时间。根据已有知识，随机的事件到达时间应该符合泊松分布，事件到达时间的间隔符合指数分布，实现时通常采用生成到达时间间隔的方式。这里的实现翻译了文章 <a href="https://preshing.com/20111007/how-to-generate-random-timings-for-a-poisson-process/" target="_blank" rel="noopener noreffer">How to Generate Random Timings for a Poisson Process</a>，使用的语言是 Go。</p>
<p>事件的发生是随机的，但是从总体上看，事件以平均的速率发生，这就是泊松过程。举个例子，USGS 预计每年全世界大约发生 13000 场 4 级以上的地震，这些地震发生的时间是随机的，但一定在 13000 场左右。</p>
<p>统计学中有大量的函数和方程用于建模泊松过程，这篇文章介绍了一种其中一种函数，并给出了一个实现程序。</p>
<h2 id="1-指数分布">1. 指数分布</h2>
<p>如果每年 13000 场地震，那么平均 40 分钟一场地震，所以定义变量 $\lambda = \frac{1}{40}$，称为速率参数，这是一个频率的衡量：单位时间（地震的例子里是分钟）发生事件（地震）的平均速率。</p>
<p>因此，接下来的问题是，下一分钟发生地震的概率是多少？下一个十分钟呢？这里有一个众所周知的函数，称为 指数分布的累积分布函数（cumulative distribution function for the exponential distribution），该函数看起来如下：
$$
F(x) = 1 - e^{-\lambda x}
$$</p>
<p></p>
<p>其含义是，随之时间的流逝，在世界上某个地方发生地震的可能性不断增大，这里「指数」的含义是指数衰减，随着时间流逝，不发生地震的可能性逐渐趋近于0，相应的，发生至少一场地震的可能性也趋向于1。</p>
<p>插入一些值，我们发现：</p>
<ul>
<li>下一分钟发生地震的可能性为 $F(1) \approx 0.0247$，该值无限接近于 $\frac{1}{40}$，这个我们预设的地震频率，但不相等；</li>
<li>下一个十分钟发生地震的可能性为 $F(10) \approx 0.221$</li>
</ul>
<p>特别的，下一个 40 分钟发生地震的可能性为 $F(40) \approx 0.632$，因此，40分钟的间隔内很可能发生地震，但不绝对。</p>
<h2 id="2-编写仿真">2. 编写仿真</h2>
<p>现在，假设我们要模拟游戏引擎或其他某种程序中地震的发生。首先，我们需要弄清楚每次地震的开始时间。</p>
<p>一种方法是循环，每隔 X 分钟之后，在 0 到 1 之间采样一个随机浮点值。如果该数字小于 $F(X)$，则开始地震。X 可以是一个小数值，因此可以每分钟采样几次，甚至每秒采样几次。只要随机数生成器是统一的并且提供足够的数值精度，这一个方法就会很好用。但是，如果打算以 $λ=\frac{1}{40}$ 每秒进行 60 次采样，随机数生成器需要至少18位精度，标准 C运行时库并不总是提供这一精度。</p>
<p>另一种方法是回避整个采样策略，只需编写一个函数即可确定下一次地震的确切时间。此函数应返回随机数，但不是大多数生成器生成的统一类型的随机数，而是以遵循指数分布的方式生成随机数。</p>
<p>Donald Knuth 在 「The Art of Computer Programming」一书的 3.4.1(D) 一节描述了一种生成这种值的方法，只需在 y 轴上选择介于 0 和 1 之间的均匀分布的随机点，然后在 x 轴上找到相应的时间值即可。例如，如果我们从下图 y 轴选择 0.2 点，那么到下一次地震的时间将是 64.38 分钟。</p>
<p></p>
<p>由于指数函数的反函数是 ln，写这个程序很简单，其中 U 是 0 到 1 之间的随机值：</p>
<h2 id="3-实现">3. 实现</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">nextTime</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">40.0</span><span class="p">))</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">nextTime</span><span class="p">(</span><span class="nx">rateParameter</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="nx">math</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Float64</span><span class="p">())</span> <span class="o">/</span> <span class="nx">rateParameter</span>
<span class="p">}</span>
<span class="c1">// Output:
</span><span class="c1"></span><span class="mf">3.645968256349058</span>
<span class="mf">21.416099701223878</span>
<span class="mf">27.140451644356354</span>
<span class="mf">132.53700107810388</span>
<span class="mf">10.94869965544849</span>
</code></pre></td></tr></table>
</div>
</div><p>经测试，该函数返回的平均时间确实为40</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestNextTime</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">sum</span> <span class="kt">float64</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="o">+=</span> <span class="nf">nextTime</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">40.0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sum</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span>
		<span class="nx">sum</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Output:
</span><span class="c1"></span><span class="o">==</span><span class="p">=</span> <span class="nx">RUN</span>   <span class="nx">TestNextTime</span>
<span class="mf">39.936436485414866</span>
<span class="mf">40.073299195147676</span>
<span class="mf">40.02405410596529</span>
<span class="mf">39.984823394877324</span>
<span class="mf">39.970452381128254</span>
<span class="mf">40.05045384327815</span>
<span class="mf">39.94419161580051</span>
<span class="mf">40.038542654941246</span>
<span class="mf">39.983753932119754</span>
<span class="mf">40.029867240804506</span>
<span class="o">---</span> <span class="nx">PASS</span><span class="p">:</span> <span class="nf">TestNextTime</span> <span class="p">(</span><span class="mf">0.42</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">PASS</span>
<span class="nx">ok</span>  	<span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">shuzang</span><span class="o">/</span><span class="nx">test</span>	<span class="mf">0.652</span><span class="nx">s</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上，Go 在 math/rand 库中本身就提供了一个生成符合指数分布的随机数的函数，叫做 <code>rand.ExpFloat64()</code>。实现的算法使用的是 Marsaglia 和 Tsang 在 2000 年发布的论文 <a href="https://www.jstatsoft.org/v05/i08/paper" target="_blank" rel="noopener noreffer">The Ziggurat Method for Generating Random Variables</a></p>
<h2 id="4-其它仿真器">4. 其它仿真器</h2>
<p><a href="http://akeranen.github.io/the-one/" target="_blank" rel="noopener noreffer">The One</a> 是一个 opportunistic Network Environment simulator，可以设置一个仿真的 IoT 网络，参数包括网络中设备数目、带宽、通信到达时间等，使用不同的模型生成随机的运动和通信，并将过程可视化。</p>]]></description></item><item><title>区块链实验8-实验流程优化及性能测试</title><link>https://shuzang.github.io/experimental-process-optimization-and-performance-test/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/experimental-process-optimization-and-performance-test/</guid><description><![CDATA[<p>我们对之前的实验流程做了进一步的优化，并且对添加恶意行为检测后的系统进行了进一步的性能测试。</p>
<h2 id="1-实验流程优化">1. 实验流程优化</h2>
<p>上一次实验我们搭建 Quorum 私链网络是采用从零开始的方式，从 genesis.json 文件开始，手动编辑配置文件、创建节点、最后组建网络，不仅耗费时间，而且一旦错误就要重新开始，浪费了大量无意义的精力。另外，我们还需要一个区块链浏览器可视化网络、区块、交易和合约的状态，与智能合约的交互也需要优化，虽然 Truffle 集成了合约的部署和测试工作，但依然存在一些不足，国内也无法使用 <code>truffle init</code> 命令。</p>
<p>针对以上问题，结合 Quorum 社区的最新进展，我们本次调整了实验方案所使用的工具和手段：</p>
<ol>
<li>使用 <a href="https://github.com/jpmorganchase/quorum-wizard" target="_blank" rel="noopener noreffer">Quorum Wizard</a> 命令行工具快速建立 Quorum 网络；</li>
<li>使用 <a href="https://github.com/jpmorganchase/cakeshop" target="_blank" rel="noopener noreffer">Cakeshop</a> 可视化区块链和智能合约状态；</li>
<li>使用 <a href="https://remix.ethereum.org/" target="_blank" rel="noopener noreffer">Remix</a>  + <a href="https://github.com/jpmorganchase/quorum-remix" target="_blank" rel="noopener noreffer">Quorum Plugin for Remix</a> 的组合部署合约及与合约交互；</li>
</ol>
<p>最后，我们对一些注意事项进行说明：</p>
<ol>
<li>Quourm Wizard 建立网络有 Bash 、 Docker-compse 和 kubernete 三种可选方式，我们使用第一种，但会尝试一下第二种；</li>
<li>之前在树莓派中建立区块链账户表示物联网网络和设备，但树莓派放在了实验室，由于疫情原因无法拿到手，因此本次建立一个 7 节点的私链网络，挑选一个节点代表物联网网关，然后建立一个新的账户表示设备，从而进行实验。</li>
</ol>
<p>最后，确定本次方案时还有一些备选方案，比如 <a href="https://github.com/blk-io/epirus-free" target="_blank" rel="noopener noreffer">Epirus-free</a> 也是一个可用的 Quorum 区块链浏览器，但结构比较简单，展示的参数也比较少，而且我们测试的时候迟迟无法加载出来数据，因此不选用。</p>
<p><a href="https://github.com/synechron-finlabs/quorum-maker" target="_blank" rel="noopener noreffer">quorum-maker</a> 是一个一体化方案，可以快速建立基于 Docker 的 Quorum 网络，并提供一个区块链浏览器查看区块链和合约状态，各方面的功能都足够晚上，唯一的问题是对 IBFT 共识的支持还处在开发阶段，暂时不可用，因此我们只能选择上述多个工具组合的方法完成本次实验。</p>
<h3 id="11-环境准备">1.1 环境准备</h3>
<p>Win10 Home Edition 不支持 Docker，且实验中涉及的组件比较多，我们决定使用虚拟机来启动一个 Linux 环境。另外，方案中的几个工具对依赖的要求如下：</p>
<ol>
<li>Quorum Wizard：
<ul>
<li>基于 Bash 建立网络：如果需要隐私管理器，需要 Java 环境</li>
<li>基于 Docker Compse：需要 Docker 和 docker-compose</li>
<li>基于 Kubernetes：需要 Docker、kubectl 和 minikube</li>
</ul>
</li>
<li>Cakeshop：需要 Java 8+ 及 Node.js</li>
<li>Geth 提供了接口供 Golang 使用来进行账户管理和合约监听，因为实验测试有可能用到，我们安装 Golang</li>
</ol>
<p>根据说明，我们开始准备实验环境</p>
<ol>
<li>
<p>安装 VMware Workstation 15 Pro，输入批量许可激活，建立 Ubuntu20.04 系统的虚拟机，分配内存 4G（有条件应为8G，这里是因为电脑配置比较低，一共只有8G，再多发生内存交换的概率比较大）、硬盘100GB。</p>
</li>
<li>
<p>进入 Ubuntu 20.04，更新系统，设置语言</p>
</li>
<li>
<p>安装git、golang、Java</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 安装git</span>
$ sudo apt install -y git
$ git version
git version 2.25.1
   
<span class="c1"># 安装golang</span>
$ sudo apt install -y golang
$ go version
go version go1.14.4 linux/amd64
   
<span class="c1"># 安装 JRE</span>
$ sudo apt install default-jre
$ java -version
openjdk version <span class="s2">&#34;11.0.7&#34;</span> 2020-04-14
OpenJDK Runtime Environment <span class="o">(</span>build 11.0.7+10-post-Ubuntu-3ubuntu1<span class="o">)</span>
OpenJDK 64-Bit Server VM <span class="o">(</span>build 11.0.7+10-post-Ubuntu-3ubuntu1, mixed mode, sharing<span class="o">)</span>
   
<span class="c1"># 安装JDK</span>
$ sudo apt install default-jdk
$ javac -version
javac 11.0.7
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>安装 Node 和 npm，由于直接安装后在使用 npm 全局安装包时会出现权限错误，因此使用 Node.js 版本管理工具 <a href="https://github.com/tj/n" target="_blank" rel="noopener noreffer">n</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt install curl
$ curl -L https://git.io/n-install <span class="p">|</span> bash
<span class="c1"># 重启终端</span>
$ n lts
   
  installing : node-v12.18.0
       mkdir : /home/shuzang/n/n/versions/node/12.18.0
       fetch : https://nodejs.org/dist/v12.18.0/node-v12.18.0-linux-x64.tar.xz
   installed : v12.18.0 <span class="o">(</span>with npm 6.14.4<span class="o">)</span>
   
<span class="c1"># 更新 npm 到最新，顺便测试全局安装</span>
$ npm install -g npm@latest
/home/shuzang/n/bin/npm -&gt; /home/shuzang/n/lib/node_modules/npm/bin/npm-cli.js
/home/shuzang/n/bin/npx -&gt; /home/shuzang/n/lib/node_modules/npm/bin/npx-cli.js
+ npm@6.14.5
updated <span class="m">5</span> packages in 16.718s
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>（可选）docker 和 docker-compose</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 安装 docker CE</span>
$ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh --mirror Aliyun
<span class="c1"># 启动 docker CE</span>
$ sudo systemctl <span class="nb">enable</span> docker
$ sudo systemctl start docker
<span class="c1"># 建立 docker 用户组并将当前用户加入 docker 组，这样就不需要 root 权限了</span>
$ sudo groupadd docker
$ sudo usermod -aG docker <span class="nv">$USER</span>
<span class="c1"># 测试安装</span>
$ docker run hello-world
<span class="c1"># 安装 docker-compose</span>
$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-<span class="sb">`</span>uname -s<span class="sb">`</span>-<span class="sb">`</span>uname -m<span class="sb">`</span> &gt; /usr/local/bin/docker-compose
$ sudo chmod +x /usr/local/bin/docker-compose
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h3 id="12-建立测试网络">1.2 建立测试网络</h3>
<p>全局安装 quorum-wizard</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ npm install -g quorum-wizard
</code></pre></td></tr></table>
</div>
</div><p>运行向导，建立测试网络，<code>-v</code> 参数用于输出日志记录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ quorum-wizard -v
...
Welcome to Quorum Wizard!

This tool allows you to easily create bash, docker, and kubernetes files to star
t up a quorum network.
You can control consensus, privacy, network details and more <span class="k">for</span> a customized se
tup.
Additionally you can choose to deploy our chain explorer, Cakeshop, to easily vi
ew and monitor your network.
? 
Welcome to Quorum Wizard!

This tool allows you to easily create bash, docker, and kubernetes files to star
t up a quorum network.
You can control consensus, privacy, network details and more <span class="k">for</span> a customized se
tup.
Additionally you can choose to deploy our chain explorer, Cakeshop, to easily vi
ew and monitor your network.
? 
Welcome to Quorum Wizard!

This tool allows you to easily create bash, docker, and kubernetes files to star
t up a quorum network.
You can control consensus, privacy, network details and more <span class="k">for</span> a customized se
tup.
Additionally you can choose to deploy our chain explorer, Cakeshop, to easily vi
ew and monitor your network.

We have <span class="m">3</span> options to <span class="nb">help</span> you start exploring Quorum:

  1.  Quickstart - our <span class="m">1</span> click option to create a <span class="m">3</span> node raft network with tesse
ra and cakeshop

  2.  Simple Network - using pregenerated keys from quorum 7nodes example,
      this option allows you to choose the number of nodes <span class="o">(</span><span class="m">7</span> max<span class="o">)</span>, consensus me
chanism, transaction manager, and the option to deploy cakeshop

  3.  Custom Network - In addition to the options available in <span class="c1">#2, this selectio</span>
n allows <span class="k">for</span> further customization of your network.
      Choose to generate keys, customize ports <span class="k">for</span> both bash and docker, or chan
ge the network id

Quorum Wizard will generate your startup files and everything required to bring 
up your network.
All you need to <span class="k">do</span> is go to the specified location and run ./start.sh

 Simple Network
? Would you like to generate bash scripts, a docker-compose file, or a kubernete
s config to bring up your network? bash
? Select your consensus mode - istanbul is a pbft inspired algorithm with transa
ction finality <span class="k">while</span> raft provides faster blocktimes, transaction finality and o
n-demand block creation istanbul
? Input the number of nodes <span class="o">(</span>2-7<span class="o">)</span> you would like in your network - a minimum of 
<span class="m">4</span> is recommended <span class="m">4</span>
? Which version of Quorum would you like to use? Quorum 2.6.0
? Choose a version of tessera <span class="k">if</span> you would like to use private transactions in y
our network, otherwise choose <span class="s2">&#34;none&#34;</span> Tessera 0.10.5
? Do you want to run Cakeshop <span class="o">(</span>our chain explorer<span class="o">)</span> with your network? Yes
? What would you like to call this network? 4-nodes-istanbul-tessera-bash
...
Building network directory...
Generating network resources locally...
Building qdata directory...
Writing start script...
Initializing quorum...
Done
--------------------------------------------------------------------------------

Tessera Node <span class="m">1</span> public key:
BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo<span class="o">=</span>

Tessera Node <span class="m">2</span> public key:
QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc<span class="o">=</span>

Tessera Node <span class="m">3</span> public key:
1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg<span class="o">=</span>

Tessera Node <span class="m">4</span> public key:
<span class="nv">oNspPPgszVUFw0qmGFfWwh1uxVUXgvBxleXORHj07g8</span><span class="o">=</span>

--------------------------------------------------------------------------------
Quorum network created

Run the following commands to start your network:

<span class="nb">cd</span> network/4-nodes-istanbul-bash
./start.sh

A sample simpleStorage contract is provided to deploy to your network
To use run ./runscript.sh public-contract.js from the network folder

A private simpleStorage contract was created with privateFor <span class="nb">set</span> to use Node 2<span class="err">&#39;</span>s public key: QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc<span class="o">=</span>
To use run ./runscript private-contract.js from the network folder
</code></pre></td></tr></table>
</div>
</div><p>在向导执行页面选择了运行 Cakeshop 的情况下，不需要自己再去安装 Cakeshop，可以直接启动。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> network/4-nodes-istanbul-bash
$ ./start.sh

Starting Quorum network...

Waiting <span class="k">until</span> all Tessera nodes are running...
...
All Tessera nodes started
Starting Quorum nodes
Starting Cakeshop
Waiting <span class="k">until</span> Cakeshop is running...
...
Cakeshop started at http://localhost:8999
Successfully started Quorum network.
</code></pre></td></tr></table>
</div>
</div><p>此时浏览器打开 http://localhost:8999 页面，可以看到网络情况</p>
<p></p>
<h3 id="13-remix-部署和交互说明">1.3 Remix 部署和交互说明</h3>
<p>浏览器打开  <a href="https://remix.ethereum.org/" target="_blank" rel="noopener noreffer">Remix IDE</a> （保证是 http 页面），点击左侧 Plugins（插件）标签页，搜索 <code>Quorum Network</code>，点击 <code>Activate</code> 激活插件。</p>
<p></p>
<p>在左侧标签栏寻找激活的插件，图标为 </p>
<p>我们上面运行的网络各节点的 url 分别为</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>url</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node1</td>
<td>Quorum RPC：http://localhost:22000<br>Tessera：http://localhost:9081</td>
</tr>
<tr>
<td>Node2</td>
<td>Quorum RPC：http://localhost:22001<br>Tessera：http://localhost:9082</td>
</tr>
<tr>
<td>Node3</td>
<td>Quorum RPC：http://localhost:22002<br/>Tessera：http://localhost:9083</td>
</tr>
<tr>
<td>Node4</td>
<td>Quorum RPC：http://localhost:22003<br/>Tessera：http://localhost:9084</td>
</tr>
</tbody>
</table>
<p>输入 Node1 的 Quroum RPC 和 Tessera 的 url，点击确认，得到如下的侧面板</p>
<p></p>
<p>从 Github 导入我们的合约</p>
<p></p>
<p>Quorum-Remix 插件使用 Remix 的 Solidity 编译器的结果，所以在 Remix 编译后的合约可以在Quorum插件的 <code>Compiled Contracts</code> 选项下找到，到时候输入参数点击部署即可，操作与 Remix 原本的 Deploy 选项卡完全一致。</p>
<p>最后，运行 <code>.stop.sh</code> 脚本可以停止所有的 quorum/geth 和 cakeshop 实例。</p>
<p>如果我们编写了交互用的 js 脚本，假设脚本名为 test.js，可以使用如下命令执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ./runscript.sh test.js
</code></pre></td></tr></table>
</div>
</div><p>有输入参数的情况下，可以使用 Bash 、Python 或 Go 有选择的批量执行脚本。</p>
<p>值得注意到是，我们上述没有使用隐私管理器，但这是 Quorum 的一个最重要的特性。</p>
<h3 id="14-错误排查记录">1.4 错误排查记录</h3>
<p><strong>2020.06.08</strong></p>
<p>Remix 无法显示所有插件，因此无法使用 Quorum Network 插件连接 Quorum 网络，经排查，为网络原因，连接手机开的热点后即可看到所有插件，深层原因未知。</p>
<p><strong>2020.06.09</strong></p>
<p>合约编译返回错误 <code>Uncaught JavaScript exception: RangeError: Maximum call stack size exceeded.</code></p>
<p>调用栈溢出，猜测可能是虚拟机内存分配不足，在宿主机中使用 Remix 通过局域网 IP 地址连接</p>
<p>宿主机浏览器无法访问 http 连接，换用 Firefox 或者使用 Remix-IDE 桌面版本都无法访问</p>
<p>考虑到此时 Remix 与 后台 Quorum 网络拆分，尝试使用 WSL 子系统，并使用 npm 安装 remix-ide</p>
<p>WSL 对 npm 支持不友好，普通用户和 root 用户权限全部被拒绝，所有包都无法安装</p>
<p>尝试在 win10 本地使用 npm 安装 remix，依赖过多，安装无法完成</p>
<p>重新尝试解决 win10 系统下无法访问 http 网页的错误，关闭防火墙不起作用，恢复 hosts 文件起作用，经确认，无法访问 http 网页是因为 hosts 文件被修改</p>
<p>重新尝试虚拟机的 Ubuntu 系统编译智能合约，Chrome 浏览器失败，Firefox 浏览器成功，确认不是因为内存分配不足。</p>
<h2 id="2-性能测试">2. 性能测试</h2>
<p>根据上篇最后一小节的分析，性能测试分为三部分：隐私合约及交易测试，访问控制系统测试和恶意行为检测部分的测试。</p>
<h3 id="21-隐私功能测试">2.1 隐私功能测试</h3>
<p>隐私合约及交易是 Quorum 自带的功能，本身不是我们实现的，因此测试只是验证该功能是否启用。合约的部署与交互使用了 Quorum for Remix 插件，该插件在 Remix 的插件列表中可以找到。测试用的合约如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.5.4</span><span class="p">;</span>
<span class="nx">contract</span> <span class="nx">SimpleStorage</span> <span class="p">{</span>

    <span class="nx">uint</span> <span class="nx">storedData</span><span class="p">;</span>

    <span class="nx">event</span> <span class="nx">Change</span><span class="p">(</span><span class="nx">string</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">uint</span> <span class="nx">newVal</span><span class="p">);</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">initVal</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">emit</span> <span class="nx">Change</span><span class="p">(</span><span class="s2">&#34;initialized&#34;</span><span class="p">,</span> <span class="nx">initVal</span><span class="p">);</span>
        <span class="nx">storedData</span> <span class="o">=</span> <span class="nx">initVal</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">set</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="nx">emit</span> <span class="nx">Change</span><span class="p">(</span><span class="s2">&#34;set&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
        <span class="nx">storedData</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">get</span><span class="p">()</span> <span class="nx">view</span> <span class="kr">public</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">uint</span> <span class="nx">retVal</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">storedData</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们令Node2 代表农场，Node3 代表超市，假设农场部署了一个私有存储合约，状态只能被超市查看。农场部署合约传入一个初始值 50，理论上，Node2 和 Node3 可以通过调用 get() 函数获取到该数据，其它的节点无法查看该数据。</p>
<p>因此我们分别进入 Node3（超市） 和 Node4 的 Geth console 进行验证，如下图所示，左侧是 Node3，可以查看合约状态并获取数据，右边是 Node4，无法查看合约状态，也无法获得数据。</p>
<p></p>
<p>从 Cakeshop 区块链浏览器可以更清楚地看到两种情况</p>
<p></p>
<p></p>
<h3 id="22-访问控制时间测试">2.2 访问控制时间测试</h3>
<p>主要测试参数为完成一次访问控制的时间，期间我们要确认信誉系统的加入是否对访问控制时间有影响，以及不同的访问控制方案是否对时间有影响。</p>
<h4 id="221-测试准备">2.2.1 测试准备</h4>
<p>第一部分隐私功能测试时使用了 Quorum for Remix 插件，由于该插件在 Remix 中无法返回执行结果，在非隐私交易时不具备优势，因此访问控制系统时间测量的预准备工作，包括合约部署和交互，使用了 Remix 自己提供的 Deploy and Run 插件，主要利用 Web3 Provider 来连接 Quorum 网络进行操作。连接端口在 geth 启动时已默认打开，我们使用的三个节点对应的 Web3 端口如下</p>
<ul>
<li>Node1：22000</li>
<li>Node2：22001</li>
<li>Node3：22002</li>
</ul>
<p>另外，我们单独安装 Web3.js 并编写 JS 代码来进行访问控制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 在用户根目录建立web3文件夹</span>
$ mdkir web3
$ <span class="nb">cd</span> web3
<span class="c1"># 在web3文件夹中本地安装 web3 1.2.8 版本，之前的版本有些依赖不再维护，安装会出错</span>
$ npm install web3@1.2.8
</code></pre></td></tr></table>
</div>
</div><p>为了获取足够样本进行分析，我们要进行大量的访问控制测试并获取每次的访问控制时间，先后使用的方案有三种，我们会阐述前两种方案不可行的原因</p>
<ol>
<li>
<p>在 JS 脚本中设立循环，使用 setInterval() 函数延时固定的时间发起访问控制，得到的结果中，初次访问控制的时间为 10ms 左右，其后迅速减少，在 1ms 和 2ms 左右浮动。查询后发现，Javascript 中 setInterval 函数的实质是每隔一段时间向任务队列中添加回调函数，开始执行的时间是不确定的，最后导致了时间统计的不确定性。</p>
</li>
<li>
<p>使用 Shell 脚本编写循环，在循环中调用 JS 代码，然后使用 sleep 函数设置延时，访问时间的获取是通过 Javascript Date 对象的 getTime 方法，在发起访问控制前获取了一次时间，在获得结果后获取了第二次时间，然后求其差值。最后得到的结果发现，访问控制时间受发起访问的时机影响，呈周期性波动，也受 CPU 占用率的影响，占用率越高时间越短，显然这一结果是不合理的。关于这一次尝试的结果，可以查看第 2.5 节。</p>
</li>
<li>
<p>使用 Linux time 命令获取执行时间，我们猜测周期性的出现是系统中其它进程的影响，为了排除它们的影响，我们使用了 Linux 的 time 命令。当测试一个程序或比较不同算法时，执行时间是非常重要的，一个好的算法应该是用时最短的。所有类UNIX系统都包含time命令，使用这个命令可以统计时间消耗。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># time ls</span>
anaconda-ks.cfg  install.log  install.log.syslog  satools  text
   
real    0m0.009s
user    0m0.002s
sys     0m0.007s
</code></pre></td></tr></table>
</div>
</div><p>输出的信息分别显示了该命令所花费的real时间、user时间和sys时间。</p>
<ul>
<li>real时间是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。</li>
<li>user时间是指进程花费在用户模式中的CPU时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。</li>
<li>sys时间是指花费在内核模式中的CPU时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。</li>
</ul>
<p>shell内建也有一个time命令，当运行time时候是调用的系统内建命令，应为系统内建的功能有限，所以需要时间其他功能需要使用time命令可执行二进制文件<code>/usr/bin/time</code>。所以我们使用 <code>/usr/bin/time</code> 获取执行访问控制的时间，然后计算 user 和 sys 的和，得到的结果就是访问控制实际执行所花费的 CPU时间。</p>
</li>
</ol>
<p>参考：<a href="https://man.linuxde.net/time" target="_blank" rel="noopener noreffer">Linux time命令</a></p>
<p>我们首先建立 <code>xtime</code> 文件(无后缀)，将如下内容写入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="cp">#!/bin/sh
</span><span class="cp"></span>/usr/bin/time -f <span class="s1">&#39;%Uu %Ss %er %P&#39;</span> <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>-f</code> 参数用于指定输出格式，<code>-f</code> 后面的几个参数说明如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%e</td>
<td style="text-align:left">real时间</td>
</tr>
<tr>
<td style="text-align:left">%U</td>
<td style="text-align:left">user时间</td>
</tr>
<tr>
<td style="text-align:left">%S</td>
<td style="text-align:left">sys时间</td>
</tr>
<tr>
<td style="text-align:left">%P</td>
<td style="text-align:left">进程所获取的CPU时间百分百，这个值等于user+system时间除以总共的运行时间。</td>
</tr>
</tbody>
</table>
<p>然后建立 shell 脚本，命名为 runscript.sh，内容为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="cp">#!/bin/bash
</span><span class="cp"></span>
<span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>1<span class="p">;</span>i&lt;<span class="o">=</span>500<span class="p">;</span>i++<span class="o">))</span><span class="p">;</span>  <span class="k">do</span>   
  ./xtime node requester_legal.js
  sleep <span class="m">5</span>
<span class="k">done</span> 
</code></pre></td></tr></table>
</div>
</div><p>其中，requester_legal.js 是完成访问控制的 JS 文件，接下来授予 xtime 和 runscript.sh 执行权限</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ chmod <span class="m">777</span> xtime
$ chmod <span class="m">777</span> runscript.sh
</code></pre></td></tr></table>
</div>
</div><p>执行 Shell 脚本之前，我们需要先解锁发起访问的账户，由于我们会一次性进行 500 次测试，每次间隔 5 s，因此一次性将账户解锁 2500s 以上，这里我们设置 4000s。解锁相应账户的命令如下，第二个参数为密码，第三个参数为时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="o">&gt;</span> <span class="nx">personal</span><span class="p">.</span><span class="nx">unlockAccount</span><span class="p">(</span><span class="nx">eth</span><span class="p">.</span><span class="nx">accounts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">4000</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="nx">personal</span><span class="p">.</span><span class="nx">unlockAccount</span><span class="p">(</span><span class="nx">eth</span><span class="p">.</span><span class="nx">accounts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">4000</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>执行 runscript.sh 脚本即可开始测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ./runscript
0.55 0.08 5.02 12%
0.54 0.07 4.96 12%
0.54 0.11 5.00 13%
0.55 0.09 5.02 12%
...
</code></pre></td></tr></table>
</div>
</div><p>所有的时间会输出到终端，如上面的格式，第一列是用户态运行时间，第二列是内核态运行时间，第三列是实际运行时间，最后一列是进程所获取的CPU时间比例。</p>
<p>注1：设备发起访问控制时，应当首先获取目标设备绑定的访问控制合约地址，该地址可以根据设备账户在管理合约中查询得到，但这里我们为了测试方便，选择预定义，而不是每次去查询。</p>
<p>注2：所有的代码文件都放在 github 仓库中。</p>
<h4 id="222-无信誉系统">2.2.2 无信誉系统</h4>
<p>完整的方案中包含 MC（管理合约）、ACC（访问控制合约）和RC（信誉合约），现在，我们将 RC 从系统中移除，并删除 MC 和 ACC 中所有相关的调用。</p>
<p>JS 文件基本逻辑如下，可以看到，前面都是变量定义的过程，执行主体是访问控制函数，当获取到 receipt 时退出（返回的事件位于 receipt 中，可以输出确认一下，正式测试时为了输出结果的格式可以只用 receipt.status判断即可）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">Web3</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;web3&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">web3</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Web3</span><span class="p">(</span><span class="nx">Web3</span><span class="p">.</span><span class="nx">givenProvider</span> <span class="o">||</span> <span class="s2">&#34;ws://localhost:23000&#34;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">accAbi</span> <span class="o">=</span> <span class="s2">&#34;这里是合约ABI&#34;</span>
<span class="kd">var</span> <span class="nx">accAddr</span> <span class="o">=</span> <span class="s2">&#34;这里是合约地址&#34;</span>

<span class="kd">var</span> <span class="nx">myACC</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">Contract</span><span class="p">(</span><span class="nx">accAbi</span><span class="p">,</span> <span class="nx">accAddr</span><span class="p">);</span>

<span class="nx">myACC</span><span class="p">.</span><span class="nx">methods</span><span class="p">.</span><span class="nx">accessControl</span><span class="p">(</span><span class="s2">&#34;这里是传入的参数列表&#34;</span><span class="p">).</span><span class="nx">send</span><span class="p">({</span>
	<span class="nx">from</span><span class="o">:</span> <span class="s2">&#34;这里是发起访问的账户地址&#34;</span><span class="p">,</span>
	<span class="nx">gas</span><span class="o">:</span> <span class="mi">10000000</span><span class="p">,</span>
	<span class="nx">gasPrice</span><span class="o">:</span> <span class="mi">0</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">receipt</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">receipt</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
	    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">receipt</span><span class="p">)</span>
        <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>        
	<span class="p">}</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>合约部署时得到的结果如下</p>
<table>
<thead>
<tr>
<th>合约</th>
<th>Gas 消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>MC</td>
<td>1958457</td>
</tr>
<tr>
<td>ACC</td>
<td>4128313</td>
</tr>
</tbody>
</table>
<p>合约部署完毕后定义属性和策略，最后根据具体情况修改 JS 和 Shell 脚本，500 次访问时间的平均值为  0.62682s，最大值为 0.99s，最小值为 0.57s。</p>
<h4 id="223-恶意行为检测加入">2.2.3 恶意行为检测加入</h4>
<p>加入信誉合约 RC 后进行测试，部署合约、注册设备、定义属性和策略。三种合约部署的 Gas 消耗分别为</p>
<table>
<thead>
<tr>
<th>合约</th>
<th>Gas 消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>MC</td>
<td>2512367</td>
</tr>
<tr>
<td>ACC</td>
<td>4749983</td>
</tr>
<tr>
<td>RC</td>
<td>1170616</td>
</tr>
</tbody>
</table>
<p>注意，我们在访问控制合约初始化时设定了两次访问控制请求间隔应不少于 100s，否则会触发 Too frequent request 错误。这个设定会极大的延长我们测试的总时间，所以我们把这个时间间隔重新设定为 4s，这样 shell 脚本中的 sleep 5 就不会触发错误。</p>
<p>测试前解锁相应的账户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="o">&gt;</span> <span class="nx">personal</span><span class="p">.</span><span class="nx">unlockAccount</span><span class="p">(</span><span class="nx">eth</span><span class="p">.</span><span class="nx">accounts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">3600</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="nx">personal</span><span class="p">.</span><span class="nx">unlockAccount</span><span class="p">(</span><span class="nx">eth</span><span class="p">.</span><span class="nx">accounts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">3600</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>500 次测试结果的平均值为 0.66736s，最大值为 2.71s，最小值为 0.55s。</p>
<h4 id="224-wang的方案">2.2.4 wang的方案</h4>
<p>在下面的论文中，wang 等利用智能合约对传统 ABAC 架构进行了实现，我们认为对比该方案和我们的方案具有较大的意义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">P. Wang, Y. Yue, W. Sun, and J. Liu, 
“An Attribute-Based Distributed Access Control for Blockchain-enabled IoT,” 
in 2019 WiMob, Barcelona, Spain, Oct. 2019, pp. 1–6, doi: 10.1109/WiMOB.2019.8923232 .
</code></pre></td></tr></table>
</div>
</div><p>鉴于作者没有提供源码，我们按照论文的描述进行了复现，然后在我们当前的实验平台下测试其访问控制时间，500 次测试的平均值为 0.69348s，最大值为 1.96s，最小值为 0.6s。</p>
<p>我们对三种情况的时间总结如下表</p>
<table>
<thead>
<tr>
<th>单位/ms</th>
<th>无信誉系统</th>
<th>加入信誉系统</th>
<th>wang的方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>平均值</td>
<td>626.82</td>
<td>667.36</td>
<td>693.48</td>
</tr>
<tr>
<td>最大</td>
<td>990</td>
<td>2710</td>
<td>1960</td>
</tr>
<tr>
<td>最小</td>
<td>570</td>
<td>550</td>
<td>600</td>
</tr>
</tbody>
</table>
<p>可以看到，信誉系统的加入使得访问控制的平均时间增加了约6%，主要是因为执行访问控制时需要和信誉合约进行交互。而 wang 的方案相比于加入信誉系统的方案平均时间增加了约 4%，相对于没有信誉系统的方案增加了约 11%。</p>
<p>三种方案的主要区别在于合约逻辑的不同，包括循环的执行、合约间的相互调用次数，尤其是 wang 的方案合约间相互调用比较多，所以平均时间要更多。</p>
<h4 id="225-意外">2.2.5 意外</h4>
<p>我们在使用 JavaScript Date对象测试时发现一个意外情况，访问时间会受发起访问的时机的影响，假设 t 为两次访问的间隔，那么区别如下</p>
<table>
<thead>
<tr>
<th></th>
<th>t % 5 == 0</th>
<th>t % 5 == 1</th>
<th>t % 5 == 2</th>
<th>t % 5 == 3</th>
<th>t % 5 == 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>结果趋向</td>
<td>4500ms</td>
<td>3500ms</td>
<td>2500ms</td>
<td>6500ms</td>
<td>5500ms</td>
</tr>
</tbody>
</table>
<p>三种方案都会出现如上结果，事实上，访问时间不仅收发起访问控制的时机影响，为了排除后台进程占用对时机的影响，我们特地利用程序分别使 CPU 占用保持在 50%，80%和100%重新进行了测试，不同的CPU占用率下，访问时间也不同，具体如下</p>
<table>
<thead>
<tr>
<th></th>
<th>t % 5 == 0</th>
<th>t % 5 == 1</th>
<th>t % 5 == 2</th>
<th>t % 5 == 3</th>
<th>t % 5 == 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU占用20%</td>
<td>4500ms</td>
<td>3500ms</td>
<td>2500ms</td>
<td>6500ms</td>
<td>5500ms</td>
</tr>
<tr>
<td>CPU占用50%</td>
<td>4300ms</td>
<td>3300ms</td>
<td>2300ms</td>
<td>6300ms</td>
<td>5300ms</td>
</tr>
<tr>
<td>CPU占用80%</td>
<td>4100ms</td>
<td>3100ms</td>
<td>2100ms</td>
<td>6100ms</td>
<td>5100ms</td>
</tr>
<tr>
<td>CPU占用100%</td>
<td>3950ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>最后，我们特定将 CPU 限制在了单核单线程，得到的结果没有区别。</p>
<ol>
<li>对合约的调用操作，分为不改变合约的状态和会改变合约的状态两种情况，这两种情况调用产生的时间消耗不同；</li>
<li>访问时间属于更改合约状态这种情况，此时，访问时间不因程序逻辑的变化而变化，意思是循环数量、合约间相互调用的数量，都不会对访问消耗时间产生影响；</li>
<li>访问通过和被拒绝属于合约逻辑问题，同样不对访问时间产生影响；</li>
<li>访问时间受网络情况影响，包括发起访问的时机和后台CPU的占用率；</li>
</ol>
<h4 id="226-其它">2.2.6 其它</h4>
<p>最后我们看一下更改合约状态的函数和不更改合约状态的函数执行时间是否有差别。我们写了两个关于存储的合约进行测试，合约内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">pragma solidity &gt;=0.4.22 &lt;0.7.0;

/**
 * @title Storage
 * @dev Store &amp; retreive value in a variable
 */
contract Storage {
    Helper public h;
    uint256 num;
    
    constructor(address _h) public {
        h = Helper(_h);
    }
    
    function store(uint256 _num) public {
        num = _num;
    }
    
    function get() public view returns (uint256){
        return num;
    }
    
    function retreive() public view returns (uint256){
        uint number;
        for (uint i = 0; i &lt; 500; i++) {
            uint t = h.getNumber();
            number = number + t;
        }
        return number;
    }
}

contract Helper {
    function getNumber() public pure returns (uint256);
}
</code></pre></td></tr></table>
</div>
</div><p>调用的 Helper 合约具体内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">pragma solidity &gt;=0.4.22 &lt;0.7.0;

contract Helper {
    function getNumber() public pure returns (uint256){
        return 23;
    }
}
</code></pre></td></tr></table>
</div>
</div><p>我们调用 Storage 合约中的 store 函数查看对合约状态进行更改时的时间消耗，调用 get 函数查看不更改合约状态时的时间消耗，调用 retreive 函数查看多次调用其它合约时对时间的影响。得到的结果如下</p>
<h2 id="3-恶意行为检测测试">3. 恶意行为检测测试</h2>
<p>如上篇所述，信誉系统的测试需要发起持续不断的合约调用，具体来说，就是在随机的时间调用随机的合约函数，从而验证奖励、惩罚、容忍、报警四大功能。</p>
<p>随机的时间间隔使用泊松分布生成，具体方法在 <a href="https://shuzang.github.io/generate-random-timings-for-a-poisson-process/" target="_blank" rel="noopener noreffer">另一篇文章</a> 中介绍。在生成的随机时间点具体执行哪个合约调用，我们进行了如下考虑</p>
<p>首先，会影响信誉值的行为包括</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>所属合约及函数</th>
<th>合法/恶意</th>
<th>事件编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>Attribute add</td>
<td>MC:addAttribute</td>
<td>合法</td>
<td>1</td>
</tr>
<tr>
<td>Device manager update</td>
<td>MC:updateManager</td>
<td>合法</td>
<td>2</td>
</tr>
<tr>
<td>Device customed attribute update</td>
<td>MC:updateAttribute</td>
<td>合法</td>
<td>2</td>
</tr>
<tr>
<td>Device delete</td>
<td>MC:deleteDevice</td>
<td>合法</td>
<td>3</td>
</tr>
<tr>
<td>Attribute delete</td>
<td>MC:deleteAttribute</td>
<td>合法</td>
<td>3</td>
</tr>
<tr>
<td>Resource attribute add</td>
<td>addResourceAttr</td>
<td>合法</td>
<td>1</td>
</tr>
<tr>
<td>Policy add</td>
<td>ACC:addpolicy</td>
<td>合法</td>
<td>1</td>
</tr>
<tr>
<td>Device manager update</td>
<td>ACC:updateManager</td>
<td>合法</td>
<td>2</td>
</tr>
<tr>
<td>Resource attribute update</td>
<td>ACC:updateResourceAttr</td>
<td>合法</td>
<td>2</td>
</tr>
<tr>
<td>Resource attribute delete</td>
<td>ACC:deleteResourceAttr</td>
<td>合法</td>
<td>3</td>
</tr>
<tr>
<td>Policy delete</td>
<td>ACC:deletePolicy</td>
<td>合法</td>
<td>3</td>
</tr>
<tr>
<td>Policy item delete</td>
<td>ACC:deletePolicyItem</td>
<td>合法</td>
<td>3</td>
</tr>
<tr>
<td>Access authorized</td>
<td>ACC:accessControl</td>
<td>合法</td>
<td>4</td>
</tr>
<tr>
<td>Blocked end time not reached</td>
<td>ACC:accessControl</td>
<td>恶意</td>
<td>0</td>
</tr>
<tr>
<td>Policy check failed</td>
<td>ACC:accessControl</td>
<td>恶意</td>
<td>0</td>
</tr>
<tr>
<td>Too frequent access</td>
<td>ACC:accessControl</td>
<td>恶意</td>
<td>1</td>
</tr>
<tr>
<td>Both above two</td>
<td>ACC:accessControl</td>
<td>恶意</td>
<td>1</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>以上影响信誉值的行为间是有先后关系的，比如，update、delete 都必须在 add 之后完成，access control 发起的条件是相关的属性和策略已定义等。如果我们完全随机的产生事件，很可能某些行为无法执行。</p>
<p>解决办法：忽略行为间的先后关系，因为如果存在显式的先后关系，一定会被我们定义的 require 机制给阻止，不会导致系统出错。</p>
</li>
<li>
<p>当确定了具体的行为，调用时如何传入参数。因为属性和策略的增删改一定会影响访问控制的结果，这样的话，访问成功还是失败完全不受我们控制。</p>
<p>解决办法：去除会影响结果的行为，因为同一类行为对信誉值的影响是相同的，所以每种行为我们只需要保留一个就可以。比如，合法行为中，Attribute add、Resource attribute add、Policy add 三者等价，我们只保留 Attribute add 一个行为，产生的所有 add 类行为都转换为对 addAttribute 一个函数的调用。最后我们保留下来的行为包括</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>所属合约及函数</th>
<th>合法/恶意</th>
<th>事件编号</th>
</tr>
</thead>
<tbody>
<tr>
<td>Attribute add</td>
<td>MC:addAttribute</td>
<td>合法</td>
<td>1</td>
</tr>
<tr>
<td>Device customed attribute update</td>
<td>MC:updateAttribute</td>
<td>合法</td>
<td>2</td>
</tr>
<tr>
<td>Attribute delete</td>
<td>MC:deleteAttribute</td>
<td>合法</td>
<td>3</td>
</tr>
<tr>
<td>Access authorized</td>
<td>ACC:accessControl</td>
<td>合法</td>
<td>4</td>
</tr>
<tr>
<td>Policy check failed</td>
<td>ACC:accessControl</td>
<td>恶意</td>
<td>0</td>
</tr>
<tr>
<td>Too frequent access</td>
<td>ACC:accessControl</td>
<td>恶意</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>为了排除仅剩的这些行为间的相互影响，我们规定，access control 将依赖于已定义好的属性和策略，新添加/更改/删除属性不会对访问结果产生影响。</p>
</li>
<li>
<p>每一种行为出现的概率可能是不一致的。比如，update 出现的次数可能多一点，add 和 delete 会少一点，access control 发起的频率可能是最高的。但是，在这里，6种不同的行为我们都以同样的概率来考虑，我们用 0-5 一共 6 个整数表示 6 种不同的事件，然后随机生成这个范围内的一个整数，从而确定某一时刻要调用的函数。</p>
</li>
</ol>
<p>使用一个文本文件存放输入参数，第一列是随机时间，第二列是随机事件，利用 Bash 读取每一行，然后在具体的时间调用指定的 JS 脚本完成这一过程。记录的结果包括从信誉合约检测到的各种值。</p>]]></description></item><item><title>函数修饰词pure和view</title><link>https://shuzang.github.io/pure-and-view-keyword/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/pure-and-view-keyword/</guid><description><![CDATA[<p>转自<a href="https://learnblockchain.cn/docs/solidity/contracts.html#view" target="_blank" rel="noopener noreffer">深入理解Solidity-函数</a></p>
<p>这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。</p>
<h2 id="1-view-视图函数">1. view 视图函数</h2>
<p>Getter 方法会被自动标记为 <code>view</code>，除此之外，一个 view 修饰的例子如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span>  <span class="o">&gt;=</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">42</span><span class="p">)</span> <span class="o">+</span> <span class="nb">now</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>view 保证函数不修改状态，以下操作会被认为是修改状态</p>
<ol>
<li>修改状态变量。</li>
<li>产生事件。</li>
<li>创建其它合约。</li>
<li>使用 <code>selfdestruct</code>。</li>
<li>通过调用发送以太币。</li>
<li>调用任何没有标记为 <code>view</code> 或者 <code>pure</code> 的函数。</li>
<li>使用低级调用。</li>
<li>使用包含特定操作码的内联汇编。</li>
</ol>
<h2 id="2-pure-纯函数">2. pure 纯函数</h2>
<p>pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态</p>
<ol>
<li>读取状态变量。</li>
<li>访问 <code>address(this).balance</code> 或者 <code>.balance</code>。</li>
<li>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li>
<li>调用任何未标记为 <code>pure</code> 的函数。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ol>
<p>一个 pure 修饰的例子如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="kr">public</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>可见性与Getter函数</title><link>https://shuzang.github.io/visibility-and-getter-function/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/visibility-and-getter-function/</guid><description><![CDATA[<p>转自：<a href="https://learnblockchain.cn/docs/solidity/contracts.html#getter" target="_blank" rel="noopener noreffer">Solidity 0.6.4 中文文档</a></p>
<p>Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。</p>
<h2 id="1-可见性">1. 可见性</h2>
<p>因此，函数和状态变量有四种可见性。函数可以指定为 <code>external</code>，<code>public</code>，<code>internal</code> 或 <code>private</code>，对于状态变量， 默认是 <code>internal</code> 且不能设置为 <code>external</code>。</p>
<ul>
<li><code>external</code>：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用（即 <code>f</code> 不起作用，但 <code>this.f()</code>可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.</li>
<li><code>public</code>：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。</li>
<li><code>internal</code>：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 <code>this</code> 调用。</li>
<li><code>private</code>：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</li>
</ul>
<blockquote>
<p>合约中的所有内容对外部观察者都是可见的。设置一些 <code>private</code> 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</p>
</blockquote>
<p>可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span>  <span class="o">&gt;=</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">16</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">private</span> <span class="kr">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">setData</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">internal</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint</span> <span class="kr">public</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在下面的例子中，<code>D</code> 可以调用 <code>c.getData（）</code> 来获取状态存储中 <code>data</code> 的值，但不能调用 <code>f</code> 。 合约 <code>E</code> 继承自 <code>C</code> ，因此可以调用 <code>compute</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">private</span> <span class="n">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">private</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">setData</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">)</span> <span class="kr">public</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">getData</span><span class="p">()</span> <span class="kr">public</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="n">compute</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="kr">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 下面代码编译错误
</span><span class="c1"></span><span class="kd">contract</span> <span class="n">D</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">readData</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span>
        <span class="kt">uint</span> <span class="n">local</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// 错误：成员 `f` 不可见
</span><span class="c1"></span>        <span class="n">c</span><span class="p">.</span><span class="n">setData</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">local</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">getData</span><span class="p">();</span>
        <span class="n">local</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// 错误：成员 `compute` 不可见
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">E</span> <span class="kr">is</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">g</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span>
        <span class="kt">uint</span> <span class="n">val</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// 访问内部成员（从继承合约访问父合约成员）
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-getter-函数">2. Getter 函数</h2>
<p>编译器自动为所有 <strong>public</strong> 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 <code>data</code> 的函数， 该函数没有参数，返回值是一个 <code>uint</code> 类型，即状态变量 <code>data</code> 的值。 状态变量的初始化可以在声明时完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span>  <span class="o">&gt;=</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">public</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Caller</span> <span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="p">();</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">local</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 <code>this.</code> ），它被认为一个状态变量。 如果使用外部访问（即用 <code>this.</code> ），它被认作为一个函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">public</span> <span class="n">data</span><span class="p">;</span>
    <span class="kd">function</span> <span class="n">x</span><span class="p">()</span> <span class="kr">public</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 内部访问
</span><span class="c1"></span>        <span class="kt">uint</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">this</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="c1">// 外部访问
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你有一个数组类型的 <code>public</code> 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 <code>data(0)</code> 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">arrayExample</span> <span class="p">{</span>
  <span class="c1">// public state variable
</span><span class="c1"></span>  <span class="kt">uint</span><span class="p">[]</span> <span class="kr">public</span> <span class="n">myArray</span><span class="p">;</span>

  <span class="c1">// 指定生成的Getter 函数
</span><span class="c1"></span>  <span class="cm">/*
</span><span class="cm">  function myArray(uint i) public view returns (uint) {
</span><span class="cm">      return myArray[i];
</span><span class="cm">  }
</span><span class="cm">  */</span>

  <span class="c1">// 返回整个数组
</span><span class="c1"></span>  <span class="kd">function</span> <span class="n">getArray</span><span class="p">()</span> <span class="kr">public</span> <span class="kr">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="kr">memory</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">myArray</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在可以使用 <code>getArray()</code> 获得整个数组，而 <code>myArray(i)</code> 是返回单个元素。</p>
<p>下一个例子稍微复杂一些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kr">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Complex</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="n">Data</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">a</span><span class="p">;</span>
        <span class="kt">bytes3</span> <span class="n">b</span><span class="p">;</span>
        <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="n">map</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kd">mapping</span><span class="p">(</span><span class="kt">bool</span> <span class="o">=&gt;</span> <span class="n">Data</span><span class="p">[]))</span> <span class="kr">public</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这将会生成以下形式的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="kd">function</span> <span class="n">data</span><span class="p">(</span><span class="kt">uint</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">arg3</span><span class="p">)</span> <span class="kr">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bytes3</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">arg1</span><span class="p">][</span><span class="n">arg2</span><span class="p">][</span><span class="n">arg3</span><span class="p">].</span><span class="n">a</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">arg1</span><span class="p">][</span><span class="n">arg2</span><span class="p">][</span><span class="n">arg3</span><span class="p">].</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。</p>
]]></description></item><item><title>字符串匹配</title><link>https://shuzang.github.io/string-equality-comparison/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/string-equality-comparison/</guid><description><![CDATA[<p>翻译自：<a href="https://fravoll.github.io/solidity-patterns/string_equality_comparison.html" target="_blank" rel="noopener noreffer">Fravoll-String Equality Comparison</a></p>
<p>比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。</p>
<h2 id="1-两种种比较方法">1. 两种种比较方法</h2>
<p>下面介绍社区中提出过的比较方法</p>
<h3 id="11-stringutils-库">1.1 StringUtils 库</h3>
<p>第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。</p>
<h3 id="12-哈希函数">1.2 哈希函数</h3>
<p>作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下</p>
<ol>
<li>检查两个字符串是否有相同长度，通过转换为 <code>bytes</code> 类型完成，因为 <code>bytes</code> 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果；</li>
<li>使用 <code>keccak256()</code> 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。</li>
</ol>
<p>一个示例代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-solidity" data-lang="solidity"><span class="err">#</span> <span class="err">这段代码未经安全审计，使用有风险</span>
<span class="kd">function</span> <span class="n">hashCompareWithLengthCheck</span><span class="p">(</span><span class="kt">string</span> <span class="n">a</span><span class="p">,</span> <span class="kt">string</span> <span class="n">b</span><span class="p">)</span> <span class="kr">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="kt">bytes</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">length</span> <span class="o">!=</span> <span class="kt">bytes</span><span class="p">(</span><span class="n">b</span><span class="p">).</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacket</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">==</span> <span class="nf">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacket</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>abi.encodePacket(...) returns (bytes)</code> 用于对给定参数执行<a href="https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode" target="_blank" rel="noopener noreffer">紧打包编码</a>，官方文档中不推荐使用 <code>keccak256(...)</code> 直接计算哈希，而是使用 <code>keccak256(abi.encodePacked(...))</code></p>
<h2 id="2-gas-消耗分析">2. Gas 消耗分析</h2>
<p>在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗</p>
<ol>
<li>比较哈希</li>
<li>比较每个字符，同时比较字符串长度</li>
<li>比较哈希，同时比较字符串长度</li>
</ol>
<p>结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei</p>
<table>
<thead>
<tr>
<th style="text-align:left">Input A</th>
<th style="text-align:left">Input B</th>
<th style="text-align:right">Hash</th>
<th style="text-align:right">Character + Length</th>
<th style="text-align:right">Hash + Length</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:left">abcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">7062</td>
<td style="text-align:right">1261</td>
</tr>
<tr>
<td style="text-align:left">abcdefghijklmnopqrstuvwxy<strong>X</strong></td>
<td style="text-align:left">abcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">7012</td>
<td style="text-align:right">1261</td>
</tr>
<tr>
<td style="text-align:left"><strong>X</strong>bcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:left">abcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">912</td>
<td style="text-align:right">1261</td>
</tr>
<tr>
<td style="text-align:left">a<strong>X</strong>cdefghijklmnopqrstuvwxyz</td>
<td style="text-align:left">abcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">1156</td>
<td style="text-align:right">1261</td>
</tr>
<tr>
<td style="text-align:left">ab<strong>X</strong>defghijklmnopqrstuvwxyz</td>
<td style="text-align:left">abcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">1400</td>
<td style="text-align:right">1261</td>
</tr>
<tr>
<td style="text-align:left">abcdefghijkl</td>
<td style="text-align:left">abcdefghijklmnopqrstuvwxyz</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">690</td>
<td style="text-align:right">707</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">a</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">962</td>
<td style="text-align:right">1261</td>
</tr>
<tr>
<td style="text-align:left">ab</td>
<td style="text-align:left">ab</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">1156</td>
<td style="text-align:right">1261</td>
</tr>
<tr>
<td style="text-align:left">abc</td>
<td style="text-align:left">abc</td>
<td style="text-align:right">1225</td>
<td style="text-align:right">1450</td>
<td style="text-align:right">1261</td>
</tr>
</tbody>
</table>
<p>可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。</p>
]]></description></item><item><title>区块链实验7-恶意行为检测机制设计</title><link>https://shuzang.github.io/credit-based-mechanism/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/credit-based-mechanism/</guid><description><![CDATA[<p>吸收了一些新论文的想法，对原访问控制系统功能做了补充，添加了恶意行为检测（或者称为动态访问控制），目的是减少恶意行为，增加合法行为在区块链中得到确认的几率。所有调整总结查看 <a href="#jump" rel="">附录II</a>。</p>
<h2 id="1-背景">1. 背景</h2>
<p>Blockchain, IoT, Access Control 是核心的三个关键词。该领域的研究中，大部分论文介绍背景从 IoT+Access Control 起步，介绍区块链能带来的好处，少部分从 Blockchain+IoT 起步，介绍访问控制对场景的必要性，事实上，我们研一开始的研究路径就是这样，先考虑 Blockchain 用于 IoT 有哪些好处，然后才选择了 Acccess Control 子方向。</p>
<p>前者可以参考之前写好的论文，或者该博客的另外一篇文章 <a href="https://shuzang.github.io/blockchain-based-access-control-for-iot/" target="_blank" rel="noopener noreffer">区块链用于物联网访问控制</a>；后者可以参考 <a href="https://www.ibm.com/cn-zh/blockchain/solutions/food-trust" target="_blank" rel="noopener noreffer">IBM Food Trust</a> 项目的介绍，或者查看本系列上一篇文章 <a href="https://shuzang.github.io/analysis-and-selection-of-experimental-scenes" target="_blank" rel="noopener noreffer">实验场景的分析与选择</a> 的第三部分。</p>
<p>无论从哪一个角度，亦或者从更直观的现象看（该方向论文超过 200 篇），都能得出一个结论：这三者的结合是必要的，至少是益处更多的。</p>
<h3 id="11-结合方式">1.1 结合方式</h3>
<p>我们之前遵循的分类是史锦山等在一篇综述<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>中提出的，该论文将这三种的结合分为两类：</p>
<ol>
<li>区块链与已有的物联网访问控制模型结合，区块链充当可信实体；</li>
<li>新的完全基于区块链的物联网访问控制模型，该分类又包括两种
<ul>
<li>基于区块链交易或脚本机制实现的访问控制</li>
<li>基于智能合约实现的访问控制</li>
</ul>
</li>
</ol>
<p>然而我们在研究中逐渐意识到，第二种并不能作为一个单独的分类。基于区块链交易或脚本实现的访问控制本质是基于 token 在区块链中的实现，基于智能合约实现的访问控制，多数依然采用了传统 ACL、RBAC、ABAC、UCON、CapBAC 等的思想，仅仅是利用智能合约重新做了实现，是实现手段的变更，实现的手段从传统的 XACML、UMA 等变到了智能合约，只不过这种实现手段附带了区块链的优点。因此研究者们所做的工作，是探索传统访问控制思想与现有实现手段（区块链、智能合约）之间的高效结合方式，探索如何充分利用区块链的优点，以及尽可能消除区块链所引入的困难。</p>
<p>明白这一点对我们主要有如下帮助</p>
<ol>
<li>区块链和传统访问控制模型的简单结合并不能看作一个创新型的工作，即不能在用智能合约实现了 UCON 模型就声称自己提出了一种新的方案，重点在于你的结合和其它结合的区别，如何更高效的利用了区块链的优点，或者如何更有力的消除了区块链的缺点；</li>
<li>如果之前没有人在区块链中实现传统访问控制模型，而你做了，可以算创新，因为要真正实现这一点需要做很多的工作（尤其是没有前人的经验借鉴是比较难的），但是这一点现在基本不太可能，因为传统模型只有几种，现在基本都有了区块链的实现；</li>
<li>大家所做的更多的是系统设计性的工作，而非算法改进，因为采用一种新的手段实现已有模型很少涉及算法，更多的是通过合约结构或合约功能的某种设计和实现，做了一定的优化；</li>
<li>应当充分吸收传统访问控制的优点。传统访问控制经历了多年的发展，在某些实现细节上有很多值得借鉴的设计，当换了一种新的实现手段，这些设计都可以移用过来。目前该方向的研究者大部分都是从区块链入手，考虑访问控制的实现，少有专业的访问控制方向的研究者转向区块链的实现，因此大部分的方案在功能完整性方面甚至都存在一定的不足，无法做全局的考虑。</li>
</ol>
<p>下一小节我们描述区块链这种手段为物联网访问控制带来的优点和引入的困难，这将是我们进行方案优化和性能评估的凭借。</p>
<h3 id="12-好处和困难">1.2 好处和困难</h3>
<p>区块链的引入解决的核心问题是<strong>信任</strong>。链式结构和共识算法带来的不可篡改、透明、便于审计等特性，从而<strong>提高了系统的安全性</strong>，最终帮助我们搭建了协作实体之间的信任关系。基于这种信任关系，我们可以搭建一个统一的平台，从而又带来效率的提高。</p>
<p>安全性又包含两个方面，一个是系统运行过程中对各种攻击的抵御，这是现有物联网系统急缺的能力，这部分的研究主要就是区块链能抵御哪些攻击，添加某些设计又可以抵御哪些新的攻击，逐步完善它的能力；另一个是系统出问题后快速追查出问题的地方，这一点从供应链角度更好理解，建立了统一的平台后，各参与者直接的交接完全数字化和透明，减少了欺诈风险，同时由于数字记录不可篡改，出现问题时可以快速追查到出问题的环节。</p>
<p>区块链还引入了两个优点：<strong>自动化</strong>和<strong>分布式</strong>。自动化是智能合约带来的，基于智能合约图灵完备的能力提高各参与者之间的交接效率，推进数字化进程；分布式是区块链的实现方式带来的，解决了传统集中式方案的单点故障问题。尽管这两个优点是解决信任问题附带的产物，但如果充分利用这两个优点，同样可以是我们考虑的问题。</p>
<p>区块链带来的困难包括</p>
<ol>
<li>实时性。某些场景下可能对实时性有一定的要求，但是，一个合法的交易在区块链中得到确认，需要经历被收集到区块、广播到区块链网络、经由大多数节点验证等过程，与传统方案相比，区块链方案显然有一定的差距；</li>
<li>吞吐量。同样的原因，区块链的吞吐量相比于传统方案有一定的差距，但影响吞吐量的决定性因素是区块链平台和共识算法的选择，架构设计产生的影响不大；</li>
<li>IoT 设备的资源（能力）限制。运行共识算法需要一定的计算能力，不是所有的 IoT 设备都有这样的能力；</li>
<li>IoT 环境的异构性。IoT 设备种类、软件平台、网络环境等千差万别，不是所有 IoT 设备都可以实用区块链客户端，并且可以实时地持续接入区块链网络；</li>
<li>区块链存储的昂贵性。在区块链中存储大量数据会导致区块链快速增长，对成员节点设备的存储性能是一个考验，因此应当尽量避免这一点；</li>
<li>成本问题。例如 Ethereum 中部署合约及与合约交互都需要以太币，更少的 Gas 消耗保证了更低的成本。</li>
</ol>
<p>我们的解决思路</p>
<ol>
<li>实时性和吞吐量：平台和共识选择；</li>
<li>设备资源限制和环境异构性：分层管理；</li>
<li>存储问题：调整合约架构</li>
</ol>
<p>然而，基于智能合约实现的系统中，恶意的行为（如短时间频繁的调用）仍可能产生过量的交易，从而降低合法交易被区块链收集的概率，或者使得确认时间延长，而区块链本身无法对这类行为做出规避。另一方面，物联网环境是一个动态变化的环境，基于属性的访问控制缺乏对这些变化的应对能力，我们应针对操作的严重性、资源的敏感性、用户的访问历史记录等信息，对决策做出动态的调整。目前，只有少数Blockchain-IoT 访问控制的论文结合了动态访问控制的思想<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。</p>
<h2 id="2-相关工作">2. 相关工作</h2>
<p>Huang等<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> 在论文中设计了一个基于信誉的 PoW 共识机制来取得效率与安全的平衡。首先为节点 $i$ 设置一个信誉值属性 $Cr_i$，该值会随着节点的行为实时的变化。正常的行为，如遵守系统规则发送交易，会随着时间的推移使信誉值逐步增加，与之相反，节点产生异常行为会导致信誉值下降。PoW 机制的难度根据每个节点的信誉值自调整，信誉值越低，运行 PoW 算法花费的时间越长。因此，诚实的节点消耗的资源更少，恶意节点攻击所需的花费更多。</p>
<p>在该论文中，作者定义的攻击模型有两个（即两种恶意行为）：</p>
<ol>
<li>Lazy Tips：懒惰的节点指那些总是验证固定的以前的交易，而不去验证最新的交易的节点。例如，恶意实体可以通过发出许多验证固定交易对的交易来人为地扩大<strong><ruby>提示<rt>tips</rt></ruby></strong>的数量。这会使其它节点有更高的概率选中这些提示，而丢弃属于诚实节点的提示</li>
<li>Double-spending：通过在前一次花费被验证之前提交多个交易，恶意节点希望将一枚代币花费两次或多次，这就是双花问题。尽管这样的行为会被共识机制检测到并撤销，但它降低了系统效率，因为其它相关的交易也会被撤销重新执行。</li>
</ol>
<p>更具体的信誉值增减算法的设计，可以参考附录I。但作者设计的算法与 PoW 结合程度较深，对恶意行为的惩罚依赖于难度值得调整，无法在 BFT 类共识算法中继续得到使用，同时，对于智能合约中由于函数调用产生的一些恶意行为，也难以阻止。</p>
<p>Mohammed等<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> 在 RBAC 中结合了信誉机制来消除恶意行为的影响，但该方案依赖于一个中心化的证书权威，恶意行为主要指的是证书的不一致和证书过期。</p>
<p>待补充&hellip;</p>
<h2 id="3-所提出的方案">3. 所提出的方案</h2>
<h3 id="31-恶意行为检测">3.1 恶意行为检测</h3>
<h4 id="311-原始方案">3.1.1 原始方案</h4>
<p><strong>惩罚</strong>：我们取设备 $i$  信誉值的负面影响部分 $Cr_i^N$ 定义为惩罚函数，惩罚函数的值与历史恶意行为的数量和类型（历史行为记录和操作严重性）有关，每个恶意行为的影响随着时间的推移逐渐减小，但不可以变为0，具体的函数如下
$$
Cr_i^N = \sum_{k=1}^{m_i} \alpha(\beta) · \frac{\gamma}{t-t_k}
$$
其中 $m_i$ 表示设备 $i$ 的恶意行为总数，$t$ 表示当前时间，$t_k$ 表示设备 $i$ 造成的第 $k$ 个恶意行为的时间点，$\alpha(\beta)$ 表示恶意行为 $\beta$ 的惩罚系数，在0-1内取值，该系数定义如下，可以根据对恶意行为敏感度的要求进行调整。
$$
\alpha(\beta) = \left \lbrace
\begin{array}{ll}
\alpha_1 &amp; \text{如果 β 代表非法的属性或策略修改请求 ;}  \\
\alpha_2 &amp; \text{如果 β 非法的访问控制请求; } \\
\alpha_3&amp; \text{如果 β 代表短时间发起大量请求}
\end{array} \right.
$$
我们采取的惩罚是阻塞设备的访问请求，意思是计算一个阻塞时间，从当前时间开始的这一段时间内，来自该设备的所有访问请求都被拒绝。阻塞时间根据如下指数函数来计算，可以看出，惩罚函数的值越大，阻塞时间越长。
$$
T_{Blocked} = 2^{Cr_i^N}
$$
惩罚函数中的 $\gamma$ 用来控制恶意行为频率，因为在 $\gamma = 1$ 的情况下，惩罚函数的值总是小于 1 的，这就意味着随之计算得到的阻塞时间会比较小。如果将 $\gamma$ 调大，比如 5，就意味着一旦两次恶意行为的间隔小于 5s （$t-t_k \lt 5$），函数的值会大于1，从而计算得到的阻塞时间会呈指数增长。</p>
<p>每一次恶意行为记录的提交都会触发惩罚函数和阻塞时间的计算，将当前时间加上阻塞时间会得到一个惩罚终止时间，这个终止时间在 RC 中定义为设备的一个属性，只能由信誉合约更新。当 ACC 在进行访问请求判定时，会读取设备该属性判断是否在阻塞期。</p>
<p><strong>奖励</strong>：除了惩罚外，我们还应当对合法的行为做出奖励，从而减少阻塞时间。奖励函数可以利用信誉值的正面影响部分 $Cr_i^P$ 表示。$Cr_i^P$ 应与合法的行为数量正相关，这里的合法行为可以包括</p>
<ol>
<li>普通的增删改操作行为。比如对设备、设备属性、策略等的增删改，这些操作执行完成后，行为记录会发送给信誉合约进行计算。增(Register or Add)、改(Update)、删(Delete)三个操作行为的 ID 分别定义为1，2，3.</li>
<li>访问控制。当设备发起的访问控制通过时，信誉合约接收行为记录并计算信誉值，访问控制通过的行为 ID 为 4</li>
</ol>
<p>我们对四种不同的行为设置不同的权重，最终的 $Cr_i^P$ 定义如下，其中 $\omega_k$ 代表第 $k$ 种操作的权重，$n_k$ 代表第 $k$ 种操作的数量</p>
<p>$$
Cr_i^P = \sum_{k=1}^4 \omega_k n_k
$$</p>
<p>$Cr_i^P$到奖励时间的转换应该是线性的，因为我们认为合法行为的累积不应当导致奖励时间迅速增加，我们在此给出一个合法行为数量上限 $N_{max}$，则奖励时间 $T_{Reward}$ 定义如下
$$
T_{Reward} = \frac{Cr_i^P}{N_{max}} \times T_{Blocked}
$$
注意，计算 $T_{Reward}$ 前需要判定 $Cr_i^P$，若其值大于 $N_{max}$，则置为 $N_{max}$，否则奖励时间就会大于阻塞时间，这是不合适的。</p>
<p>每一次合法行为的提交都会更新合法行为列表，但只有当前设备处于阻塞期，才会计算奖励时间，然后从惩罚终止时间中减去奖励时间，从而使设备的惩罚更早的结束。这里需要注意的是，产生恶意行为并做出惩罚时，并不会立即根据历史行为计算奖励时间，而是在下一次合法行为产生时进行计算。奖励时间计算完毕后，要清空当前的合法行为记录，因为它们已经起到了自己的作用。与之相对的，恶意行为记录永远不会清空，虽然它们产生的影响随着时间的推移变小，但不可能消失，因此每次惩罚函数计算都会读取所有恶意行为。</p>
<p><strong>参数设置</strong>：处于直觉，我们暂时将参数设置为</p>
<ol>
<li>惩罚函数中，$\alpha_1 = 0.5, \alpha_2 = 0.5, \alpha_3 = 1$，因为第三种恶意行为影响更恶劣；</li>
<li>惩罚函数中，$\gamma = 5$，这是直觉判断，需要后续更正；</li>
<li>奖励函数中，$\omega_1 = 0.5, \omega_2 = 0.5, \omega_3 = 0.5, \omega_4 = 1$，因为访问控制通过是主要的合法行为</li>
<li>奖励时间中，$N_{max} = 10$，也是一个直觉判断，需要后续更正</li>
</ol>
<h4 id="312-原始方案的问题">3.1.2 原始方案的问题</h4>
<ol>
<li>设备信誉值不应当与设备活跃程度有关，某种设备可能短时间一次请求都不发起，但这种情况不应当对设备信誉值产生影响；</li>
<li>如果设备一直遵守规则，信誉值会保持不断增长，最终可能导致超限。因此需要为信誉值设置上限和下限；</li>
<li>设备前期累积的信誉值不应当与设备产生的特定恶意行为抵消，也就是说，设备产生了某种特别恶劣的行为，即时它前期积累了很高的信誉，也必须惩罚；</li>
<li>以太坊智能合约语言 Solidity 不支持浮点数定义和运算，因此公式中涉及的除法运算和浮点数需要调整；</li>
<li>原始方案中时间的计算单位是 ms，因此两次行为间隔太久可能导致结果过大，计划将行为数量作为窗口而不是时间间隔；</li>
<li>非法的属性、策略修改请求会被直接拒绝，不会作为交易提交到区块链，阻塞期间继续访问也应当直接拒绝，只有这样才能阻止更多的非法交易进入区块链。</li>
</ol>
<h4 id="313-改进后的方案">3.1.3 改进后的方案</h4>
<p>改进后的方案中，惩罚公式如下
$$
Cr_i^N = -\sum_{k=1}^{m} max \{\alpha(\beta)-(m - k), 1 \}
$$
其中，$m$ 为设备 $i$ 当前的恶意行为总数，$k$ 是第 k 个恶意行为发生时的恶意行为总数，$\alpha(\beta)$ 表示恶意行为 $\beta$ 的惩罚系数，在1-10内取值,该系数定义如下，可以根据对恶意行为敏感度的要求进行调整。
$$
\alpha(\beta) = \begin{cases}
\alpha_1 &amp; \text{如果 β 非法的访问控制请求; } \\
\alpha_2 &amp; \text{如果 β 代表短时间发起大量请求}
\end{cases}
$$
$max \{\alpha(\beta)-(m - k), 1 \}$ 的含义是，每发生一个新的恶意行为，旧的恶意行为惩罚系数就减一，底线是惩罚系数的最小值1，这能保证随着时间的推移，旧的恶意行为的影响不断减小，但不会减小到0。</p>
<p>奖励函数 $Cr_i^P$ 定义不变， $\omega_k$ 代表第 $k$ 种操作的权重，$n_k$ 代表第 $k$ 种操作的数量，但权重的取值范围限定在 1-10
$$
Cr_i^P = max \{ Cr_{imax}^P , \sum_{k=1}^4 \omega_k n_k \}
$$</p>
<p>最终的信誉值计算公式如下
$$
Cr_i = Cr_i^P + Cr_i^N
$$
阻塞时间的计算依然是以 2 为底的指数函数，但这里会进行判断，当恶意行为是短时间发起大量请求时，立刻进行处罚，否则只有在信誉值低于某个值$\gamma$ 时才进行处罚。阻塞时间函数如下
$$
T_{blocked} = 2^{Cr_i}, if \ \text{频繁请求恶意行为} \ or \ \text{(信誉值} &lt; \gamma)
$$</p>
<h3 id="32-合约设计">3.2 合约设计</h3>
<h4 id="321-合约结构">3.2.1 合约结构</h4>
<p>添加恶意行为检测部分后，将原系统中的注册合约（RC）更名为管理合约（MC），将原系统中的判决合约（JC）更名为信誉合约（RC）。因此，当前系统中的三种合约分别为：管理合约（Management Contract, MC），访问控制合约（Access Control Contract, ACC）和信誉合约（Reputation Contract, RC），这几种合约间的调用关系如下图</p>
<p></p>
<p>管理合约（Management Contract, MC），负责管理合约和设备属性。在设备属性中新增 TimeofUnblock 字段，用于设置阻塞终止时间，该字段只能被信誉合约更新。MC中各种操作行为会产生日志并提交给信誉合约</p>
<p>访问控制合约（Access Control Contract，ACC），负责管理资源属性、策略和执行访问控制。在执行访问控制判断时，会首先从 MC 读取 TimeofUnblock 字段，查看是否大于当前时间，如果大于则阻塞请求，否则通过。同样，ACC 中的所有行为记录也会提交到 RC</p>
<p>信誉合约（Reputation Contract, RC），负责根据 MC 和 ACC 提交的记录计算信誉函数的值，并根据该值计算阻塞终止时间，最后调用 MC 的相关函数更新设备的 TimeofUnblock 字段。</p>
<h4 id="322-合约测试">3.2.2 合约测试</h4>
<p>在 Remix 中进行 测试，编译配置开启 <code>Enable optimization</code>（可以大幅减少 gas 消耗），1-7步的顺序不能改变</p>
<ol>
<li>
<p>系统管理者部署MC</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">MC部署账户(系统管理者)：0x4542ED8d83107Db8e9Cab06d9A8D7a02b896f7d9
返回：
 MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe
transaction cost：3164548 gas
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>监管机构部署RC</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">RC部署账户(监管机构)：0x5521Ba0bC012bE5dC12855f4972c48505Dc88c4A
传入：
 MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe
返回：
 RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c
transaction cost：1244974 gas
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>系统管理者调用 MC中的 setRC()  进行设置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(系统管理者)：0x4542ED8d83107Db8e9Cab06d9A8D7a02b896f7d9
传入：
 RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c
 监管机构账户：0x5521Ba0bC012bE5dC12855f4972c48505Dc88c4A
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>设备管理者部署 ACC</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ACC部署账户(设备管理者)：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入：
 MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe
 RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c
 设备管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
返回：
 ACC合约地址：0x19455cac7bd27705661d467e20ee82b1cc48737b
transaction cost：5635472 gas
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>设备管理者调用 MC 中的 deviceRegister() 函数，注册自身</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者)：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数为：
 设备地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
 管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
 合约地址：0x19455cac7bd27705661d467e20ee82b1cc48737b
 设备ID：gateway33
 设备类型：gateway
 设备角色：manager
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>设备部署 ACC</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ACC部署账户(设备)：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1
传入：
 MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe
 RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c
 设备管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
返回：
 ACC合约地址：0x54d463eca95c313077815ce0a893b4036199e28e
transaction cost：5635472 gas
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>设备管理者调用 MC 中的 deviceRegister() 函数，注册设备固定属性</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者)：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数为：
 设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1
 管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
 合约地址：0x54d463eca95c313077815ce0a893b4036199e28e
 设备ID：pallat23
 设备类型：pallat
 设备角色：device
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>设备管理者调用 MC 中的 addAttribute()  函数，添加额外属性</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数：
 设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1
 属性名：currentFruit
 属性值：apple
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>调用 MC 中的 get 类函数，查看设备属性，包括 getFixedAttribute(), getDeviceRelatedAddress(), getCustomedAttribute() 三个函数</p>
</li>
<li>
<p>设备管理者调用 MC 中的 updateAttribute() 函数，更改属性</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数：
    设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1
    属性名：currentFruit
    属性值：peer
</code></pre></td></tr></table>
</div>
</div><p>调用 MC 中的 getCustomedAttribute() 函数，查看更改后的属性，确认无误</p>
</li>
<li>
<p>设备管理者调用 MC 中的 deleteAttribute() 函数，删除 currentFruit 属性</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数：
    设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1
    属性名：currentFruit
</code></pre></td></tr></table>
</div>
</div><p>调用 MC 中的 getCustomedAttribute() 函数，会返回 Attribute not exist! 错误</p>
</li>
</ol>
<p>接下来测试访问控制合约（ACC）</p>
<ol>
<li>
<p>设备管理者调用 ACC 的 addResourceAttr() 函数添加资源属性</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数：
 资源名：GPS
 属性名：currentLocation
 属性值：116.309551, 39.896559 
</code></pre></td></tr></table>
</div>
</div><p>然后调用 getResourceAttr() 函数查看</p>
</li>
<li>
<p>设备管理者调用 ACC 的 updateResourceAttr() 函数更新资源属性，继续查看；最后调用 deleteResourceAttr() 函数删除资源属性，查看返回 Resource attribute not exist! 错误</p>
</li>
<li>
<p>设备管理者调用 ACC 的 addPolic() 函数添加策略</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数：
 资源名：truck
 操作：read
 属性所有者：subject
 属性名：deviceType
 操作符：=
 属性值：gateway
</code></pre></td></tr></table>
</div>
</div><p>成功后查看策略</p>
</li>
<li>
<p>设备管理者调用 ACC 的 accessControl() 函数，测试访问控制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18
传入参数：
 资源名：truck
 操作：read
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h4 id="323-合约审计">3.2.3 合约审计</h4>
<p>依旧打算使用 Mythx 进行合约审计，但 Mythx 已转为收费，合约审计部分的工作只能放弃。</p>
<h2 id="4-性能测试的指标">4. 性能测试的指标</h2>
<p>测量值，或者说实验结果分为三部分：访问控制系统、私有交易验证和信誉系统，下面对其进行讨论。</p>
<h3 id="41-访问控制系统">4.1 访问控制系统</h3>
<p>合约功能以及在 Remix 中进行了验证，访问控制系统应当获得的实验结果，包括</p>
<ol>
<li>合约部署的时间和 Gas 消耗；</li>
<li>属性定义及更新的时间消耗；</li>
<li>访问控制的时间消耗；</li>
</ol>
<p>其中以访问控制的时间消耗为最主要的测量者，我们应当证明我们实现的系统相比于其它系统更优，尤其是相对于论文[^wang_2016_blockchain]，主要就是通过访问控制时间的对比。事实上，我们还应当通过 IBM Food Trust 的访问控制系统做对比，但目前我们无法拿到该系统的数据。</p>
<p>Gas 的消耗在 Remix 部署时可以在返回值中看到，属性定义、更新、访问控制等操作都通过 JS 脚本进行，利用 JS 的时间库计算执行时间。每一种操作都取 50 次测量的平均值。要注意的是，时间的测量值受实验环境影响很大。</p>
<h3 id="42-私有交易验证">4.2 私有交易验证</h3>
<p>我们设定超市与农场的购买合同是私有的，通过 Remix 发起私有交易，通过 Geth 或 Cakeshop 区块链浏览器查看。</p>
<h3 id="43-信誉系统">4.3 信誉系统</h3>
<p>需要验证奖励、惩罚、容忍、报警四大功能。</p>
<p>输入参数定义为一个文件，文件包括三列，第一列是产生请求的时间，需要符合泊松分布，可以通过 Matlab 产生；第二列是是请求类型，根据请求类型的不同调用不同的 JS 脚本。应当得到的值包括 CrP、CrN、阻塞时间等，这些参数都通过监测合约发出的时间收集。收集到相关数据后，计算正确检测恶意行为的概率、虚警概率、信誉值随时间变动的曲线、阻塞时间的变化等。</p>
<p>应当注意、产生请求的时间、当前属性、请求类型全部都是随机的，这样才有测量的必要，恶意行为应当不止一种，且是否能检测到也是不确定的，这样才存在正确检测恶意行为的概率。</p>
<p>读取文件并调用 JS 脚本，使用 Shell 脚本完成。</p>
<h2 id="附录i-参考的信誉算法">附录I 参考的信誉算法</h2>
<p>根据节点 $i$ 的行为，将其信誉值 $Cr_i$ 划分为两部分，公式如下
$$
Cr_i = \lambda_1 Cr_i^P + \lambda_2 Cr_i^N
$$
其中 $Cr_i^P$ 代表正面影响部分，$Cr_i^P$ 代表负面影响部分。$\lambda_1$ 和 $\lambda_2$ 分别代表各部分的权重系数，调节这两个值就可以调整两部分所占权重，比如，如果我们想要严格的惩罚策略，应该令 $\lambda_2$ 更大一点。</p>
<p>$Cr_i^P$ 与节点 $i$ 单位时间内正常的交易数量成正相关，即通过节点活跃程度定义，表示如下
$$
Cr_i^P = \frac{\sum_{k=1}^{n_i} \omega_k} {\Delta T}
$$
其中 $n_i$ 代表节点 $i$ 在最近的单位时间内有效交易的数量，$\Delta T$ 代表单位时间，$\omega_k$ 代表第 $k$ 个交易的权重，交易的权重指的是该交易被验证的次数。也就是说，如果节点 $i$ 在一段时间内保持活跃，$Cr_i^P$ 将根据活跃程度不断调整，保证活跃节点可以使用更少的算力更快地发布交易。如果节点 $i$ 在一段时间内没有发布交易，就认为它是不活跃的，甚至是不可信节点，所以系统不会为它降低 PoW 的难度，即 $Cr_i^P = 0$。</p>
<p>$Cr_i^N$ 与节点 $i$ 的恶意行为数量成负相关，可以表示为
$$
Cr_i^N = -\sum_{k=1}^{m_i} \alpha(\beta) · \frac{\Delta T}{t-t_k}
$$
其中 $m_i$ 表示节点 $i$ 的恶意行为总数，$t$ 表示当前时间，$t_k$ 表示节点 $i$ 造成的第 $k$ 个恶意行为的时间点，$\alpha(\beta)$ 表示恶意行为 $\beta$ 的惩罚系数，该系数定义如下，其中 $\alpha_l$ 和 $\alpha_d$ 可以根据对恶意行为敏感度的要求进行调整。
$$
\alpha(\beta) = \begin{cases} \alpha_l&amp;\text{if β is lazy tips behavior;}  \\ \alpha_d &amp; \text{if β is double-spending behavior} \end{cases}
$$
从$Cr_i^N$ 的公式中我们可以发现，随着时间的推移，恶意行为对节点的影响在逐渐减小，但不同于 $Cr_i^P$，它无法减小到0，也就是完全消除。当一个恶意行为发生的时候，$Cr_i^N$ 的绝对值会很大，由于 PoW 难度巨大，攻击将无法持续，通过这种方式我们可以及时阻止恶意行为。</p>
<p>该机制正常运行的需求是我们可以获取每个节点相关的所有交易，这样就可以计算出交易权重 $\omega$ 和 恶意行为记录 $\alpha(\beta)$，从而可以独立地计算出 $Cr_i^P$ 和 $Cr_i^N$，最终得到信誉值。作者在论文中将信誉值与 PoW 难度关联，具体来说，这两种成反比，定义公式为 $Cr_i = \delta \frac 1{D_i}$，其中 $D_i$ 为节点 $i$ 的 PoW 难度，$\delta$ 为比例系数。这样，信誉值高的难度低，信誉值低的难度高，难度的调整通过控制前缀0的最小长度完成，整个系统得以实现。</p>
<p>具体的实验中以上公式中的相关参数如何设置，作者给出了一些描述。交易权重 $\omega$ 可以直接计算，两个权重系数设置为 $\lambda_1 = 1,\lambda_2 = 0.5$，因为 $Cr_i^N$ 的值可能相对比较大，如果想要更严厉的惩罚措施，$\lambda_2$ 可以设置的更大。考虑到 IIoT 系统的请求频率，单位时间设置为 $\Delta T = 30s$，一个不是太长的间隔。对于 lazy tips，设置 $\alpha(\beta) = 0.5$，对于 double-spending，设置 $\alpha(\beta) = 1$，因为双花对系统造成的损害更严重。</p>
<h2 id="附录ii-所做调整">附录II 所做调整</h2>
<p><span id="jump"></span>下面是所作的调整总结</p>
<ul>
<li><i class="far fa-square fa-fw"></i> 功能-策略冲突解决机制</li>
<li><i class="far fa-square fa-fw"></i> 功能-无匹配策略时的处理</li>
<li><i class="far fa-square fa-fw"></i> 功能-恶意行为检测</li>
<li><i class="far fa-check-square fa-fw"></i> 架构-策略定义拆分单独的合约（提供重用性）</li>
<li><i class="far fa-square fa-fw"></i> 架构-部分函数迁移到单独的库文件 Utils.sol（for gas save）</li>
<li><i class="far fa-square fa-fw"></i> 语法-匹配最新版本编译器</li>
<li><i class="far fa-square fa-fw"></i> 语法-统一代码风格</li>
<li><i class="far fa-square fa-fw"></i> 实验过程-去除合约审计（MythX 转为收费）</li>
<li><i class="far fa-square fa-fw"></i> 实验过程-移除树莓派节点（在家的时候没有树莓派）</li>
<li><i class="far fa-square fa-fw"></i> 实验过程-恶意行为的测试方案</li>
<li><i class="far fa-check-square fa-fw"></i> 实验过程-测试新的性能指标（必要的）</li>
<li><i class="far fa-check-square fa-fw"></i> 实验过程-利用 JavaScript 和 Bash 交互迁移到利用 Go</li>
<li><i class="far fa-square fa-fw"></i> 思路-明晰背景（为什么做这件事）</li>
<li><i class="far fa-square fa-fw"></i> 思路-明晰场景</li>
<li><i class="far fa-square fa-fw"></i> 思路-信誉算法设计</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>史锦山, 李茹, 等. 物联网下的区块链访问控制综述[J]. 软件学报, 2019, Vol.30Issue(6): 1632–1648. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>ZHANG Y, KASAHARA S, SHEN Y, 等. Smart Contract-Based Access Control for the Internet of Things[J]. IEEE Internet of Things Journal, 2019, 6(2): 1594–1605. DOI:<a href="https://doi.org/10.1109/JIOT.2018.2847705" target="_blank" rel="noopener noreffer">10.1109/JIOT.2018.2847705</a>. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>AMOON M, ALTAMEEM T, ALTAMEEM A. RRAC: Role Based Reputed Access Control Method for Mitigating Malicious Impact in Intelligent IoT Platforms[J]. Computer Communications, 2020, 151: 238–246. DOI:<a href="https://doi.org/10.1016/j.comcom.2020.01.011" target="_blank" rel="noopener noreffer">10.1016/j.comcom.2020.01.011</a>. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>J. Huang, L. Kong, G. Chen, M.-Y. Wu, X. Liu, and P. Zeng, “Towards Secure Industrial IoT: Blockchain System With Credit-Based Consensus Mechanism,” <em>IEEE Trans. Ind. Inf.</em>, vol. 15, no. 6, pp. 3680–3689, Jun. 2019, doi: <a href="https://doi.org/10.1109/TII.2019.2903342" target="_blank" rel="noopener noreffer">10.1109/TII.2019.2903342</a>. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>]]></description></item><item><title>2018-2020 研究历史</title><link>https://shuzang.github.io/2018-2020-research-history/</link><pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/2018-2020-research-history/</guid><description><![CDATA[<p>本文总结2018年12月到2020年4月的研究工作历史，不包括论文阅读工作。</p>
<h2 id="201812">2018.12</h2>
<ul>
<li>区块链主流共识算法收集了解和分析</li>
<li>IIoT 与区块链结合的场景收集和一些研究思路， <a href="https://shuzang.github.io/blockchain-for-iot/" target="_blank" rel="noopener noreffer">总结文档地址</a></li>
<li>利用 Hyperledge Composer 完成供应链场景下的易腐食品运输示例</li>
</ul>
<h2 id="201901">2019.01</h2>
<ul>
<li>实时与非实时数据的区别，区块链存储问题分析，<a href="https://shuzang.github.io/data-storage-in-blockchain/" target="_blank" rel="noopener noreffer">总结文档地址</a></li>
<li>区块链平台比较和选择，<a href="https://shuzang.github.io/blockchain-platform-compare-and-select/" target="_blank" rel="noopener noreffer">总结文档地址</a></li>
</ul>
<h2 id="201903">2019.03</h2>
<ul>
<li>Ethereum 原理、架构等基本知识学习</li>
<li>利用虚拟机搭建 Ethereum 私有链，熟悉转账、挖矿等相关命令和操作</li>
<li>了解智能合约编译、部署、调用全过程，了解智能合约开发与测试框架 Truffle</li>
<li>搭建 Swarm 分布式存储网络</li>
</ul>
<h2 id="201904">2019.04</h2>
<ul>
<li>Ethereum 区块生成时间数据集获取及分析 <a href="https://shuzang.github.io/extract-the-block-generation-time-of-ethereum/" target="_blank" rel="noopener noreffer">过程记录</a></li>
<li>场景思考，初步的方案设计和实验设计，工业4.0背景了解。<a href="https://shuzang.github.io/blockchain-for-smart-factory/" target="_blank" rel="noopener noreffer">未完成的智能工厂方案设计</a></li>
<li>智能合约编程语言 Solidity 语法学习及练习</li>
<li>基于已有知识的区块链综述文章撰写，<a href="https://shuzang.github.io/blockchain-for-iot/iiota-smart-factory-case-study/" target="_blank" rel="noopener noreffer">文档地址</a></li>
</ul>
<h2 id="201905">2019.05</h2>
<ul>
<li>继续撰写综述文章，智能工厂场景可行性分析及相关问题考虑</li>
<li>区块链安全与隐私问题总结分析，比如可能的攻击、相关解决方案等，相关方向论文阅读</li>
<li>注意力集中在两篇当时新出的区块链和智能工厂结合的论文，初步确认了应实现一个访问控制方案</li>
</ul>
<h2 id="201906">2019.06</h2>
<ul>
<li>各论文使用的访问控制方案总结比较</li>
<li>各论文使用的存储方案总结</li>
<li>起草开题报告第一版，确认三个创新方向为：访问控制，存储，其它（如共识、通信方式、不相干区块过滤），并确认具体的细节</li>
</ul>
<h2 id="201907">2019.07</h2>
<ul>
<li>开题报告内容继续完善</li>
<li>开始关注区块链平台性能分析工具，并将其作为一个可能的方向</li>
<li>确认要做的三件事：1. 在 Zhang 的方案上复现然后做改进；2. 区块链压缩；3. 移动性和通信链路不稳定性问题解决</li>
</ul>
<h2 id="201908">2019.08</h2>
<ul>
<li>关注性能分析可能遇到的问题及其实验设计细节，寻找可能的方向</li>
<li>安排访问控制方案实现的时间表</li>
<li>熟悉 Quorum 区块链及其网络搭建</li>
<li>开题</li>
</ul>
<h2 id="201909">2019.09</h2>
<ul>
<li>设计树莓派和PC的组网方案，Quorum 客户端编译部署到树莓派，最终将树莓派作为节点加入 Quorum网络</li>
<li>Zhang 论文中的访问控制合约复现，部署及相关问题解决</li>
<li>开始关注异常检测方向，了解强化学习概念和信誉问题</li>
</ul>
<h2 id="201910">2019.10</h2>
<ul>
<li>复现合约的功能测试，相关测试脚本的编写</li>
<li>异常检测方向的论文收集和阅读，相关思路提出，<a href="https://shuzang.github.io/blockchain-and-anomaly-detection/" target="_blank" rel="noopener noreffer">总结文档地址</a></li>
<li>访问控制方案场景思考，可优化之处分析，<a href="https://shuzang.github.io/idea-design-and-optimization-of-smart-contract-based-access-control-scheme/" target="_blank" rel="noopener noreffer">总结文档地址</a></li>
</ul>
<h2 id="201911">2019.11</h2>
<ul>
<li>实验室已有设备梳理及实验方案设计</li>
<li>优化的访问控制方案设计及智能合约实现</li>
<li>区块链用于物联网访问控制的全部问题总结，<a href="https://shuzang.github.io/blockchain-based-access-control-for-iot/" target="_blank" rel="noopener noreffer">文档地址</a></li>
</ul>
<h2 id="201912">2019.12</h2>
<ul>
<li>区块链发展情况调查，包括论文发表情况，期刊、会议和基金信息，研究团队，著名研究者，征稿情况等</li>
<li>已实现的访问控制合约功能测试，使用Truffle 部署，Gas和时间消耗统计，合约安全性检查</li>
</ul>
<h2 id="202001">2020.01</h2>
<ul>
<li>整理已完成访问控制工作，总结创新点，思考下一步研究方向（异常检测、区块链压缩，细化方案，性能测试工具）</li>
<li>通过阅读论文了解当时访问控制发展情况，区块链理论发展情况</li>
</ul>
<h2 id="202003">2020.03</h2>
<ul>
<li>论文写作</li>
<li>分析存储方向研究思路的可行性</li>
<li>开始阅读 Edge-D2D-区块链 的论文</li>
</ul>
<h2 id="202004">2020.04</h2>
<ul>
<li>D2D与区块链结合背景情况调查，初步方案提出，<a href="https://shuzang.github.io/blockchain-for-d2d-cache-or-computing-offload/" target="_blank" rel="noopener noreffer">总结文档地址</a></li>
<li>阅读已有论文分析现有访问控制工作的可扩展性</li>
</ul>
]]></description></item><item><title>An Attribute-Based Distributed Access Control for Blockchain-enabled IoT</title><link>https://shuzang.github.io/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/</link><pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/</guid><description><![CDATA[<p>P. Wang, Y. Yue, W. Sun, and J. Liu, “An Attribute-Based Distributed Access Control for Blockchain-enabled IoT,” in <em>2019 International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob)</em>, Barcelona, Spain, Oct. 2019, pp. 1–6, doi: <a href="https://doi.org/10.1109/WiMOB.2019.8923232" target="_blank" rel="noopener noreffer">10.1109/WiMOB.2019.8923232</a>.</p>
<p>第一作者是西电的，国家自然科学基金项目成果，研究方向完全一致，都是利用智能合约实现 ABAC 模型完成物联网访问控制。可以看的出来，这篇论文也深受 Zhang<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 的影响，参考的文献全都看过，由于方向一致，这是必然的事情。因此，这里记的笔记不包括引言、相关工作、实验等部分，仅仅理解和阐述作者的架构描述，并分析其优缺点，将优点吸纳到我们当前的方案。</p>
<h2 id="1-系统架构">1. 系统架构</h2>
<p>用来说明方案的 IoT 场景是 smart home，如下图所示。作者将设备分为三类</p>
<ol>
<li>有足够计算和存储能力的节点，比如 server 和 desktop，这部分作为区块链全节点；</li>
<li>只有有限的计算和存储能力，比如 mobile phone 和 smart TV，这部分作为轻节点；</li>
<li>计算和存储能力高度有限，比如传感器，这些设备称为超轻量级节点，由所连接的网关作为代理。</li>
</ol>
<p></p>
<p>Server 负责存储 IoT 设备产生的数据，包括传感器收集的环境信息、运行过程产生的日志文件，同时向设备提供服务，因此也会发送一些命令到设备从而控制设备的执行。全节点或轻节点通过有线或 Wi-Fi 连到网络，维持区块链的运行，保存所有或部分访问控制信息，执行访问控制。超轻量级节点通过 Bluetooth、Wi-Fi、ZigBee 等技术连到网关，从而连到网络，不存储访问控制信息，只通过网关发起访问控制请求或获取访问控制结果。</p>
<h2 id="2-访问控制架构">2. 访问控制架构</h2>
<p>核心是 ABAC 模型，如下图所示，收到访问控制请求后根据主体属性（Subject Attribute, SA）、客体属性（Object Attribute, OA）和环境属性（Environment Attribute, EA）执行预定义的策略，从而得到结果。</p>
<p></p>
<p>作者使用了一个 Subject Contract（SC）、一个 Object Contract（OC）、一个 Access Control Contract（ACC）和多个 Policy Contracts（PC）来实现该模型，各部分介绍如下。</p>
<h3 id="21-subject-contract">2.1 Subject Contract</h3>
<p>由于设备可以作为 subject 发起访问，也可以作为 object 提供资源，subject 访问不同的 object 时属性还有可能不同，作者将主体属性划分为两部分：</p>
<ol>
<li>Manufacturer Attribute（MA）：由制造商在出厂时设置的属性，无法二次修改，主要包括一些设备的基本信息，比如 MAC 地址和序列号。</li>
<li>Setting by Object Attribute（SOA）：如果设备 o 作为 object 设置了针对 subject s 的 SOA，意味着该属性只在 s 访问 o 时生效，其它 subject 访问 o 不生效。</li>
</ol>
<p>SC 负责管理合法制造商的账户、IoT 设备账户和设备的主体属性信息，属性以键值对的形式定义，如下所示
$$
[name_1:value_1] [name_2:value_2] ……  [name_n:value_n]
$$
一个 MA 的示例为 $[type:remotecontrol][mac:00efefefefef]$，</p>
<p>一个 SOA 的示例为 $[group:owner][role:children]$</p>
<p>SC 提供了如下功能</p>
<ol>
<li>addmanufacturer()：只能由 SC 所有者调用，传入制造商账户地址，将该地址代表的制造商加如合法制造商列表</li>
<li>addsubject()：只能由合法制造商列表中的成员调用，负责注册新的 IoT 设备</li>
<li>addobattr()：由 object 调用，设置针对某个 subject 的 SOA，接收设备地址和一个描述属性的字符串</li>
<li>delemanufacturer()，deleteobattr()：如函数名</li>
</ol>
<h3 id="22-object-contract">2.2 Object Contract</h3>
<p>OC 负责管理每个设备的 object attributes（OA），和主题属性的结构定义相同，一个 OA 示例为$[type:TV][location:living]$。OC 提供的函数功能有：</p>
<ol>
<li>addobattr()：接收设备地址和一个描述属性的字符串，设置客体属性</li>
<li>deleteobattr()：接收设备地址，删除对应的属性</li>
<li>getattr()：接收设备地址，获取对应的属性</li>
</ol>
<h3 id="23-policy-contract">2.3 Policy Contract</h3>
<p>每个用户创建自己的 PC，并在 ACC 中和用户的设备进行绑定，因此，一个 PC 可能对应多个 IoT 设备，但只有一个所有者且只有所有者可以添加或删除策略。</p>
<p><strong><ruby>策略<rt>policy</rt></ruby></strong> 和 <strong><ruby>规则<rt>rule</rt></ruby></strong> 在 PC 中是不同的，策略由如下五个字段定义
$$
resource, action,duty,rule,algorithm
$$
其中，$duty$ 是实施完访问控制需要做的事；一个策略可能包含多个规则，一个 $rule$ 由 $SA,OA,EA,resource,action,result$ 六部分组成；$algorithm$ 用来在规则产生矛盾时进行判定；返回的结果有两种：$allow$ 和 $deny$。一个示例为</p>
<blockquote>
<p>policy: [resource:switch] [action:on] [duty:record] [algorithm:denyoverrides]</p>
<p>rule1:</p>
<p>​	subject attribute: [group:owner] [role:parent] [type:remotecontrol]</p>
<p>​	object attribute: [type:TV] [location:livingroom]</p>
<p>​	environment attribute: [time: 21:00 - 23:00]</p>
<p>​	result: allow</p>
</blockquote>
<p>PC 提供如下函数功能：</p>
<ol>
<li>addpolicy()：添加新策略到用户策略集，接收四个参数：resource, action, duty 和 algorithm</li>
<li>addrule()：添加新规则到策略，接收六个参数：SA, OA, EA, resource, action 和 result，通过资源和操作，可以找到相应的策略并将规则添加到规则列表</li>
<li>delepolicy()，delerule()：如函数名</li>
</ol>
<h3 id="24-access-control-contract">2.4 Access Control Contract</h3>
<p>ACC 用来确定请求是否符合用户自定义的策略，最终会返回相应的结果并执行预定的 $duty$，如记录访问历史到区块链等，历史记录结构示例如下</p>
<p></p>
<p>PC 提供的函数功能如下</p>
<ol>
<li>
<p>Initialization()：为了和 SC，OC 交互，记录它们的合约地址</p>
</li>
<li>
<p>setobjectpolicyaddress()：负责将 PC 地址绑定到 IoT 设备地址，接收这两个地址作为参数</p>
</li>
<li>
<p>accesscontrol()：执行访问控制，接收 subject address、object address 、resource 、action 四个参数，与其它几个合约交互获取相应的属性信息和策略信息，然后根据策略中每个规则进行判决并记录，如果满足规则，获取 $allow$ 或 $deny$ 两个结果之一，如果不满足，返回 $NotAplicable$，最后利用 $algorithm$ 处理冲突得到最终结果。如果设置了 $duty$ 字段，那么执行该字段描述的任务。该函数的算法伪代码如下</p>
<p></p>
</li>
</ol>
<h2 id="3-总结与收获">3. 总结与收获</h2>
<p>这篇论文基本可以看作传统的 XACML 的架构使用智能合约的实现，比如 SC 和 OC 用来维护属性信息，相当于策略信息点（PIP）；PC 维护策略信息，相当于策略管理点（PAP），ACC接收并执行访问控制策略，相当于策略实施点（PEP）和策略决策点（PDP）的结合。这种结构将各部分功能进行了良好的划分，确保了低内聚高耦合，所以现在应该去深入理解一下传统 ABAC 模型，了解其缺点后，再讨论是像这篇论文这一原样实现还是做一些改变。</p>
<p>在 Ouaddah 的论文中评价了 ABAC 模型的优劣<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。他认为 ABAC 模型的优点是较好的互操作性和细粒度的访问控制，缺点是较为复杂和非用户驱动，这里介绍一下两个缺点：</p>
<ol>
<li><strong>Complexity</strong>：属性语义的诠释，属性的可信度，表达基于属性的授权请求和响应的语法定义，这些都是导致 ABAC 复杂的原因。另外，XACML 的复杂性常导致用户避免使用它转而使用更传统的方法。这种复杂性还阻碍了它在日常场景中的应用，例如，可穿戴娱乐物联网应用领域。只有在需要高度互操作性和细粒度表达的应用中才适合使用这种模型。</li>
<li><strong>Not User-driven</strong>：尽管 XACML 和 ABAC 是完善而精确的策略描述方法，XACML 策略的结构是复杂的。用户必须深入理解 XACML 才能熟练地写下详细地策略，这使得 XACML 难以掌握和使用。这种方式地隐私管理不支持以<strong><ruby>本机方式<rt>native way</rt></ruby></strong>与用户交互，为了让用户参与策略制定过程，需要一个用户驱动的隐私管理器。</li>
</ol>
<p>可以思考如何在区块链中改善这两者。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Y. Zhang, S. Kasahara, Y. Shen, X. Jiang, and J. Wan, “Smart contractbased access control for the internet of things,” IEEE Internet of Things Journal, vol. 6, no. 2, pp. 1594–1605, 2019. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>A. Ouaddah, H. Mousannif, A. A. Elkalam, and A. A. Ouahman, “Access control in The Internet of Things: Big challenges and new opportunities,” <em>Computer Networks</em>, vol. 112, pp. 237–262, 2016. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></description></item></channel></rss>