<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Go项目基础 - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/go%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/</link><description>Go项目基础 - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 07 Jun 2020 09:48:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/tags/go%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/" rel="self" type="application/rss+xml"/><item><title>Golang日志系统</title><link>https://shuzang.github.io/golang-log-system/</link><pubDate>Sun, 07 Jun 2020 09:48:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-log-system/</guid><description><![CDATA[<p>日志是一个系统必不可少的部分，本篇介绍Golang中的日志系统。</p>
<h2 id="1-内置log包">1. 内置log包</h2>
<p>官方提供的 log 包实现了简单的日志服务。该包定义了一个 Logger 类型，提供了一些格式化输出方法，为了更容易地使用，对该类型提供了一个标准 Logger 实现，该 Logger 会打印每条日志信息的日期、时间、默认输出到标准错误，Fatal系列函数会在写入日志信息后调用 os.Exit(1)。Panic系列函数会在写入日志信息后panic。</p>
<h3 id="11-内置实现">1.1 内置实现</h3>
<p>一个内置实现使用的简单例子如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// This sample program demonstrates how to use the base log package.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;log&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">SetPrefix</span><span class="p">(</span><span class="s">&#34;TRACE: &#34;</span><span class="p">)</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">SetFlags</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">Ldate</span> <span class="p">|</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lmicroseconds</span> <span class="p">|</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Llongfile</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Println writes to the standard logger.
</span><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;message&#34;</span><span class="p">)</span>

    <span class="c1">// Fatalln is Println() followed by a call to os.Exit(1).
</span><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="s">&#34;fatal message&#34;</span><span class="p">)</span>

    <span class="c1">// Panicln is Println() followed by a call to panic().
</span><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nf">Panicln</span><span class="p">(</span><span class="s">&#34;panic message&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">-------------------------------</span>
<span class="nx">TRACE</span><span class="p">:</span> <span class="mi">2019</span><span class="o">/</span><span class="mo">04</span><span class="o">/</span><span class="mi">09</span> <span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mf">32.868375</span> <span class="nx">D</span><span class="p">:</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">TestFile</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">TestLog</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span> <span class="nx">message</span>
<span class="nx">TRACE</span><span class="p">:</span> <span class="mi">2019</span><span class="o">/</span><span class="mo">04</span><span class="o">/</span><span class="mi">09</span> <span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mf">32.962329</span> <span class="nx">D</span><span class="p">:</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">TestFile</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">TestLog</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span> <span class="nx">fatal</span> <span class="nx">message</span>

<span class="nx">Process</span> <span class="nx">finished</span> <span class="nx">with</span> <span class="nx">exit</span> <span class="nx">code</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>原型函数的说明如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Flags</span><span class="p">()</span> <span class="kt">int</span>            		<span class="c1">// Flags返回标准logger的输出选项
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SetFlags</span><span class="p">(</span><span class="nx">flag</span> <span class="kt">int</span><span class="p">)</span>   		<span class="c1">// SetFlags设置标准logger的输出选项
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Prefix</span><span class="p">()</span> <span class="kt">string</span>      		<span class="c1">// Prefix返回标准logger的输出前缀
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SetPrefix</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span> 		<span class="c1">// SetPrefix设置标准logger的输出前缀
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SetOutput</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>		<span class="c1">// SetOutput设置标准logger的输出目的地，默认是标准错误输出
</span><span class="c1"></span>
<span class="c1">// Printf调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Printf相同的方法处理。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="c1">// Print调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Print相同的方法处理。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="c1">// Println调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Println相同的方法处理。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Println</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>

<span class="kd">func</span> <span class="nf">Fatalf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>	<span class="c1">// Fatalf等价于{Printf(v...); os.Exit(1)}
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Fatal</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>			<span class="c1">// Fatal等价于{Print(v...); os.Exit(1)}
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Fatalln</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>			<span class="c1">// Fatalln等价于{Println(v...); os.Exit(1)}
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Panicf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>	<span class="c1">// Panicf等价于{Printf(v...); panic(...)}
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Panic</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>			<span class="c1">// Panic等价于{Print(v...); panic(...)}
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Panicln</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>			<span class="c1">// Panicln等价于{Println(v...); panic(...)}
</span></code></pre></td></tr></table>
</div>
</div><p>SetPrefix 设置输出前缀，SetfFlags 设置输出选项，为了理解输出前缀与选项，我们先来看一个标准输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">TRACE</span><span class="p">:</span> <span class="mi">2019</span><span class="o">/</span><span class="mo">04</span><span class="o">/</span><span class="mi">09</span> <span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mf">32.868375</span> <span class="nx">D</span><span class="p">:</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">TestFile</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">TestLog</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span> <span class="nx">message</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，<code>TRACE</code> 就是输出前缀，可以通过 SetPrefix 设置，通过 Prefix 输出，用来在普通的程序输出中分布出日志。后面冒号前的信息就是输出选项，通过 SetFlags 设置，通过 Flags 输出。输出选项的结构定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// 字位共同控制输出日志信息的细节。不能控制输出的顺序和格式。
</span><span class="c1"></span>    <span class="c1">// 在所有项目后会有一个冒号：2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
</span><span class="c1"></span>    <span class="nx">Ldate</span>         <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>     <span class="c1">// 日期：2009/01/23
</span><span class="c1"></span>    <span class="nx">Ltime</span>                         <span class="c1">// 时间：01:23:23
</span><span class="c1"></span>    <span class="nx">Lmicroseconds</span>                 <span class="c1">// 微秒分辨率：01:23:23.123123（用于增强Ltime位）
</span><span class="c1"></span>    <span class="nx">Llongfile</span>                     <span class="c1">// 文件全路径名+行号： /a/b/c/d.go:23
</span><span class="c1"></span>    <span class="nx">Lshortfile</span>                    <span class="c1">// 文件无路径名+行号：d.go:23（会覆盖掉Llongfile）
</span><span class="c1"></span>    <span class="nx">LstdFlags</span>     <span class="p">=</span> <span class="nx">Ldate</span> <span class="p">|</span> <span class="nx">Ltime</span> <span class="c1">// 标准logger的初始值
</span><span class="c1"></span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>log 包有一个很方便的地方就是，这些日志记录器是多 goroutine 安全的。这意味着在多个goroutine 可以同时调用来自同一个日志记录器的这些函数，而不会有彼此间的写冲突。标准日志记录器具有这一性质，用户定制的日志记录器也应该满足这一性质。</p>
<h3 id="12-基于logger自定义">1.2 基于Logger自定义</h3>
<p>官方的预置实现是基于Logger类型的，我们也可以基于Logger类型自己进行实现</p>
<p>Logger类型表示一个活动状态的记录日志的对象，它会生成一行行的输出写入一个io.Writer接口。每一条日志操作会调用一次io.Writer接口的Write方法。Logger类型的对象可以被多个线程安全的同时使用，它会保证对io.Writer接口的顺序访问。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Logger类型的方法就是官方实现的那些函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Fatal</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Fatalf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Fatalln</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Flags</span><span class="p">()</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Output</span><span class="p">(</span><span class="nx">calldepth</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Panic</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Panicf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Panicln</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Prefix</span><span class="p">()</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">Println</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetFlags</span><span class="p">(</span><span class="nx">flag</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetPrefix</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>有区别的是，还有一个 New 函数用来创建一个 Logger，其中的参数 out 用于设置日志信息写入的目的地，prefix 设置前缀，flag 设置选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">prefix</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">flag</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Logger</span>
</code></pre></td></tr></table>
</div>
</div><p>一个简单的使用示例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
<span class="nx">logger</span> <span class="o">:=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;logger: &#34;</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lshortfile</span><span class="p">)</span>
<span class="nx">logger</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;Hello, log file!&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">)</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="nx">logger</span><span class="p">:</span> <span class="nx">example_test</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span> <span class="nx">Hello</span><span class="p">,</span> <span class="nx">log</span> <span class="nx">file</span><span class="p">!</span>
</code></pre></td></tr></table>
</div>
</div><p>一般情况下，我们需要区分不同的日志级别：Info、Warning 和 Error，这里有一个参考实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 这个示例程序展示如何创建定制的日志记录器
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;io&#34;</span>
    <span class="s">&#34;io/ioutil&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">Trace</span>   <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span> <span class="c1">// 记录所有日志
</span><span class="c1"></span>    <span class="nx">Info</span>    <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span> <span class="c1">// 重要的信息
</span><span class="c1"></span>    <span class="nx">Warning</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span> <span class="c1">// 需要注意的信息
</span><span class="c1"></span>    <span class="nx">Error</span>   <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span> <span class="c1">// 非常严重的问题
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;errors.txt&#34;</span><span class="p">,</span>
        <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">,</span> <span class="mo">0666</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="s">&#34;Failed to open error log file:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">Trace</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span>
        <span class="s">&#34;TRACE: &#34;</span><span class="p">,</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Ldate</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Ltime</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Lshortfile</span><span class="p">)</span>

    <span class="nx">Info</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span>
        <span class="s">&#34;INFO: &#34;</span><span class="p">,</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Ldate</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Ltime</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Lshortfile</span><span class="p">)</span>

    <span class="nx">Warning</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span>
        <span class="s">&#34;WARNING: &#34;</span><span class="p">,</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Ldate</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Ltime</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Lshortfile</span><span class="p">)</span>

    <span class="nx">Error</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nf">MultiWriter</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">),</span>
        <span class="s">&#34;ERROR: &#34;</span><span class="p">,</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Ldate</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Ltime</span><span class="p">|</span><span class="nx">log</span><span class="p">.</span><span class="nx">Lshortfile</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">Trace</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;I have something standard to say&#34;</span><span class="p">)</span>
    <span class="nx">Info</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Special Information&#34;</span><span class="p">)</span>
    <span class="nx">Warning</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;There is something you need to know about&#34;</span><span class="p">)</span>
    <span class="nx">Error</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Something has failed&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">------------------------------------</span>
<span class="nx">INFO</span><span class="p">:</span> <span class="mi">2019</span><span class="o">/</span><span class="mo">04</span><span class="o">/</span><span class="mi">09</span> <span class="mi">14</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">11</span> <span class="nx">TestCustomLog</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">44</span><span class="p">:</span> <span class="nx">Special</span> <span class="nx">Information</span>
<span class="nx">ERROR</span><span class="p">:</span> <span class="mi">2019</span><span class="o">/</span><span class="mo">04</span><span class="o">/</span><span class="mi">09</span> <span class="mi">14</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">11</span> <span class="nx">TestCustomLog</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span> <span class="nx">Something</span> <span class="nx">has</span> <span class="nx">failed</span>
<span class="nx">WARNING</span><span class="p">:</span> <span class="mi">2019</span><span class="o">/</span><span class="mo">04</span><span class="o">/</span><span class="mi">09</span> <span class="mi">14</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">11</span> <span class="nx">TestCustomLog</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span> 
<span class="nx">There</span> <span class="nx">is</span> <span class="nx">something</span> <span class="nx">you</span> <span class="nx">need</span> <span class="nx">to</span> <span class="nx">know</span> <span class="nx">about</span>
</code></pre></td></tr></table>
</div>
</div><p>这里写入的目的地为 ioutil.Discard，这是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情并且始终成功返回。</p>
<p>OpenFile几个选项说明如下</p>
<ul>
<li>O_CREATE   // 如果不存在将创建一个新文件</li>
<li>O_WRONLY  // 只写模式打开文件</li>
<li>O_APPEND  // 写操作时将数据附加到文件尾部</li>
</ul>
<h2 id="2-第三方log库">2. 第三方log库</h2>
<p>比较流行且近期还在更新的日志库有 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsirupsen%2Flogrus" target="_blank" rel="noopener noreffer">logrus</a>、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fuber-go%2Fzap" target="_blank" rel="noopener noreffer">zap</a>、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Foklog%2Foklog" target="_blank" rel="noopener noreffer">oklog</a>、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Frs%2Fzerolog" target="_blank" rel="noopener noreffer">zerolog</a></p>
<p>可以考虑选择 JSON 格式的日志，参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27363484" target="_blank" rel="noopener noreffer">最佳日志实践（v2.0）</a> 一文</p>
<p>关于性能可以参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmzh.io%2Fgolang-build-tags-for-debug" target="_blank" rel="noopener noreffer">Go零消耗debug log技巧</a>，使用官方模块在生产环境中存在性能瓶颈</p>
<h2 id="3参考">3.参考</h2>
<p>[1] 合肥懒皮，简书，<a href="https://www.jianshu.com/p/73ae6dc4d16a" target="_blank" rel="noopener noreffer">Golang log日志</a>，2019.04.09</p>
<p>[2] <a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener noreffer">Go语言标准库文档</a></p>]]></description></item><item><title>Golang设置与使用cookie</title><link>https://shuzang.github.io/golang-set-and-use-cookie/</link><pubDate>Mon, 01 Jun 2020 20:11:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-set-and-use-cookie/</guid><description><![CDATA[<p>关于 Cookie 的使用是 Web 编程中的重要一部分，本篇介绍 Cookie 的基本知识和 Golang 中使用的方法。</p>
<h2 id="1-使用cookie来管理状态">1. 使用Cookie来管理状态</h2>
<p>HTTP 是无状态协议，不记录之前发生过的请求和响应，也因此无法根据历史状态信息处理当前请求。但假设我们正在浏览淘宝，然后在首页进行了登录，点击并跳转到商品页面时，因为 HTTP 的无状态特性，就需要重新进行登录，这带来了诸多不便。</p>
<p>不可否认，无状态协议有它的优点，由于不必保存状态，减少了服务器的 CPU 及内存资源消耗，同时也因为协议足够简单，才可以用到各种场景中。那么如何解决逛淘宝这种需要记录历史信息的场景呢，这里就用到 Cookie 技术。</p>
<p>Cookie 技术通过在 HTTP 请求和响应报文中写入 Cookie 信息来控制客户端的状态。首先，服务端在发送的响应报文内添加一个叫做 Set-Cookie 的首部字段信息，客户端接收到后会保存 Cookie。当下次客户端向服务器发送请求时，就会自动在请求报文中加入保存的 Cookie 值。服务器发现客户端发送过来的 Cookie 后，会检查究竟是哪个客户端发来的连接请求，然后对比服务器上的数据，得到之前的状态信息。过程如下图所示（图源为《图解HTTP》）</p>
<p></p>
<p></p>
<p>所以 Cookie 的实质是 HTTP 请求与响应报文中的一个首部字段信息，下面给出一些报文示例：</p>
<ol>
<li>
<p>请求报文（没有 Cookie 信息时的状态）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GET /reader/ HTTP/1.1
Host: hackr.jp
*首部字段内没有Cookie的相关信息
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>响应报文（服务器端生成 Cookie 信息）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞
Content-Type: text/plain; charset=UTF-8
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>请求报文（自动发送保存的 Cookie 信息）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GET /image/ HTTP/1.1
Host: hackr.jp
Cookie: sid=1342077140226724
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="2-关于cookie的首部字段">2. 关于Cookie的首部字段</h2>
<p>关于 Cookie 的相关说明没有被编入标准化 HTTP/1.1 的RFC2516中，下面介绍的是使用最广泛的 Cookie 标准。</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody>
</table>
<h3 id="21-set-cookie">2.1 Set-Cookie</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; ⇒
path=/; domain=.hackr.jp;
</code></pre></td></tr></table>
</div>
</div><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。下面的表格列举了Set-Cookie 的字段值。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td>赋予Cookie的名称和其值（必须项）</td>
</tr>
<tr>
<td>expires=DATE</td>
<td>Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=PATH</td>
<td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td>作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器域名）</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在HTTPS安全通信时才会发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使Cookie不能被JavaScript脚本访问</td>
</tr>
</tbody>
</table>
<p><strong>expires属性</strong>：有两种方法来设置过期时间：一种是直接设置 <code>Expires</code> 字段，一种是设置 <code>MaxAge</code> 字段。前者表示到期的具体时间点，后者表示 Cookie 的有效时长（单位是秒）。这并不是 Go 语言的设计，而是不同浏览器的混乱标准使然，比如虽然 HTTP/1.1 有意废弃 <code>Expires</code>，不过 IE 6、7、8 却不支持 <code>MaxAge</code> 字段。通常，考虑到默认时区问题，本地时间不可靠，推荐通过 <code>MaxAge</code> 字段设置 Cookie 过期时间，不过对于 Web 应用而言，通常不设置过期时间，让 Cookie 随着浏览器关闭而失效即可。</p>
<p><strong>domain属性</strong>：domain 属性指定的域名可做到与结尾匹配一致，比如，当指定 example.com 后，除 example.com 本身外，www.example.com 或 www2.example.com 等都可以发送 Cookie，所以，除了针对具体指定的多个域名发送Cookie之外，不指定domain属性显得更安全</p>
<p><strong>secure属性</strong>：指定 secure 属性的方法为 <code>Set-Cookie: name=value; secure</code></p>
<p><strong>HttpOnly属性</strong>：指定 HttpOnly 属性的方法为 <code>Set-Cookie: name=value; HttpOnly</code></p>
<h3 id="22-cookie">2.2 Cookie</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Cookie: status=enable
</code></pre></td></tr></table>
</div>
</div><p>在请求报文中添加该字段后，就相当于告诉服务器客户端想要获得 HTTP 状态管理支持。接收到多个Cookie时，同样可以以多个Cookie形式发送。</p>
<h2 id="3-session-管理">3. Session 管理</h2>
<p>某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见，为达到这个目标，需要添加认证功能。HTTP/1.1 实用的认证包括 BASIC认证、DIGEST认证、SSL客户端认证、FormBase认证等，由于使用上的便利性和安全性问题，前两种几乎不适用，SSL客户端认证则由于导入及费用问题未得到普及，目前常用的是最后一种：基于表单的认证。</p>
<p>基于表单的认证方法并不是在HTTP协议中定义的，而是由客户端通过表单向服务器提交登录信息，然后由服务器安装自定义的实现方式进行验证，不同的应用使用的验证方式多有不同，但多数情况下，是基于用户输入的用户ID（通常是任意字符串或邮件地址）和密码等登录信息进行认证。</p>
<p>鉴于 HTTP 是无状态协议，之前已认证成功额用户状态无法保留，因此一般使用 Cookie 来管理 Session(会话)。</p>
<p></p>
<p>如上图所示，基本的步骤为</p>
<ol>
<li>客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。</li>
<li>服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSID=028a8c…）。你可以把Session ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性。</li>
<li>客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。</li>
</ol>
<p>需要注意，上述介绍并不是唯一的实现方式，实际上，不仅基于表单认证的登录信息及认证过程没有标准化，服务端如何保持密码等登录信息也没有标准化。通常，一种安全的保存方法是，先利用给密码加盐（salt）的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。</p>
<h2 id="4-go中cookie的设置与读取">4. Go中Cookie的设置与读取</h2>
<h3 id="41-设置cookie">4.1 设置Cookie</h3>
<p>Go语言中通过 net/http 包中的 SetCookie 来设置 Cookie：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">cookie</span> <span class="o">*</span><span class="nx">Cookie</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>w 表示需要写入的 response，cookie 是一个 struct，让我们来看看对象是怎样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cookie</span> <span class="nx">str</span><span class="err">、</span><span class="nx">uct</span> <span class="p">{</span>
    <span class="nx">Name</span>        <span class="kt">string</span>
    <span class="nx">Value</span>       <span class="kt">string</span>
    <span class="nx">Path</span>        <span class="kt">string</span>
    <span class="nx">Domain</span>      <span class="kt">string</span>
    <span class="nx">Expires</span>     <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">RawExpires</span>  <span class="kt">string</span>
    <span class="c1">// MaxAge=0 意味着没有指定 Max-Age 的值
</span><span class="c1"></span>    <span class="c1">// MaxAge&lt;0 意味着现在就删除 Cookie，等价于 Max-Age=0
</span><span class="c1"></span>    <span class="c1">// MaxAge&gt;0 意味着 Max-Age 属性存在并以秒为单位存在
</span><span class="c1"></span>    <span class="nx">MaxAge</span>      <span class="kt">int</span>
    <span class="nx">Secure</span>      <span class="kt">bool</span>
    <span class="nx">HttpOnly</span>    <span class="kt">bool</span>
    <span class="nx">Raw</span>         <span class="kt">string</span>
    <span class="nx">Unparsed</span>    <span class="p">[]</span><span class="kt">string</span> <span class="c1">// 未解析的 attribute-value 属性位对
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面来看一个如何设置 Cookie 的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">expiration</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
<span class="nx">expiration</span> <span class="o">:=</span> <span class="nx">expiration</span><span class="p">.</span><span class="nf">AddDate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">cookie</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span>
    <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;username&#34;</span><span class="p">,</span> 
    <span class="nx">Value</span><span class="p">:</span> <span class="s">&#34;zuolan&#34;</span><span class="p">,</span> 
    <span class="nx">Expires</span><span class="p">:</span> <span class="nx">expiration</span>
<span class="p">}</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">writer</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">Cookie</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="42-读取-cookie">4.2 读取 Cookie</h3>
<p>上面的例子演示了如何设置 Cookie 数据，这里演示如何读取 Cookie：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">cookie</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Cookie</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">cookie</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>还有另外一种读取方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cookie</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Cookies</span><span class="p">()</span> <span class="p">{</span>    
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">cookie</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到通过 request 获取 Cookie 非常方便。</p>
<h2 id="参考">参考</h2>
<ol>
<li>上野宣[日]，<a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener noreffer">图解HTTP</a>，人民邮电出版社，2014</li>
<li>学院君，<a href="https://xueyuanjun.com/post/21668" target="_blank" rel="noopener noreffer">在 Go 语言中设置、读取和删除 HTTP Cookie</a>，2020</li>
</ol>]]></description></item><item><title>Golang模板</title><link>https://shuzang.github.io/golang-template/</link><pubDate>Fri, 29 May 2020 17:08:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-template/</guid><description><![CDATA[<p>模板就是在写动态页面时不变的部分，服务端程序渲染可变部分生成动态网页，Go 语言提供了 html/template 包来支持模板渲染。</p>
<h2 id="1-基本语法">1. 基本语法</h2>
<p>模板的基本语法来自于 text/template 包，与大多数语言一样，用 <code>{{</code> 和 <code>}}</code> 来做标识，<code>{{ }}</code> 里可以是表达式，也可以是变量</p>
<h3 id="11-变量">1.1 变量</h3>
<p>模板中的变量通过{{.}} 来访问。Golang渲染template的时候，可以在模板文件中读取变量内的值并渲染到模板里。有两个常用的传入类型。一是struct，在模板内可以读取该struct的内容。二是map[string]interface{}，在模板内可以使用key来进行渲染。</p>
<p>以结构体为例，假设初始化了一个结构体 User</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">UserId</span> <span class="kt">int</span>
    <span class="nx">Username</span> <span class="kt">string</span>
    <span class="nx">Age</span> <span class="kt">uint</span>
    <span class="nx">Sex</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="nx">user</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;Steven&#34;</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="s">&#34;男&#34;</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>模板获取数据的方式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{.}}{{.Username}}{{.UserId}}{{.Age}}{{.Sex}}
</code></pre></td></tr></table>
</div>
</div><p>那么渲染后的模板内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span><span class="mi">1</span> <span class="nx">Steven</span> <span class="mi">35</span> <span class="nx">男</span><span class="p">}</span><span class="nx">Steven135男</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以在模板中定义变量，初始化后就可以进行调用，如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{$MyUserName := &#34;StevenWang&#34;}}
{{$MyUserName}}
</code></pre></td></tr></table>
</div>
</div><h3 id="12-逻辑判断">1.2 逻辑判断</h3>
<p>Golang 模板支持 if 条件判断，当前支持最简单的 bool 类型和 string 类型，定义方式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{if .confition}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>当.condition是bool类型时，值为true表示执行。当.condition是string类型时，值非空表示执行。加入 else 时，形式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{if .confition}}
{{else}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>此模板也支持if…else if嵌套，定义方式如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{if .confition}}
{{else if .confition}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>Golang的模板提供了一些内置的模板函数来执行逻辑判断，下面列举目前常用的一些内置模板函数</p>
<table>
<thead>
<tr>
<th>函数语法</th>
<th>函数作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>{{if not .condition}}<br>{{end}}</td>
<td>not 非</td>
</tr>
<tr>
<td>{{if and .condition1 .condition2}}<br>{{end}}</td>
<td>and 与</td>
</tr>
<tr>
<td>{{if or .condition1 .condition2}}<br>{{end}}</td>
<td>or 或</td>
</tr>
<tr>
<td>{{if eq .var1 .var2}}<br>{{end}}</td>
<td>eq 等于</td>
</tr>
<tr>
<td>{{if ne .var1 .var2}}<br>{{end}}</td>
<td>ne 不等于</td>
</tr>
<tr>
<td>{{if lt .var1 .var2}}<br>{{end}}</td>
<td>lt 小于</td>
</tr>
<tr>
<td>{{if le .var1 .var2}}<br/>{{end}}</td>
<td>le 小于等于</td>
</tr>
<tr>
<td>{{if gt .var1 .var2}}<br/>{{end}}</td>
<td>gt 大于</td>
</tr>
<tr>
<td>{{if ge .var1 .var2}}<br/>{{end}}</td>
<td>ge 大于等于</td>
</tr>
</tbody>
</table>
<p>假设在 Go 程序中定义了一个map，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">locals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
<span class="nx">locals</span><span class="p">[</span><span class="s">&#34;username1&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;Steven&#34;</span>
<span class="nx">locals</span><span class="p">[</span><span class="s">&#34;username2&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;Daniel&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>在模板文件中进行逻辑判断如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{if eq .username .user}}
	OK:账号名称一致
{{else if ne .username .user}}
	Err:账号名称不一致
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>逻辑判断也可以使用 with 作为关键词</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{with .condition}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>或者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{with .condition}}
{{else}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><h3 id="13-循环遍历">1.3 循环遍历</h3>
<p>Golang 的模板支持 range 循环来遍历 map、slice中的内容，语法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{range $index, $value := .slice}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>在这个range循环内，遍历数据通过<code>$index</code>和 <code>$value</code>来实现。还有一种遍历方式，语法格式如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{range .slice}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>这种方式无法访问到<code>$index</code>和<code>$key</code>的值，需要通过{{.}}来访问对应的$value。这种情况下，在循环体内，外部变量需要使用{{$.}}来访问。</p>
<p>模板文件的示例代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{range $index, $value := .filelist}}
  <span class="p">&lt;</span><span class="nt">figure</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/html/upload/{{$value}}&#34;</span><span class="p">&gt;&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;/html/upload/{{$value}}&#34;</span><span class="p">/&gt;&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">figcaption</span><span class="p">&gt;</span>
      {{$value}} <span class="p">&lt;</span><span class="nt">br</span><span class="p">/&gt;</span>
          <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/delete?id={{$value}}&#34;</span><span class="p">&gt;</span>[删除]<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> {{$.username}}上传
      <span class="p">&lt;/</span><span class="nt">figcaption</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">figure</span><span class="p">&gt;</span>
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>循环也有 else 语句，如果作为循环条件的数组、切片、映射或通道长度为0，就执行 else 后的语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{range .slice}}
{{else}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><h3 id="14-模板嵌套">1.4 模板嵌套</h3>
<p>在编写模板的时候，经常需要将公用的模板进行整合，比如每一个页面都有导航栏和页脚，通常的做法是将其编写为一个单独的模块，让所有的页面进行导入，这样就不用重复编写了。</p>
<p>任何网页都有一个主模板，然后可以在主模板内嵌入子模板来实现模块共享。当模板想要引入子模板时，通常使用如下语句</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{template &#34;navbar&#34;}}
</code></pre></td></tr></table>
</div>
</div><p>这样就会载入名为 navbar 的子模版，同时，我们需要定义 navbar 子模版的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{define &#34;navbar&#34;}}
{{end}}
</code></pre></td></tr></table>
</div>
</div><p>在定义中间的内容最终会替代源文件中的 {{template &ldquo;navbar&rdquo;}} 这一条语句</p>
<p>如果想要子模板获得父模板的变量，使用如下方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">{{template &#34;navbar&#34; .}}
</code></pre></td></tr></table>
</div>
</div><h2 id="2-模板函数">2. 模板函数</h2>
<p>上面的语法一般情况都是定义在前端文件中的，要对模板进行处理，html/template 还提供了一系列函数。</p>
<p>一个简单的例子如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;text/template&#34;</span>
<span class="o">...</span>
<span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">).</span><span class="nf">Parse</span><span class="p">(</span><span class="s">`</span><span class="cp">{{</span><span class="nx">define</span><span class="w"> </span><span class="s">&#34;T&#34;</span><span class="cp">}}</span><span class="s">Hello, </span><span class="cp">{{</span><span class="na">.</span><span class="cp">}}</span><span class="s">!</span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">`</span><span class="p">)</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="s">&#34;T&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;script&gt;alert(&#39;you have been pwned&#39;)&lt;/script&gt;&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>涉及到的几个函数分别是 New，Parse 和 ExecuteTemplate，解释如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个名为name的模板
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Template</span>  
<span class="c1">// Parse方法将字符串text解析为模板
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">src</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Template</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="c1">// 将解析好的模板应用到data上，使用名为name的t关联的模板产生输出。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">wr</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>所以 New 和 Parse 创建一个模板并将字符串解析到该模板，但实际使用时模板文件通常是单独的，这时一般使用 Must 和 ParseFiles 函数。</p>
<p>ParseFiles方法解析filenames指定的文件里的模板定义并将解析结果与t关联。如果发生错误，会停止解析并返回nil，否则返回(t, nil)。至少要提供一个文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">ParseFiles</span><span class="p">(</span><span class="nx">filenames</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Template</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到 ParseFiles 返回 (*Template, error)，Must 函数正好用来封装这种返回形式的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Must</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="o">*</span><span class="nx">Template</span>
</code></pre></td></tr></table>
</div>
</div><p>它会在 err 非 nil 时 panic，一般用于变量初始化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">t</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">).</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;html&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>另外，ExecuteTemplate 将输出指定到名为 name 的模板上，但还有一种简单形式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">Execute</span><span class="p">(</span><span class="nx">wr</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Execute方法将解析好的模板应用到data上，并将输出写入wr，唯一的区别就是没有绑定模板。</p>]]></description></item><item><title>Golang使用gorilla、mux包</title><link>https://shuzang.github.io/golang-use-gorilla/mux-package/</link><pubDate>Fri, 29 May 2020 13:38:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-use-gorilla/mux-package/</guid><description><![CDATA[<p>本文介绍 <a href="https://github.com/gorilla/mux" target="_blank" rel="noopener noreffer">gorilla/mux</a> 包的使用。</p>
<p>我们已知 Go 标准库 net/http 提供的默认路由是 DefaultServeMux，虽然简单易上手，但存在很多不足，比如</p>
<ul>
<li>不支持参数设定，例如 <code>/user/:uid</code> 这种泛类型匹配；</li>
<li>对 REST 风格接口支持不友好，无法限制访问路由的方法；</li>
<li>对于拥有很多路由规则的应用，编写大量路由规则非常繁琐。</li>
</ul>
<p>为此，我们可以使用第三方库 <code>gorilla/mux</code> 提供的更加强大的路由处理器（<code>mux</code> 代表 <code>HTTP request multiplexer</code>，即 HTTP 请求多路复用器），和 <code>http.ServeMux</code> 实现原理一样，<code>gorilla/mux</code> 提供的路由器实现类 <code>mux.Router</code> 也会匹配用户请求与系统注册的路由规则，然后将用户请求转发过去。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Router</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Configurable Handler to be used when no route matches.
</span><span class="c1"></span>	<span class="nx">NotFoundHandler</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
	<span class="c1">// Configurable Handler to be used when the request method does not match the route.
</span><span class="c1"></span>	<span class="nx">MethodNotAllowedHandler</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span>
	<span class="c1">// Routes to be matched, in order.
</span><span class="c1"></span>	<span class="nx">routes</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Route</span>
	<span class="c1">// Routes by name for URL building.
</span><span class="c1"></span>	<span class="nx">namedRoutes</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Route</span>
	<span class="c1">// If true, do not clear the request context after handling the request.
</span><span class="c1"></span>	<span class="c1">// Deprecated: No effect, since the context is stored on the request itself.
</span><span class="c1"></span>	<span class="nx">KeepContext</span> <span class="kt">bool</span>
	<span class="c1">// Slice of middlewares to be called after a match is found
</span><span class="c1"></span>	<span class="nx">middlewares</span> <span class="p">[]</span><span class="nx">middleware</span>
	<span class="c1">// configuration shared with `Route`
</span><span class="c1"></span>	<span class="nx">routeConf</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>mux.Router</code> 主要具备以下特性：</p>
<ul>
<li>实现了 <code>http.Handler</code> 接口，所以和 <code>http.ServeMux</code> 完全兼容；</li>
<li>可以基于 URL 主机、路径、前缀、scheme、请求头、请求参数、请求方法进行路由匹配；</li>
<li>URL 主机、路径、查询字符串支持可选的正则匹配；</li>
<li>支持构建或反转已注册的 URL 主机，以便维护对资源的引用；</li>
<li>支持路由嵌套，以便不同路由可以共享通用条件，比如主机、路径前缀等。</li>
</ul>
<h2 id="1-使用入门">1. 使用入门</h2>
<p>运行如下命令进行安装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go get -u github.com/gorilla/mux
</code></pre></td></tr></table>
</div>
</div><p>一个简单的示例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">()</span>
    <span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">HomeHandler</span><span class="p">)</span>
    <span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/products&#34;</span><span class="p">,</span> <span class="nx">ProductsHandler</span><span class="p">)</span>
    <span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/articles&#34;</span><span class="p">,</span> <span class="nx">ArticlesHandler</span><span class="p">)</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>main</code> 函数中的第一行显式初始化了 <code>mux.Router</code> 作为路由器，然后在这个路由器中注册路由规则，最后将这个路由器传入 <code>http.ListenAndServe</code> 方法，整个调用过程和之前并无二致，因为<code>mux.Router</code> 也实现了 <code>Handler</code> 接口。</p>
<p>路径中可以包含变量。变量的定义形式为 <code>{name}</code> 或 <code>{name:pattern}</code>，只能是小写字母，不支持其它字符，同时，name 可以是正则表达式，如下面的例子所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">()</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/products/{key}&#34;</span><span class="p">,</span> <span class="nx">ProductHandler</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/articles/{category}/&#34;</span><span class="p">,</span> <span class="nx">ArticlesCategoryHandler</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/articles/{category}/{id:[0-9]+}&#34;</span><span class="p">,</span> <span class="nx">ArticleHandler</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>相应地，在闭包处理函数中，我们使用 <code>mux.Vars()</code> 解析路由参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ArticlesCategoryHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">vars</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">Vars</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Category: %v\n&#34;</span><span class="p">,</span> <span class="nx">vars</span><span class="p">[</span><span class="s">&#34;category&#34;</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-路由代码拆分">2. 路由代码拆分</h2>
<p>比较简单的情况下，所有的路由、处理器都放在应用入口文件中，一般是 main.go，但如果项目比较大，甚至仅仅是博客这种级别的项目，就要处理文章、用户、图片等众多资源，所以我们需要针对这种情况进行一定的优化。</p>
<p>优化的办法就是将路由器与控制器分离，为了使代码结构更加清晰明了，我们把服务器、路由器、路由定义、处理器方法全都拆分开。</p>
<h3 id="21-路由器">2.1 路由器</h3>
<p>我们在项目根目录下新建 <code>routes</code> 目录用来存放路由定义及实现。</p>
<p>首先在 <code>routes</code> 目录下创建 <code>routes.go</code> 存放路由定义，文件内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routes</span>

<span class="kn">import</span> <span class="s">&#34;net/http&#34;</span>

<span class="c1">// 定义一个 WebRoute 结构体用于存放单个路由
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">WebRoute</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span>        <span class="kt">string</span>
    <span class="nx">Method</span>      <span class="kt">string</span>
    <span class="nx">Pattern</span>     <span class="kt">string</span>
    <span class="nx">HandlerFunc</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span>
<span class="p">}</span>

<span class="c1">// 声明 WebRoutes 切片存放所有 Web 路由
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">WebRoutes</span> <span class="p">[]</span><span class="nx">WebRoute</span>

<span class="c1">// 定义所有 Web 路由
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">webRoutes</span> <span class="p">=</span> <span class="nx">WebRoutes</span><span class="p">{</span>
    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里，我们定义了一个 <code>WebRoute</code> 结构体来表示单个路由，其中包含了路由名称、请求方法、匹配字符串模式、以及对应的处理器方法，路由器可以根据这些配置请求请求分发。</p>
<p>然后定义了一个 <code>WebRoutes</code> 切片来存放所有 <code>WebRoute</code> 类型的路由，最后初始化这个切片为空，表示还没有定义任何路由。</p>
<p>接下来，在 <code>routes</code> 目录下创建 <code>router.go</code> 用来编写路由器实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routes</span>

<span class="kn">import</span> <span class="s">&#34;github.com/gorilla/mux&#34;</span>

<span class="c1">// 返回一个 mux.Router 类型指针，从而可以当作处理器使用
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">mux</span><span class="p">.</span><span class="nx">Router</span> <span class="p">{</span>

    <span class="c1">// 创建 mux.Router 路由器示例
</span><span class="c1"></span>    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">().</span><span class="nf">StrictSlash</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>

    <span class="c1">// 遍历 web.go 中定义的所有 webRoutes
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">route</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">webRoutes</span> <span class="p">{</span>
        <span class="c1">// 将每个 web 路由应用到路由器
</span><span class="c1"></span>        <span class="nx">router</span><span class="p">.</span><span class="nf">Methods</span><span class="p">(</span><span class="nx">route</span><span class="p">.</span><span class="nx">Method</span><span class="p">).</span>
            <span class="nf">Path</span><span class="p">(</span><span class="nx">route</span><span class="p">.</span><span class="nx">Pattern</span><span class="p">).</span>
            <span class="nf">Name</span><span class="p">(</span><span class="nx">route</span><span class="p">.</span><span class="nx">Name</span><span class="p">).</span>
            <span class="nf">Handler</span><span class="p">(</span><span class="nx">route</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">router</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>StrictSlash 定义斜杠尾随行为，意思是，传入 true 时，如果路由路径是 <code>/path</code> 这种形式，将重定向到 <code>/path/</code>  ，反之亦然。传入 false 时，不会重定向，这两种情况不会看作一种。</p>
<p>Methods，Path，Name，Handler分别用来限定请求方法、匹配字符串模式、路由名和处理器方法。通过这种方式，我们将 routes.go 中定义的所有 Web 路由都应用到了使用 mux.NewRouter 创建的路由器，以便可以处理用户请求的路由匹配和分发。</p>
<h3 id="22-服务器">2.2 服务器</h3>
<p>在入口文件 main.go 中使用如下方法启动服务器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
     <span class="p">.</span> <span class="s">&#34;github.com/shuzang/projectname/routes&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
    <span class="nf">startWebServer</span><span class="p">(</span><span class="s">&#34;8080&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">startWebServer</span><span class="p">(</span><span class="nx">port</span> <span class="kt">string</span><span class="p">)</span>  <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nf">NewRouter</span><span class="p">()</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>

    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Starting HTTP service at &#34;</span> <span class="o">+</span> <span class="nx">port</span><span class="p">)</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">port</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// Goroutine will block here
</span><span class="c1"></span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;An error occured starting HTTP listener at port &#34;</span> <span class="o">+</span> <span class="nx">port</span><span class="p">)</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error: &#34;</span> <span class="o">+</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们将 Web 服务器启动逻辑封装到 <code>startWebServer</code> 方法中实现，该方法需要传入端口参数。在具体实现时，我们调用了 <code>routes/router.go</code> 中定义的 <code>NewRouter</code> 方法，将其返回值作为处理器传入 <code>http.Handle</code> 方法，最后调用 <code>http.ListenAndServe</code> 启动 Web 服务器并监听传入的端口号。</p>
<p>最后在 <code>main</code> 方法中调用 <code>startWebServer</code> 方法即可。</p>
<h3 id="23-处理器">2.3 处理器</h3>
<p>上层代码写完后，现在定义处理器方法。在项目根目录下新建 <code>handlers</code> 目录存放处理器方法，这里举 2 个示例，分别定义在 <code>common.go</code> 和 <code>user.go</code> 两个文件中，用来处理通用请求和用户资源。</p>
<p>首先在 <code>common.go</code> 中编写首页请求处理器方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">handlers</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;io&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Home</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>  <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Welcome to my site&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在 <code>user.go</code> 中定义获取指定用户对应处理器方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">handlers</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gorilla/mux&#34;</span>
    <span class="s">&#34;io&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">GetUser</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>  <span class="p">{</span>
    <span class="c1">// Get user from DB by id...
</span><span class="c1"></span>    <span class="nx">params</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">Vars</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">params</span><span class="p">[</span><span class="s">&#34;id&#34;</span><span class="p">]</span>
    <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Return user info with id = &#34;</span> <span class="o">+</span> <span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这时要记得，<code>routes/routes.go</code> 中的路由切片还是空的，用实现的处理器填充它</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">webRoutes</span> <span class="p">=</span> <span class="nx">WebRoutes</span><span class="p">{</span>
    <span class="nx">WebRoute</span><span class="p">{</span>
        <span class="s">&#34;Home&#34;</span><span class="p">,</span>
        <span class="s">&#34;GET&#34;</span><span class="p">,</span>
        <span class="s">&#34;/&#34;</span><span class="p">,</span>
        <span class="nx">handlers</span><span class="p">.</span><span class="nx">Home</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">WebRoute</span><span class="p">{</span>
        <span class="s">&#34;User&#34;</span><span class="p">,</span>
        <span class="s">&#34;GET&#34;</span><span class="p">,</span>
        <span class="s">&#34;/user/{id}&#34;</span><span class="p">,</span>
        <span class="nx">handlers</span><span class="p">.</span><span class="nx">GetUser</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-路由匹配规则">3. 路由匹配规则</h2>
<p>第一部分的路由匹配规则只是简单介绍，实际上，gorilla/mux 实现的匹配规则非常强大。</p>
<h3 id="31-常用匹配规则">3.1 常用匹配规则</h3>
<p><strong>限定请求方法</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/books/{title}&#34;</span><span class="p">,</span> <span class="nx">CreateBook</span><span class="p">).</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;POST&#34;</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/books/{title}&#34;</span><span class="p">,</span> <span class="nx">ReadBook</span><span class="p">).</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/books/{title}&#34;</span><span class="p">,</span> <span class="nx">UpdateBook</span><span class="p">).</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;PUT&#34;</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/books/{title}&#34;</span><span class="p">,</span> <span class="nx">DeleteBook</span><span class="p">).</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;DELETE&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>限定主机名或子域名</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/books/{title}&#34;</span><span class="p">,</span> <span class="nx">BookHandler</span><span class="p">).</span><span class="nf">Host</span><span class="p">(</span><span class="s">&#34;www.mybookstore.com&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>限定 Scheme</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/secure&#34;</span><span class="p">,</span> <span class="nx">SecureHandler</span><span class="p">).</span><span class="nf">Schemes</span><span class="p">(</span><span class="s">&#34;https&#34;</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/insecure&#34;</span><span class="p">,</span> <span class="nx">InsecureHandler</span><span class="p">).</span><span class="nf">Schemes</span><span class="p">(</span><span class="s">&#34;http&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>限定前缀和子路由</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">bookrouter</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">PathPrefix</span><span class="p">(</span><span class="s">&#34;/books&#34;</span><span class="p">).</span><span class="nf">Subrouter</span><span class="p">()</span>
<span class="nx">bookrouter</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">AllBooks</span><span class="p">)</span>
<span class="nx">bookrouter</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/{title}&#34;</span><span class="p">,</span> <span class="nx">GetBook</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>限定请求参数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/request/header&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">header</span> <span class="o">:=</span> <span class="s">&#34;X-Requested-With&#34;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;包含指定请求头[%s=%s]&#34;</span><span class="p">,</span> <span class="nx">header</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">[</span><span class="nx">header</span><span class="p">])</span>
<span class="p">}).</span><span class="nf">Headers</span><span class="p">(</span><span class="s">&#34;X-Requested-With&#34;</span><span class="p">,</span> <span class="s">&#34;XMLHttpRequest&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="32-自定义匹配规则">3.2 自定义匹配规则</h3>
<p><code>gorilla/mux</code> 路由支持通过 <code>MatcherFunc</code> 方法自定义路由匹配规则，在该方法中，可以获取到请求实例 <code>request</code>，这样我们就可以拿到所有的用户请求信息，并对其进行判断，符合我们预期的请求才能匹配并访问该方法应用到的路由。</p>
<p>比如下面这个示例，我们限定只有来自 <code>https://baidu.com</code> 域名的请求才可以匹配到 <code>/custom/matcher</code> 路由</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/custom/matcher&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;请求来自指定域名: %s&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Referer</span><span class="p">())</span>
<span class="p">}).</span><span class="nf">MatcherFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">request</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">match</span> <span class="o">*</span><span class="nx">mux</span><span class="p">.</span><span class="nx">RouteMatch</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">request</span><span class="p">.</span><span class="nf">Referer</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;https://baidu.com&#34;</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="33-路由命名">3.3 路由命名</h3>
<p>通过 <code>Name</code> 方法在路由规则中指定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">postRouter</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">PathPrefix</span><span class="p">(</span><span class="s">&#34;/posts&#34;</span><span class="p">).</span><span class="nf">Subrouter</span><span class="p">()</span>
<span class="nx">postRouter</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">listPosts</span><span class="p">).</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;posts.index&#34;</span><span class="p">)</span>
<span class="nx">postRouter</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/create&#34;</span><span class="p">,</span> <span class="nx">createPost</span><span class="p">).</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;POST&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;posts.create&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="4-路由中间件">4. 路由中间件</h2>
<h2 id="5-处理静态资源响应">5. 处理静态资源响应</h2>
<p>使用默认<code>http</code>包处理静态资源的方法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fs</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;assets/&#34;</span><span class="p">))</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/static/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;/static/&#34;</span><span class="p">,</span> <span class="nx">fs</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 gorilla/mux 时，处理方法很相似</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span> <span class="o">:=</span> <span class="nf">NewRouter</span><span class="p">()</span> <span class="c1">// 通过 router.go 中定义的路由器来分发请求
</span><span class="c1"></span>
<span class="nx">assets</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;public&#34;</span><span class="p">))</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">PathPrefix</span><span class="p">(</span><span class="s">&#34;/static/&#34;</span><span class="p">).</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;/static/&#34;</span><span class="p">,</span> <span class="nx">assets</span><span class="p">))</span>

<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="c1">// 应用路由器到 HTTP 服务器
</span><span class="c1"></span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然 <code>gorilla/mux</code> 路由器提供了对静态资源的支持，但是通常我们还是会基于 Nginx 来处理静态资源，然后将动态请求转发给 Go HTTP 服务器，因为 Nginx 作为一款强大的反向代理服务器，并发处理静态资源的能力非常强悍，没必要自己去处理这块逻辑。</p>]]></description></item><item><title>Golang启动HTTP服务器</title><link>https://shuzang.github.io/golang-start-http-server/</link><pubDate>Fri, 29 May 2020 09:32:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-start-http-server/</guid><description><![CDATA[<p>本文介绍 Golang 如何实现 HTTP 服务端及客户端。</p>
<h2 id="1-http协议客户端实现">1. HTTP协议客户端实现</h2>
<p>Go语言标准库内置了net/http包，涵盖了HTTP客户端和服务端具体的实现方式。内置的net/http包提供了最简洁的HTTP客户端实现方式，无须借助第三方网络通信库，就可以直接使用HTTP中用得最多的GET和POST方式请求数据。</p>
<p>实现HTTP客户端就是客户端通过网络访问向服务端发送请求，服务端发送响应信息，并将相应信息输出到客户端的过程。实现客户端有多种方式，具体如下所示。</p>
<h3 id="11-使用httpnewrequest方法">1.1 使用http.NewRequest()方法</h3>
<p>首先创建一个client（客户端）对象，其次创建一个request（请求）对象，最后使用client发送request。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">testHttpNewRequest</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testHttpNewRequest</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//1.创建一个客户端
</span><span class="c1"></span>	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
	<span class="c1">//2.创建一个请求，请求方式可以是GET或POST
</span><span class="c1"></span>	<span class="nx">request</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;http://www.baidu.com&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="c1">//3.客户端发送请求
</span><span class="c1"></span>	<span class="nx">cookName</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;username&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="s">&#34;Steven&#34;</span><span class="p">}</span>

	<span class="c1">//添加cookie
</span><span class="c1"></span>	<span class="nx">request</span><span class="p">.</span><span class="nf">AddCookie</span><span class="p">(</span><span class="nx">cookName</span><span class="p">)</span>
	<span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
	<span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="c1">//设置请求头
</span><span class="c1"></span>	<span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Accept-Lanauage&#34;</span><span class="p">,</span> <span class="s">&#34;zh-cn&#34;</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">response</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="c1">//查看请求头的数据
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Header:%+v\n&#34;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;响应状态码: %v\n&#34;</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>

	<span class="c1">//4.操作数据
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">response</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;网络请求成功&#34;</span><span class="p">)</span>
		<span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;网络请求失败&#34;</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//检查错误
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ins</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">().(</span><span class="kt">error</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序出现异常: &#34;</span><span class="p">,</span> <span class="nx">ins</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
Header:map<span class="o">[</span>Accept-Lanauage:<span class="o">[</span>zh-cn<span class="o">]</span> Cookie:<span class="o">[</span><span class="nv">username</span><span class="o">=</span>Steven<span class="o">]]</span>
响应状态码: <span class="m">200</span>
网络请求成功 
</code></pre></td></tr></table>
</div>
</div><h3 id="12-调用clientget-方法">1.2 调用client.Get() 方法</h3>
<p>这种方法总共两个步骤，先创建一个client（客户端）对象，然后使用client调用Get()方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">testClientGet</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testClientGet</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//1.创建一个客户端
</span><span class="c1"></span>	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
	<span class="c1">//2.通过client请求
</span><span class="c1"></span>	<span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;http://www.baidu.com&#34;</span><span class="p">)</span>
	<span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;响应状态码: %v\n&#34;</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">response</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;网络请求成功&#34;</span><span class="p">)</span>
		<span class="k">defer</span> <span class="nx">response</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//检查错误
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ins</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">().(</span><span class="kt">error</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序出现异常: &#34;</span><span class="p">,</span> <span class="nx">ins</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>运行结果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
响应状态码: <span class="m">200</span>
网络请求成功
</code></pre></td></tr></table>
</div>
</div><h3 id="13-使用clientpost或clientpostform方法">1.3 使用client.Post()或client.PostForm()方法</h3>
<p>这种方法也是两个步骤，先创建一个client（客户端）对象，然后使用client调用Post()或PostForm()方法。其实client的Post()或PostForm()方法，就是对http.NewRequest()的封装。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="s">&#34;http://example.com/upload&#34;</span><span class="p">,</span> <span class="s">&#34;image/jpeg&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">buf</span><span class="p">)</span>
<span class="o">...</span>
<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;http://example.com/form&#34;</span><span class="p">,</span>
	<span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">{</span><span class="s">&#34;key&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;Value&#34;</span><span class="p">},</span> <span class="s">&#34;id&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;123&#34;</span><span class="p">}})</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="14-使用httpget-方法">1.4 使用http.Get() 方法</h3>
<p>这种方式只有一个步骤，http的Get()方法就是对DefaultClient.Get()的封装。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">testHttpGet</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testHttpGet</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//获取服务器数据
</span><span class="c1"></span>	<span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;http://www.baidu.com&#34;</span><span class="p">)</span>
	<span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;响应状态码: %v\n&#34;</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">response</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;网络请求成功&#34;</span><span class="p">)</span>
		<span class="k">defer</span> <span class="nx">response</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;请求失败&#34;</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//检查错误
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkErr</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ins</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">().(</span><span class="kt">error</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序出现异常: &#34;</span><span class="p">,</span> <span class="nx">ins</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>运行结果为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
响应状态码: <span class="m">200</span>
网络请求成功
</code></pre></td></tr></table>
</div>
</div><h3 id="15-使用httppost或httppostform方法">1.5 使用http.Post()或http.PostForm()方法</h3>
<p>http的Post()函数或PostForm()，就是对DefaultClient.Post()或DefaultClient.PostForm()的封装。这种方法也只需要一个步骤</p>
<h2 id="2-http协议服务端实现">2. HTTP协议服务端实现</h2>
<p>使用Go语言标准库内置的net/http包，就可以实现一个基本的HTTP服务端。一个基本的HTTP服务器主要应完成如下功能</p>
<ol>
<li>处理动态请求：处理浏览网站，登录帐户或发布图片等用户传入的请求。</li>
<li>提供静态文件：将JavaScript，CSS和图像等静态文件提供给浏览器，服务于用户。</li>
<li>接受连接请求：HTTP服务器必须监听指定端口从而接收来自网络的连接请求。</li>
</ol>
<h3 id="21-处理动态请求">2.1 处理动态请求</h3>
<p>我们可以使用<code>http.HandleFunc</code>函数注册一个新的 Handler 来处理动态请求。它的第一个参数是请求路径的匹配模式，第二个参数是一个函数类型，表示针对这个请求要执行的功能。下例中针对请求返回一个欢迎访问的提示语。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Welcome to my website!&#34;</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p><code>http.ResponseWriter</code>类型包含了服务器端给客户端的响应数据。服务器端往里面写入了什么内容，浏览器的网页源码就是什么内容。<code>*http.Request</code>包含了客户端发送给服务器端的请求信息（路径、浏览器类型等）。</p>
<h3 id="22-提供静态文件">2.2 提供静态文件</h3>
<p>使用<code>http.FileServer()</code> 方法提供 Javascript，CSS或图片等静态文件。它的参数是文件系统接口，可以使用<code>http.Dir()</code>来指定文件所在的路径。如果该路径中有index.html文件，则会优先显示html文件，否则会显示文件目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fs</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;static/&#34;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><code>http.FileServer()</code>的返回值正好是 Handler 类型，也就是可以提供文件访问服务的HTTP处理器。现在，我们只需要将一个URL指向它，期间我们可以使用<code>http.StripPrefix()</code> 去除某些URL前缀，返回值同样是一个 Handler类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/static/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;/static/&#34;</span><span class="p">,</span> <span class="nx">fs</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="23-接收连接请求">2.3 接收连接请求</h3>
<p><code>http.ListenAndServer()</code>函数用来启动HTTP服务器，并且在指定的 IP 地址和端口上监听客户端请求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:80&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>函数实现如下，其中第一个参数为监听地址，第二个参数表示一个HTTP处理器 Handler。可以看到，底层调用的是 <code>net/http</code> 包的 <code>ListenAndServe</code> 方法，首先会初始化一个 <code>Server</code> 对象，然后调用该 <code>Server</code> 实例的 <code>ListenAndServe</code> 方法，进而调用 <code>net.Listen(&quot;tcp&quot;, addr)</code>，也就是基于 TCP 协议创建 Listen Socket，并在传入的IP 地址和端口号上监听请求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span><span class="nx">Addr</span><span class="p">:</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">:</span> <span class="nx">handler</span><span class="p">}</span>
	<span class="k">return</span> <span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">ListenAndServe</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">shuttingDown</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrServerClosed</span>
	<span class="p">}</span>
	<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">Addr</span>
	<span class="k">if</span> <span class="nx">addr</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">addr</span> <span class="p">=</span> <span class="s">&#34;:http&#34;</span>
	<span class="p">}</span>
	<span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">ln</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最终我们看到调用了  <code>Server</code> 实例的 <code>Serve(net.Listener)</code> 方法，这个方法里面起了一个 <code>for</code> 循环，在循环体中首先通过 <code>net.Listener</code>（即上一步监听端口中创建的 Listen Socket）实例的 <code>Accept</code> 方法接收客户端请求，接收到请求后根据请求信息创建一个 <code>conn</code> 连接实例，最后单独开了一个 goroutine，把这个请求的数据当做参数扔给这个 <code>conn</code> 去服务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
		<span class="nx">rw</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span>
		<span class="nx">connCtx</span> <span class="o">:=</span> <span class="nx">ctx</span>
		<span class="k">if</span> <span class="nx">cc</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">ConnContext</span><span class="p">;</span> <span class="nx">cc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">connCtx</span> <span class="p">=</span> <span class="nf">cc</span><span class="p">(</span><span class="nx">connCtx</span><span class="p">,</span> <span class="nx">rw</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">connCtx</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;ConnContext returned nil&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">newConn</span><span class="p">(</span><span class="nx">rw</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateNew</span><span class="p">)</span> <span class="c1">// before Serve can return
</span><span class="c1"></span>		<span class="k">go</span> <span class="nx">c</span><span class="p">.</span><span class="nf">serve</span><span class="p">(</span><span class="nx">connCtx</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用户的每一次请求都是在一个新的 goroutine 去服务，相互不影响。客户端请求的具体处理逻辑都是在 <code>c.serve</code> 中完成的。 <code>conn</code> 实例的 <code>serve</code> 方法首先会通过 <code>c.readRequest()</code> 解析请求，然后在 <code>serverHandler{c.server}.ServeHTTP(w, w.req)</code> 的 <code>ServeHTTP</code> 方法中获取相应的 <code>handler</code>：<code>handler := c.server.Handler</code>，也就是我们刚才在调用函数 <code>ListenAndServe</code> 时候的第二个参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">sh</span> <span class="nx">serverHandler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">rw</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">handler</span> <span class="o">:=</span> <span class="nx">sh</span><span class="p">.</span><span class="nx">srv</span><span class="p">.</span><span class="nx">Handler</span>
	<span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">handler</span> <span class="p">=</span> <span class="nx">DefaultServeMux</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestURI</span> <span class="o">==</span> <span class="s">&#34;*&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;OPTIONS&#34;</span> <span class="p">{</span>
		<span class="nx">handler</span> <span class="p">=</span> <span class="nx">globalOptionsHandler</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">handler</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">rw</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们发现当 handler 为 nil，也就是 ListenAndServe() 的第二个参数为 nil 时，使用了默认的 http.DefaultServeMux，这是 ServeMux的默认实例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">DefaultServeMux</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">defaultServeMux</span>
<span class="kd">var</span> <span class="nx">defaultServeMux</span> <span class="nx">ServeMux</span>
</code></pre></td></tr></table>
</div>
</div><p>ServeMux的数据结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ServeMux</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">.</span> <span class="c1">// 由于请求涉及到并发处理，因此这里需要一个锁机制
</span><span class="c1"></span>    <span class="nx">m</span>     <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">muxEntry</span> <span class="c1">// 路由规则字典，存放 URL 路径与处理器的映射关系
</span><span class="c1"></span>    <span class="nx">es</span>    <span class="p">[]</span><span class="nx">muxEntry</span> <span class="c1">// MuxEntry 切片（按照最长到最短排序）
</span><span class="c1"></span>    <span class="nx">hosts</span> <span class="kt">bool</span>       <span class="c1">// 路由规则中是否包含 host 信息
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里，我们需要重点关注的是 <code>muxEntry</code> 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">muxEntry</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">h</span>   <span class="nx">Handler</span>       <span class="c1">// 处理器具体实现
</span><span class="c1"></span>    <span class="nx">pattern</span> <span class="kt">string</span>    <span class="c1">// 模式匹配字符串
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后我们来看一下 <code>Handler</code> 的定义，这是一个接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="c1">// 路由处理实现方法
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当请求路径与 <code>pattern</code> 匹配时，就会调用 <code>Handler</code> 的 <code>ServeHTTP</code> 方法来处理请求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">sayHelloWorld</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们使用一个自定义的处理函数时，如上面的sayHelloWorld，并没有实现 <code>Handler</code> 接口，之所以可以成功添加到路由映射规则，是因为在底层通过 <code>HandlerFunc()</code> 函数将其强制转化为了 <code>HandlerFunc</code> 类型，而 <code>HandlerFunc</code> 类型实现了 <code>ServeHTTP</code> 方法，这样，<code>sayHelloWorld</code> 方法也就变相实现了 <code>Handler</code> 接口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">HandleFunc</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		  <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: nil handler&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">mux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nf">HandlerFunc</span><span class="p">(</span><span class="nx">handler</span><span class="p">))</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于 <code>sayHelloWorld</code> 方法来说，它已然变成了 <code>HandlerFunc</code> 类型的函数类型，当我们在其实例上调用 <code>ServeHTTP</code> 方法时，调用的是 <code>sayHelloWorld</code> 方法本身。</p>
<p>前面我们提到，<code>DefaultServeMux</code> 是 <code>ServeMux</code> 的默认实例，当我们在 <code>HandleFunc</code> 中调用 <code>mux.Handle</code> 方法时，实际上是将其路由映射规则保存到 <code>DefaultServeMux</code> 路由处理器的数据结构中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">mux</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">pattern</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: invalid pattern&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: nil handler&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">];</span> <span class="nx">exist</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: multiple registrations for &#34;</span> <span class="o">+</span> <span class="nx">pattern</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">muxEntry</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">muxEntry</span><span class="p">{</span><span class="nx">h</span><span class="p">:</span> <span class="nx">handler</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">:</span> <span class="nx">pattern</span><span class="p">}</span>
	<span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">es</span> <span class="p">=</span> <span class="nf">appendSorted</span><span class="p">(</span><span class="nx">mux</span><span class="p">.</span><span class="nx">es</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">hosts</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>还是以 <code>sayHelloWorld</code> 为例，这里的 <code>pattern</code> 字符串对应的是请求路径 <code>/</code>，<code>handler</code> 对应的是 <code>sayHelloWorld</code> 函数。</p>
<p>保存好路由映射规则之后，客户端请求的处理就默认调用<code>ServeMux</code> 实现的 <code>ServeHTTP</code> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span> <span class="o">==</span> <span class="s">&#34;*&#34;</span> <span class="p">{</span>
        <span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Connection&#34;</span><span class="p">,</span> <span class="s">&#34;close&#34;</span><span class="p">)</span>
        <span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">StatusBadRequest</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    
    <span class="nx">h</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="nx">h</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如上所示，路由处理器接收到请求之后，如果 URL 路径是 <code>*</code>，则关闭连接，否则调用 <code>mux.Handler(r)</code> 返回对应请求路径匹配的处理器，然后执行 <code>h.ServeHTTP(w, r)</code>，也就是调用对应路由 <code>handler</code> 的 <code>ServerHTTP</code> 方法，以 <code>/</code> 路由为例，调用的就是 <code>sayHelloWorld</code> 函数本身。</p>
<p><strong>总结</strong></p>
<p>现在我们来捋一下，当我们调用 http.ListenAndServe，首先建立了一个 Server 实例，然后把两个参数都赋给了该实例，之后我们在该实例的基础上调用底层 net 包监听端口、创建socket并开启连接，最后把这个连接交给了 Server实例的 handler处理，这个handler 正是我们在 ListenAndServe 中传入的第二个参数。</p>
<p>当第二个参数为 nil 时调用了 ServeMux 的默认实例 DefaultServeMux ，该实例实现了一个 ServeMux 结构体，而这个结构体中最重要的一个字段就是muxEntry 结构体，包含 pattern 和 handler 两部分。所以我们实现 Handle 和 HandleFunc 都是在将路由映射规则保存到 <code>DefaultServeMux</code> 路由处理器的 muxEntry 结构体的这两个字段。</p>
<p>客户端请求的处理就默认调用<code>ServeMux</code> 实现的 <code>ServeHTTP</code> 方法，把对应的请求交给对应的处理器。</p>
<h3 id="24-获取客户端提交的数据">2.4 获取客户端提交的数据</h3>
<p>前面已经提到，客户端提交的数据全部位于 *http.Request 中，下面的例子虽然做了声明，但没有使用，本节介绍一下如何从 *http.request 中提取想要的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Welcome to my website!&#34;</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>Request的部分结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// Method指定HTTP方法（GET、POST、PUT等）。对客户端，&#34;&#34;代表GET。
</span><span class="c1"></span>    <span class="nx">Method</span> <span class="kt">string</span>
    <span class="c1">// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。
</span><span class="c1"></span>    <span class="nx">Form</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
    <span class="c1">// PostForm是解析好的POST或PUT的表单数据。
</span><span class="c1"></span>    <span class="nx">PostForm</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">ParseForm</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>然后使用 FormValue 返回以 key 为健查询 r.Form 得到的第一个值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">FormValue</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>PostFormValue则返回key为键查询r.PostForm字段得到的第一个值，用于POST和PUT</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">PostFormValue</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>当提交的请求数据中有文件时，使用FormFile，可以返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="nf">FormFile</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">FileHeader</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>一个简单的实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">loginActionHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;GET&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">username</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">FormValue</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">)</span>
		<span class="nx">pwd</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">FormValue</span><span class="p">(</span><span class="s">&#34;password&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">4</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;用户名不符合规范&#34;</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pwd</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">6</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pwd</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">16</span> <span class="p">{</span>
			<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;密码不符合规范&#34;</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">http</span><span class="p">.</span><span class="nf">Redirect</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="s">&#34;/list&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusFound</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;请求方式不对&#34;</span><span class="p">))</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;登录失败&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Golang密码学算法</title><link>https://shuzang.github.io/golang-cryptographic-algorithm/</link><pubDate>Thu, 28 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-cryptographic-algorithm/</guid><description><![CDATA[<p>在 Go 中，加密是很重要的一部分，本文对此进行介绍。</p>
<h2 id="1-hash">1. Hash</h2>
<p>利用 Hash 算法可以将任意长度的二进制值（明文）映射为较短的固定长度的二进制值（Hash 值），是密码学的基础之一。</p>
<h3 id="11-流行的hash算法">1.1 流行的Hash算法</h3>
<p>目前常见的Hash算法包括Message Digest（MD）系列和Secure HashAlgorithm（SHA）系列算法。</p>
<p>MD算法主要包括MD4和MD5两个算法。MD4（RFC 1320）是MIT的Ronald L. Rivest在1990年设计的，其输出为128位。MD4已被证明不够安全。MD5（RFC 1321）是Rivest于1991年发布的MD4改进版本。它对输入仍以512位进行分组，其输出是128位。MD5比MD4更加安全，但过程更加复杂，计算速度要慢一点。MD5已于2004年被成功碰撞，其安全性已不足以应用于商业场景。</p>
<p>SHA算法由美国国家标准与技术研究院（National Institute ofStandards and Technology，NIST）征集制定。SHA-0算法于1993年问世，1998年即遭破解。随后的修订版本SHA-1算法在1995年面世，它的输出为长度160位的Hash值，安全性更好。SHA-1设计采用了MD4算法类似原理。SHA-1已于2005年被成功碰撞，意味着无法满足商用需求。为了提高安全性，NIST后来制定出更安全的SHA-224、SHA-256、SHA-384和SHA-512算法（统称为SHA-2算法）。新一代的SHA-3算法也正在研究中。</p>
<p><strong>目前MD5和SHA-1已经不够安全，推荐至少使用SHA-256算法</strong>。比特币系统就是使用SHA-256算法。</p>
<p>SHA-3算法又名Keccak算法。Keccak的输出长度有：512位、384位、256位、224位。</p>
<p>SHA-3并不是要取代SHA-2，因为SHA-2目前并没有暴露明显的弱点。由于对MD5出现成功的破解，以及对SHA-1出现理论上破解的方法，NIST认为需要一个与之前算法不同的、可替换的加密杂凑算法，也就是现在的SHA-3。区块链中的以太坊系统就是使用Keccak256算法</p>
<h3 id="12-sha-256">1.2 SHA-256</h3>
<p>SHA-256算法输入报文的最大长度是264 bit，产生的输出是一个256bit的报文摘要。SHA-256算法步骤如下。</p>
<ol>
<li>附加填充比特：对报文进行填充，使报文长度与448模512同余（长度=448 mod512），填充的比特数范围是1到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个1，再加很多个0，直到长度满足mod512=448。为什么是448？因为448+64=512。第二步会加上一个64bit的原始报文的长度信息。</li>
<li>附加长度值：将用64bit表示的初始报文（填充前）的位长度附加在步骤1的结果后（低位字节优先）。</li>
<li>初始化缓存：使用一个256bit的缓存来存放该Hash函数的中间及最终结果。该缓存表示为A=0x6A09E667，B=0xBB67AE85，C=0x3C6EF372，D=0xA54FF53A，E=0x510E527F，F=0x9B05688C，G=0x1F83D9AB，H=0x5BE0CD19。</li>
<li>处理512bit（16个字）报文分组序列：该算法使用了6种基本逻辑函数，由64步迭代运算组成。每步都以256bit缓存值ABCDEFGH为输入，然后更新缓存内容。</li>
</ol>
<p>每步使用一个32bit Kt（常数值）和一个32bit Wt（分组后的报文）。</p>
<h3 id="13-示例代码">1.3 示例代码</h3>
<p>计算字符串的 SHA-256 使用如下函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Sum256</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[</span><span class="nx">Size</span><span class="p">]</span><span class="kt">byte</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-对称加密算法">2. 对称加密算法</h2>]]></description></item><item><title>Golang数据库编程</title><link>https://shuzang.github.io/golang-interact-with-mysql/</link><pubDate>Tue, 26 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-interact-with-mysql/</guid><description><![CDATA[<p>Go 官方提供了database 包，database 包下有 sql/driver。该包用来定义操作数据库的接口，这保证了无论使用哪种数据库，操作方式都是相同的。但 Go 官方并没有提供连接数据库的 driver，如果要操作数据库，还需要第三方的 driver 包。这里介绍 <a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener noreffer">go-mysql-driver</a> 的使用。</p>
<h2 id="1-安装">1. 安装</h2>
<p>在执行了 <code>go mod</code> 的项目目录下执行如下安装命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go get -u github.com/go-sql-driver/mysql
</code></pre></td></tr></table>
</div>
</div><p>Win10 下，go-sql-driver 包将被安装到 <code>%GOPATH%\pkg\mod\github.com\go-sql-driver\mysql@v1.5.0</code> 目录下，其它项目使用时不必重复下载，执行上述命令即可直接引入。</p>
<h2 id="2-导入">2. 导入</h2>
<p>示例代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;database/sql&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="nx">_</span> <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Golang 提供了database/sql 包，用于对 SQL 数据库的访问。它提供了一系列接口方法，用于访问关系数据库但并不会提供数据库特有的方法，那些特有的方法交给数据库驱动去实现。</p>
<p>对于数据库操作来说，开发者不应该直接使用导入的驱动包所提供的方法，而应该使用 sql.DB 对象所提供的统一的方法。因此在导入 MySQL 驱动时，使用了匿名导入包的方式，即将 go-sql-driver 包重命名为特殊符号 <code>_</code>。采用这种方式只会执行其中的 init 函数和初始化其全局变量，无法调用函数。</p>
<h2 id="3-连接数据库">3. 连接数据库</h2>
<p>连接数据库使用 sql 包中的 Open() 函数，原型如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">driverName</span><span class="p">,</span> <span class="nx">dataSourceName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">DB</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>driverName：使用的驱动名。这个名字其实就是数据库驱动注册到 database/sql 时所使用的名字</li>
<li>dataSourceName：数据库连接信息。它包含了数据库的用户名、密码、数据库主机以及需要连接的数据库名等信息。</li>
</ul>
<p>使用示例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>sql.Open() 返回的 sql.DB 对象是 Goroutine 并发安全的。sql.DB 通过数据库驱动为开发者提供管理底层数据库连接的打开和关闭操作。sql.DB 帮助开发者管理数据库连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果开发者没有把连接释放回连接池，会导致过多连接使系统资源耗尽。</p>
<p>sql.DB 的设计目标就是作为长连接（一次连接多次数据交互）使用，不宜频繁开关。比较好的做法是，为每个不同的 datastore 建一个DB 对象，保持这些对象打开。如果需要短连接（一次连接一次数据交互），就把 DB 作为参数传入函数，而不要在函数中开关。</p>
<h2 id="4-增删改数据">4. 增删改数据</h2>
<p>直接调用DB对象的 Exec() 方法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>通过db.Exec()插入数据，通过返回的 err 可知插入失败的原因，通过返回的结果可以进一步查询本次插入数据影响的行数（RowsAffected）和最后插入的ID（如果数据库支持查询最后插入ID）。事实上，Result 是对已执行的 SQL 命令的总结，类型定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Result</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// LastInsertId返回一个数据库生成的回应命令的整数。
</span><span class="c1"></span>    <span class="c1">// 当插入新行时，一般来自一个&#34;自增&#34;列。
</span><span class="c1"></span>    <span class="c1">// 不是所有的数据库都支持该功能，该状态的语法也各有不同。
</span><span class="c1"></span>    <span class="nf">LastInsertId</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// RowsAffected返回被update、insert或delete命令影响的行数。
</span><span class="c1"></span>    <span class="c1">// 不是所有的数据库都支持该功能。
</span><span class="c1"></span>    <span class="nf">RowsAffected</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Exec() 方法的使用方式如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">result</span><span class="p">,</span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;INSERT INTO user_info (username, departname, created) VALUES (?,?,?)&#34;</span><span class="p">,</span> <span class="s">&#34;Steven&#34;</span><span class="p">,</span> <span class="s">&#34;区块链教学部&#34;</span><span class="err">，</span> <span class="s">&#34;2017-10-1&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>预编译语句（PreparedStatement）提供了诸多好处。PreparedStatement 可以实现自定义参数的查询，通常来说比手动拼接字符串SQL语句高效；PreparedStatement 还可以防止SQL注入攻击。因此，开发中应尽量使用它。</p>
<p>通常使用 PreparedStatement 和 Exec() 完成 INSERT、UPDATE、DELETE 操作。使用DB对象的Prepare() 方法获得预编译对象 stmt，然后调用 Exec() 方法，语法如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Prepare</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>具体用法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;INSERT INTO user_info SET username=?, departnamt=?, created=?&#34;</span><span class="p">)</span>
<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;Jackson&#34;</span><span class="p">,</span> <span class="s">&#34;研发部&#34;</span><span class="p">,</span> <span class="s">&#34;2017-10-1&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>获取影响数据库的行数，可以根据该数值判断是否操作（插入、删除或修改）成功。语法如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">count</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">result</span><span class="p">.</span><span class="nf">RowsAffected</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>预编译对象 stmt 属于 Stmt 类型，是一个准备好的状态，可以安全地被多个 Goroutine 同时使用，类型定义与方法集如下，定义在 DB 对象上的 Exec 和 Stmt 对象上的 Exec 传入参数有区别，后者不需要 SQL 语句，但作用应该是相同的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Stmt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stmt</span><span class="p">)</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stmt</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stmt</span><span class="p">)</span> <span class="nf">QueryRow</span><span class="p">(</span><span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">Row</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stmt</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="5-查询数据">5. 查询数据</h2>
<p>数据查询的一般步骤如下</p>
<ol>
<li>
<p>调用 db.Query() 方法执行 SQL 语句，此方法返回一个 Rows 作为查询结果，语法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，Rows 作为查询结果，其游标指向结果集的第零行</p>
</li>
<li>
<p>将 rows.Next() 方法的返回值作为 for 循环的条件，迭代查询数据，语法如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Next 的返回值不是简单的一个对下一个结果是否存在的判断，而是准备下一行结果用于 Scan 方法进行扫描，如果准备好，返回 true，如果没有下一行或准备时出现错误，返回 false</p>
</li>
<li>
<p>在循环中，通过 rows.Scan()方法读取每一行数据，语法如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">Scan</span><span class="p">(</span><span class="nx">dest</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>rows.Scan() 方法的参数顺序很重要，必须和查询结果的列相对应（数量和顺序都需要一致）。假设 <code>SELECT * From user_info where age ＞=20 AND age ＜ 30</code> 查询的列顺序是 <code>id, name, age</code>，和插入操作顺序相同，rows.Scan() 的参数传入也需要按照此顺序 <code>rows.Scan(＆id, ＆name, ＆age)</code>，不然会造成数据读取的错位。</p>
</li>
<li>
<p>调用db.Close()关闭查询，Close 关闭 DB对象，释放任何打开的资源，但实际上因为 DB 句柄通常被多个 Go 协程共享，不会被关闭。</p>
</li>
</ol>
<p>查询多行数据的一个完整示例如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user_info WHERE uid&lt;?&#34;</span><span class="p">)</span>
<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1">// 注意这里的 Query 也是 stmt 的方法
</span><span class="c1"></span><span class="nx">user</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">UserTable</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Username</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Department</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Created</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">user</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为 Golang 是强类型语言，所以查询数据时先定义数据类型。数据库中的数据有3种可能状态：存在值、存在零值、未赋值，因此可以将待查询的数据类型定义为 sql.NullString、sql.NullInt64 类型等。可以通过 Valid 值来判断查询到的值是赋值状态还是未赋值状态。</p>
<p>每次 db.Query() 操作后，都建议调用 rows.Close()。因为 db.Query() 会从数据库连接池中获取一个连接，这个底层连接在结果集（rows）未关闭前会被标记为处于繁忙状态。当遍历读到最后一条记录时，会发生一个内部 EOF 错误，自动调用 rows.Close()。但如果出现异常，提前退出循环，rows 不会关闭，连接不会回到连接池中，连接也不会关闭，则此连接会一直被占用。因此通常使用 defer rows.Close() 来确保数据库连接可以正确放回到连接池中。rows.Close() 操作是幂等操作，而一个幂等操作的特点是：其任意多次执行所产生的影响与一次执行的影响相同。所以即便对已关闭的 rows 再执行 close() 也没关系。</p>
<p>谈到这里，我们可以注意到 Close 方法一共有三种，分别定义在 DB、Stmt、Rows 三个方法上，用于关闭数据库连接、预准备状态和查询结果，不过本质上都是释放某个连接池中的连接。</p>
<p>单条数据通过 QueryRow() 方法查询，语法如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">QueryRow</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">Row</span>
</code></pre></td></tr></table>
</div>
</div><p>使用示例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">departname</span><span class="p">,</span> <span class="nx">created</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT username, departname, created FROM user_info WHERE uid=?&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">username</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">departname</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">created</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="6-示例代码">6. 示例代码</h2>
<p>定义一个表结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">mysql&gt; CREATE TABLE user_info (
    -&gt; uid INT(10) NOT NULL AUTO_INCREMENT,
    -&gt; username VARCHAR(64) DEFAULT NULL,
    -&gt; departname VARCHAR(64) DEFAULT NULL,
    -&gt; created DATE DEFAULT NULL,
    -&gt; PRIMARY KEY(uid)
    -&gt; );
Query OK, 0 rows affected, 1 warning (0.03 sec)

mysql&gt; DESC user_info;
+------------+-------------+------+-----+---------+----------------+
| Field      | Type        | Null | Key | Default | Extra          |
+------------+-------------+------+-----+---------+----------------+
| uid        | int         | NO   | PRI | NULL    | auto_increment |
| username   | varchar(64) | YES  |     | NULL    |                |
| departname | varchar(64) | YES  |     | NULL    |                |
| created    | date        | YES  |     | NULL    |                |
+------------+-------------+------+-----+---------+----------------+
4 rows in set (0.00 sec)
</code></pre></td></tr></table>
</div>
</div><p>编写一个完整的测试代码，使用上述提到的所有数据库操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;database/sql&#34;</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="nx">_</span> <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>
<span class="p">)</span>

<span class="c1">// 定义数据库连接信息
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DbConn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Dsn</span> <span class="kt">string</span> <span class="c1">// 数据库驱动字符串
</span><span class="c1"></span>	<span class="nx">Db</span>  <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span>
<span class="p">}</span>

<span class="c1">// 数据库中的用户表的映射对象
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UserTable</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Uid</span>        <span class="kt">int</span>
	<span class="nx">Username</span>   <span class="kt">string</span>
	<span class="nx">Department</span> <span class="kt">string</span>
	<span class="nx">Created</span>    <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">dbConn</span> <span class="o">:=</span> <span class="nx">DbConn</span><span class="p">{</span>
		<span class="nx">Dsn</span><span class="p">:</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/testdb?charset=utf8&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">dbConn</span><span class="p">.</span><span class="nx">Db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nx">Dsn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nx">Db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="c1">//1. 测试直接使用 DB 的 Exec() 方法增删改
</span><span class="c1"></span>	<span class="nf">execData</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dbConn</span><span class="p">)</span>
	<span class="c1">//2. 测试使用预编译语句和 Exec() 方法增删改
</span><span class="c1"></span>	<span class="nf">preExecData</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dbConn</span><span class="p">)</span>
	<span class="c1">//3. 查询单行数据(以最后一条数据为例)
</span><span class="c1"></span>	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nf">QueryRowData</span><span class="p">(</span><span class="s">&#34;select * from user_info where uid = (select max(uid) from user_info)&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
	<span class="c1">//4. 查询多行数据
</span><span class="c1"></span>	<span class="nx">result1</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nf">QueryData</span><span class="p">(</span><span class="s">&#34;select * from user_info where uid&lt;10&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">result1</span><span class="p">))</span>
	<span class="c1">//5. 查询多行数据（使用预编译语句）
</span><span class="c1"></span>	<span class="nx">result2</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nf">PreQueryData</span><span class="p">(</span><span class="s">&#34;select * from user_info where uid&lt;? order by uid desc&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">result2</span><span class="p">))</span>
	<span class="c1">//遍历查询的结果集
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">result2</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;uid: &#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">execData</span><span class="p">(</span><span class="nx">dbConn</span> <span class="o">*</span><span class="nx">DbConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">count</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nf">ExecData</span><span class="p">(</span><span class="s">&#34;insert user_info (username,departname,created) values (&#39;Josh&#39;, &#39;business group&#39;,&#39;2020-06-14&#39;)&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;受影响的行数：&#34;</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;新添加数据的id：&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dbConn</span> <span class="o">*</span><span class="nx">DbConn</span><span class="p">)</span> <span class="nf">ExecData</span><span class="p">(</span><span class="nx">sqlString</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nx">Db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">sqlString</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nf">LastInsertId</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nf">RowsAffected</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">preExecData</span><span class="p">(</span><span class="nx">dbConn</span> <span class="o">*</span><span class="nx">DbConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">count</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nf">PreExecData</span><span class="p">(</span><span class="s">&#34;insert user_info (username,departname,created) values (&#39;Jackson&#39;, &#39;Education Department&#39;,&#39;2020-06-14&#39;)&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;受影响的行数：&#34;</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;新添加数据的id：&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dbConn</span> <span class="o">*</span><span class="nx">DbConn</span><span class="p">)</span> <span class="nf">PreExecData</span><span class="p">(</span><span class="nx">sqlString</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nx">Db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="nx">sqlString</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">args</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nf">LastInsertId</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nf">RowsAffected</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dbConn</span> <span class="o">*</span><span class="nx">DbConn</span><span class="p">)</span> <span class="nf">QueryRowData</span><span class="p">(</span><span class="nx">sqlString</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">data</span> <span class="nx">UserTable</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">user</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">UserTable</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nx">Db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="nx">sqlString</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Username</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Department</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Created</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">*</span><span class="nx">user</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dbConn</span> <span class="o">*</span><span class="nx">DbConn</span><span class="p">)</span> <span class="nf">QueryData</span><span class="p">(</span><span class="nx">sqlString</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">resultSet</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">UserTable</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nx">Db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">sqlString</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">resultSet</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">UserTable</span><span class="p">)</span>
	<span class="nx">user</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">UserTable</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Username</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Department</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Created</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">resultSet</span><span class="p">[</span><span class="nx">user</span><span class="p">.</span><span class="nx">Uid</span><span class="p">]</span> <span class="p">=</span> <span class="o">*</span><span class="nx">user</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">resultSet</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dbConn</span> <span class="o">*</span><span class="nx">DbConn</span><span class="p">)</span> <span class="nf">PreQueryData</span><span class="p">(</span><span class="nx">sqlString</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">resultSet</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">UserTable</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dbConn</span><span class="p">.</span><span class="nx">Db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="nx">sqlString</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">args</span><span class="o">...</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">resultSet</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">UserTable</span><span class="p">)</span>
	<span class="nx">user</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">UserTable</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Username</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Department</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Created</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">resultSet</span><span class="p">[</span><span class="nx">user</span><span class="p">.</span><span class="nx">Uid</span><span class="p">]</span> <span class="p">=</span> <span class="o">*</span><span class="nx">user</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">resultSet</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
受影响的行数： <span class="m">1</span>
新添加数据的id： <span class="m">2</span>
受影响的行数： <span class="m">1</span>
新添加数据的id： <span class="m">3</span>
<span class="o">{</span><span class="m">3</span> Jackson Education Department 2020-06-14<span class="o">}</span>        
<span class="m">3</span>
<span class="m">3</span>
uid:  <span class="m">3</span> <span class="o">{</span><span class="m">3</span> Jackson Education Department 2020-06-14<span class="o">}</span>
uid:  <span class="m">2</span> <span class="o">{</span><span class="m">2</span> Josh business group 2020-06-14<span class="o">}</span>
uid:  <span class="m">1</span> <span class="o">{</span><span class="m">1</span> Steven 区块链教学部 2017-10-01<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://weread.qq.com/web/reader/df83279071b1ee24df86404k07c32570311607cdfd23f04">https://weread.qq.com/web/reader/df83279071b1ee24df86404k07c32570311607cdfd23f04</a></p>
]]></description></item></channel></rss>