<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数据结构与算法 - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>数据结构与算法 - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 18 Sep 2020 20:37:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>算法-时间复杂度和空间复杂度</title><link>https://shuzang.github.io/algorithm-time-and-space-complexity/</link><pubDate>Fri, 18 Sep 2020 20:37:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-time-and-space-complexity/</guid><description><![CDATA[<p>时间和空间复杂度的分析是编制程序的一个基本能力，不过平时基本都是脑子里简单的估计，本篇文章打算回忆一下大 O 表示法和具体的时间复杂度的推导过程。</p>
<h2 id="1-时间复杂度">1. 时间复杂度</h2>
<p>算法的时间复杂度指的是算法运行所需要的时间的量，这个时间量不应该依赖外部因素，而应当只和问题规模 N、输入 I 以及算法 A 本身相关。如果用 T 表示时间复杂度，那么表达式为</p>
<p>$$
T = T(N,I,A)
$$
由于算法是通过一个或几个函数实现的，算法 A 本身通常就会隐含在函数名中，这样表达式可以简化为
$$
T = T(N,I)
$$
如果算法连输入都不依赖，那么表达式就可以进一步简化为 $T(N)$，但我们通常用 N 的小写形式，写作 $T(n)$</p>
<p>那么我们如何来计算这个时间的量呢，通常，我们假设算法中每条语句的执行时间均为单位时间，这样，算法运行的总时间就是所有语句执行时间之和。以顺序查找为例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 返回第一个与 k 相同的元素的下标，否则返回-1
</span><span class="c1"></span><span class="n">Search</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mf">0.</span><span class="p">..</span><span class="n">n</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>                         <span class="c1">// c1=1
</span><span class="c1"></span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span> <span class="k">do</span>  <span class="c1">// c2
</span><span class="c1"></span>        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>                 <span class="c1">// c3
</span><span class="c1"></span>    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> 
        <span class="k">return</span> <span class="n">i</span>             	  <span class="c1">// c4=1
</span><span class="c1"></span>    <span class="k">else</span> 
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>                 <span class="c1">// 或c5=1
</span></code></pre></td></tr></table>
</div>
</div><p>注释中列出了每条语句的执行时间 $c_i$，那么 $\sum_{i=1}^{n}c_i$ 就是算法运行的总时间。</p>
<p>但是，算法运行的总时间并不是算法的时间复杂度，我们通常说的时间复杂度完整的叫法应该是算法的渐进时间复杂度，是考虑当问题规模充分大时，算法运行时间的表达式在渐进意义下的阶。定义如下</p>
<blockquote>
<p>设 $T(n)$ 是关于算法 A 的复杂性函数，如果存在 t(n)，使得 $\lim\limits_{N\to\infty} \frac{T(n)-t(n)}{T(n)} = 0 $，则 t(n) 是 T(n) 是当 $n\to\infty$ 时的渐进表达式，也可以直接称作其渐进时间复杂度</p>
</blockquote>
<p>具体而言，对于给定的 $T(n)$ 的表达式，算法的渐进时间复杂度是略去低阶项和常数因子留下的主项。例如，给定 $T(n) = 3n^3 + 90n^2 - 5n + 6040$，略去低阶项和常数因子，得到渐进时间复杂度 $t(n) = n^3$</p>
<h3 id="11-大o表示法">1.1 大O表示法</h3>
<p>通常用渐进上界 O 来表示渐进时间复杂度，也就是我们常说的大 O 表示法，其定义是
$$
O(g(n)) = {f(n) | 存在正常数 c 和 n_0使得对所有 n \ge n_0 有：0 \le f(n) \le cg(n)}
$$
</p>
<p>举个例子，$f(n) = 2n+3 = O(n)$，因为当 $n\ge 3$ 时，$2n+3 \le 3n$，这里的含义就是，当 $n \ge 3$ 时，算法步骤不会超过 $3n$</p>
<p>第二个例子，$f(n) = 10n^2 + 4n + 2 = O(n^2)$，因为当 $n \ge 5$ 时，$10n^2 + 4n + 2 \le 11n^2$</p>
<p>最后给一个矩阵乘法的实例，总时间 $T(n) = 2n^3 + n^2 + 2n$，这样渐进时间复杂度就是 $O(n^3)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>                <span class="c1">// n
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>            <span class="c1">// n
</span><span class="c1"></span>        <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>                     <span class="c1">// n^2
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>        <span class="c1">// n^3
</span><span class="c1"></span>            <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">k</span><span class="p">]</span><span class="o">*</span><span class="nx">b</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>  <span class="c1">// n^3
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后声明两个大 O 的运算规则</p>
<ol>
<li>$O(f) + O(g) = O(max(f,g))$</li>
<li>$O(f)O(g) = O(fg)$</li>
</ol>
<p>此外，有时候也会见到渐进下界 $\Omega$ 和 渐进准确界 $\Theta$，但很少或几乎用不到</p>
<h3 id="12-对输入实例的依赖">1.2 对输入实例的依赖</h3>
<p>有些时候需要考虑某类有代表性的输入实例，比如最坏情况、最好情况、平均情况，这几种情况的复杂度是不一样的，通常用如下符号表示</p>
<ul>
<li>最好情况 $T_{min}(n)$</li>
<li>最坏情况 $T_{max}(n)$</li>
<li>平均情况 $T_{avg}(n)$</li>
</ul>
<p>对于前面提到的查找算法，第一个与 k 相同的元素可能是最后一个元素，这时循环执行 n 次，是最坏情况；也可能是第一个元素，这时循环只执行 1 次，是最好情况。</p>
<p>理解这三种情况下的算法性能都很重要，但应注意：</p>
<ol>
<li>很多算法最好情况下的性能都差不多，O(1) 或者 O(n)，没有太大的影响，不能说明哪种算法更好；</li>
<li>算法的平均情况往往不是那么容易分析；</li>
<li>最坏情况可以告诉我们算法性能的上限，从而保证任何情况都不会比它差。</li>
</ol>
<h3 id="13-复杂度分析的步骤">1.3 复杂度分析的步骤</h3>
<p>复杂度分析的步骤如下</p>
<ol>
<li>确定表示问题规模的变量；</li>
<li>确定占运行时间最大比例的语句；</li>
<li>确定算法是否依赖输入实例（决定了是否分最坏、最好、平均三种情况考虑）；</li>
<li>计算语句执行总次数；</li>
<li>确定时间复杂度；</li>
</ol>
<p>以选择排序为例，用伪代码描述如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">SelectionSort</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mf">0.</span><span class="p">..</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span> <span class="k">do</span> 
	    <span class="n">min</span> <span class="o">=</span> <span class="n">i</span>
	    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="k">do</span> 
	        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="p">{</span>
		        <span class="n">min</span> <span class="o">=</span> <span class="n">j</span>	
    <span class="n">swap</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>问题规模为数组长度 n</li>
<li>占运行时间最大比例的语句是 $min = j$</li>
<li>算法只依赖问题规模，不依赖输入实例</li>
<li>语句执行总次数 $T(n) = \sum_{i=1}^{n}i = \frac{n(n-1)}{2}$</li>
<li>时间复杂度为 $O(n^2)$</li>
</ol>
<p>一个依赖输入实例的例子是插入排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">InsertSort</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mf">0.</span><span class="p">..</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span><span class="o">--</span>
    <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>问题规模为数组长度 n</li>
<li>占运行时间最大比例的语句是 $A[j] &gt; a$</li>
<li>算法依赖输入实例</li>
<li>语句执行总次数：
<ul>
<li>最坏情况：$T(n) = \frac{n(n-1)}{2}$</li>
<li>最好情况：$T(n) = n-1$</li>
</ul>
</li>
<li>时间复杂度
<ul>
<li>最坏情况：$T(n)=O(n^2)$</li>
<li>最好情况：$T(n) = O(n)$</li>
</ul>
</li>
</ol>
<h3 id="14-常见时间复杂度">1.4 常见时间复杂度</h3>
<p>常见时间复杂度总结如下表</p>
<table>
<thead>
<tr>
<th>复杂度</th>
<th>出现情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>几乎不存在</td>
</tr>
<tr>
<td>logn</td>
<td>不能考虑全部输入</td>
</tr>
<tr>
<td>n</td>
<td>遍历、扫描全部输入</td>
</tr>
<tr>
<td>nlogn</td>
<td>许多分治算法</td>
</tr>
<tr>
<td>$n^2$</td>
<td>两层循环</td>
</tr>
<tr>
<td>$n^3$</td>
<td>三层循环</td>
</tr>
<tr>
<td>$2^n$</td>
<td>一个集合的所有子集</td>
</tr>
<tr>
<td>$n!$</td>
<td>一个集合中的元素的所有排列</td>
</tr>
</tbody>
</table>
<p>我们可以按这些时间复杂度把算法分为两类</p>
<ul>
<li>多项式时间算法
<ul>
<li>用多项式对运行时间限界的算法</li>
<li>$O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3)$</li>
</ul>
</li>
<li>指数时间算法
<ul>
<li>用指数函数对运行时间限界的算法</li>
<li>$O(2^n) &lt; O(n!) &lt; O(n^n)$</li>
</ul>
</li>
</ul>
<p>对指数时间的算法应尽可能优化。</p>
<h2 id="2-空间复杂度">2. 空间复杂度</h2>
<p>空间复杂度是对算法所消耗的额外存储单元进行计数，这里注意是<strong>额外</strong>的存储单元，不包括</p>
<ol>
<li>为容纳输入数据而分配的存储空间，比如输入数组 A[0&hellip;n] 占用的空间</li>
<li>实现该算法的程序代码和常数占用的空间</li>
</ol>
<p>额外的意思是算法所需要的工作空间，比如交换两个变量值时分配了一个临时变量，这个变量占用的空间就属于空间复杂度分析的范围，再比如实现栈时为栈申请的空间也属于空间复杂度的分析范围，最后，递归函数使用的内部栈也属于空间复杂度的分析范围。</p>
<p>在很多问题中，时间和空间是一个对立面。为算法分配更多的空间，可以使算法运行的更快，反之，当空间是一个重要因素时，需要用算法的运行时间去换取空间。一个运行时间短、所需存储空间小、其它性能也好的算法是很难做到的。因此我们要根据具体情况进行算法设计。</p>
<ul>
<li>对于使用次数较少的程序，力求算法简单易懂；</li>
<li>对于反复多次使用的程序，尽可能选用快速的算法；</li>
<li>若待解决的问题数据量极大，机器的存储空间较小，则相应算法主要考虑如何节省空间。</li>
</ul>]]></description></item><item><title>算法-字符串类问题</title><link>https://shuzang.github.io/algorithm-stings/</link><pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-stings/</guid><description><![CDATA[<p>做 Leetcode 每日一题的时候遇到了子串判断类的问题，想起一直没仔细的去看过 KMP 等字符串常用的算法，所以这里学习一下。</p>
<!---more-->
<h2 id="1-重复的子字符串">1. 重复的子字符串</h2>
<p>这就是今天遇到的题目，题目描述为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:
输入: &#34;abab&#34;
输出: True
解释: 可由子字符串 &#34;ab&#34; 重复两次构成。

示例 2:
输入: &#34;aba&#34;
输出: False

示例 3:
输入: &#34;abcabcabcabc&#34;
输出: True
解释: 可由子字符串 &#34;abc&#34; 重复四次构成。 (或者子字符串 &#34;abcabc&#34; 重复两次构成。)
</code></pre></td></tr></table>
</div>
</div><p>首先确认边界条件</p>
<ol>
<li>字符串长度满足：0 &lt; len(s) &lt;= 10000，所以不需要考虑空字符串</li>
<li>字符串的子串不包括自己，也就是说，「一个字符串由自己重复 1 次构成」这种说法不成立，可由示例2得出</li>
</ol>
<p>然后确认基本思路</p>
<ol>
<li>遍历所有可能的子串长度，从 1 到 len(s)/2，然后判断这个长度的子串是否可能为结果。取 len(s)/2 是因为超过字符串长度一半的子串不可能通过重复构成原字符串；</li>
<li>字符串的长度一定是子串长度的倍数，否则也不可能是结果；</li>
<li>考虑如何取给定长度的子串，由于字符串由子串重复构成，那么只需要从第一个字符开始取即可，长度为 n 的子串就从第一个字符开始取 n 个字符构成子串；</li>
</ol>
<p>最后根据该思路编写代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">repeatedSubstringPattern</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 字符串长度可能是1到len(s)/2
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 只有 len(s) 是子字符串长度的倍数才有可能
</span><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 子串为 s[:i]，然后对字符串的其它部分进行判断
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">flag</span> <span class="kt">bool</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">j</span> <span class="o">+=</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">:</span><span class="nx">j</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 中途没有跳出才说明整个字符串由子串重复构成
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 所有长度的子串都无法重复构成原字符串
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码编写完成后要考虑最后一件事，就是条件和循环的边界条件，这是最容易产生错误的地方</p>
<ol>
<li>
<p><code> i &lt;= len(s)/2</code>：当 <code>i == len(s)/2</code> 的时候，子串为 <code>s[:len(s)/2]</code>，以字符串 <code>abab</code> 为例，子串为 <code>ab</code>，因为 Go 的切片不会取最后一个字符，所以必须添加 <code>=</code> 号，不然会漏掉一种情况；</p>
</li>
<li>
<p><code>j &lt; len(s)</code>：我们考虑最后一次循环的 j，此时 <code>s[j:j+i]</code> 中 <code>j+i</code> 可能会越界超出 len(s)，导致 panic。遇到这种情况我们最常用的做法是修改条件为 <code>j + i &lt; len(s)</code>，然后我们来考虑边界条件。</p>
<p>当 <code>j + i == len(s)</code> 的时候， <code>s[j:j+i]</code> 其实原本想表达的含义是最后一个字符串，是应该取的，但是 j + i 产生越界，所以要额外处理。</p>
</li>
</ol>
<p>修改后的程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">repeatedSubstringPattern</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 字符串长度可能是1到len(s)/2
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 只有 len(s) 是子字符串长度的倍数才有可能
</span><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 子串为 s[:i]，然后对字符串的其它部分进行判断
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">flag</span> <span class="kt">bool</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">j</span> <span class="o">+=</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">tmp</span> <span class="kt">string</span>
            <span class="k">if</span> <span class="nx">j</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">tmp</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">:]</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="nx">tmp</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">:</span><span class="nx">j</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 中途没有跳出才说明整个字符串由子串重复构成
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 所有长度的子串都无法重复构成原字符串
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-模式匹配bf算法">2. 模式匹配BF算法</h2>
<p>上面的问题可以使用 KMP 算法解决，但解释 KMP 算法之前必须先了解 BF 算法。</p>
<p>模式匹配问题为：假设有两个字符串 S 和 T，设 S 为主串，判断 T 是否为 S 的子串，如果是，返回子串在主串中第一个出现的位置，如果不是，返回 -1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">示例 1:
输入: haystack = &#34;hello&#34;, needle = &#34;ll&#34;
输出: 2

示例 2:
输入: haystack = &#34;aaaaa&#34;, needle = &#34;bba&#34;
输出: -1
</code></pre></td></tr></table>
</div>
</div><p>最笨的办法，也就是暴力法，是穷举 S 所有的子串，判断是否和 T 相同，该算法就称为 BF（Brute Force）算法。为了介绍通用的算法，这里放弃 Go 切片的优势，采用逐个字符匹配的方式。代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// 子串为空，返回0
</span><span class="c1"></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>

    <span class="c1">// = 号是考虑子串等于主串的情况
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">flag</span> <span class="kt">bool</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-模式匹配kmp算法">3. 模式匹配KMP算法</h2>
<p>实际上，没有必要从主串 S 的每一个字符开始穷举每种情况。Knuth、Morris、Pratt 对该算法进行了改进，提出了 KMP 算法。</p>
<p>设 <code>S = abaabaabeca，T = abaabe</code>，KMP 的流程如下</p>
<p>从S第1个字符开始：i=1, j=1，比较两个字符是否相等，如果相等，则 i++, j++；等到第一次匹配不相等的时候，BF算法会继续从 S 第 2个字符开始和 T 第一个字符进行比较，但 BMP 的做法是：S 的索引不需要移动，T 的索引回退 3 个，如下图</p>
<p></p>
<p>这样做的原因是 T 串中 j 索引前面的两个字符和 S 串中 i 索引前面的两个字符相同，都是 <code>ab</code>，所以现在的关键变成了我们怎么知道 i 前面的字符和 j 前面的字符相同，有几个字符相同（这决定了 j 回退几个位置）</p>
<p>直观的想法是进行第二次的比较，比较 T 开头的字符和 i 前面的字符，但其实不需要，因为在 j 回退之前，i 前面的字符必然和 j 前面的字符相同，如下</p>
<p></p>
<p>所以问题转化成了 T 内部字符的比较，假设 T 中当前 j 指向的前面的所有字符为 $T'$，上图中 $T' = abaab$，那么只需要比较 $T'$ 的前缀和后缀即可。判断其前缀后缀是否相等，并寻找相等前缀后缀的最大长度。</p>
<ol>
<li>长度为1：前缀 a，后缀 b，不相等</li>
<li>长度为2：前缀 ab，后缀 ab，相等</li>
<li>长度为3：前缀 aba，后缀 aab，不相等</li>
<li>长度为4：前缀 abaa，后缀 baab，不相等</li>
</ol>
<p>相等前缀后缀的最大长度为 2，则 j 可以回到 2+1=3 个位置继续比较。如果将这个回退的位置表示为 next[j]，令 $T' = t_1t_2&hellip;t_{j-1}$，则可得公式</p>
<p></p>
<p>由于字符串 T 的长度有限，next[] 其实是一个固定的数组</p>
<table>
<thead>
<tr>
<th>j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>e</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>假设 next[j] = k，$T' = t_1t_2&hellip;t_{j-1}$，那么 T 的相等前缀、后缀最大长度为 k-1</p>
<p></p>
<p>我们在求 next[j+1] 的时候可以考虑动态规划递推的办法</p>
<ol>
<li>
<p>$t_k = t_j$：那么 next[j+1] = k+1，即相等前缀和后缀的长度比 next[j] 多1，如下图</p>
<p></p>
</li>
<li>
<p>$t_k \neq t_j$：那么回退找 next[k] = k' 的位置，比较 $t_{k'}$ 和 $t_j$ 是否相等</p>
<p></p>
<p>如果相等，则 next[j+1] = k'' + 1，如果不相等，继续向前找，直到找到 next[i] = 0 停止</p>
<p></p>
</li>
</ol>
<p>求解 next 的代码实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getNext</span><span class="p">(</span><span class="nx">T</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">next</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">j</span><span class="p">,</span><span class="nx">k</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
    <span class="nx">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">T</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">T</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">j</span><span class="p">,</span><span class="nx">k</span> <span class="p">=</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span>
            <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">k</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">k</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>KMP 算法的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">KMP</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span><span class="nx">T</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pos</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">i</span><span class="p">,</span><span class="nx">j</span> <span class="o">:=</span> <span class="nx">pos</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">S</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">S</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">T</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">i</span><span class="o">++</span>
            <span class="nx">j</span><span class="o">++</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">j</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">i</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>算法-背包问题</title><link>https://shuzang.github.io/algorithm-knapsack-problem/</link><pubDate>Thu, 06 Aug 2020 10:22:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-knapsack-problem/</guid><description><![CDATA[<p>奇安信的笔试遇到了完全背包问题，结果写的时候按 0-1 背包写的贪心，最后没 AC，因此本篇对所有的背包问题做一次整理。</p>
<h2 id="1-0-1-背包">1. 0-1 背包</h2>
<p>问题描述如下</p>
<blockquote>
<p>有 n 个物品和一个容量为 W 的背包，每个物品有重量 $w_i$ 和价值 $v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p>
</blockquote>
<p>解决该问题实际上可以用我们学到的所有算法，下面做一点解释</p>
<h3 id="11-递归">1.1 递归</h3>
<p>选择装入背包的物品时，每种物品 $i$ 只有两种选择：装入或不装入。不能将物品 $i$ 装入背包多次，也不能只装入部分物品，我们用 $x_i$ 表示对第 $i$ 个物品的选择，$x_i=1$ 表示选择该物品，$x_i=0$ 表示不选择该物品。这样，对所有的物品，我们就有了一个解集 $(x_1,x_2,……,x_n)$，最终的目标是求得  $max \sum_{i=1}^n v_i x_i$，并且可以将问题写成如下的数学形式
$$
\sum_{i=1}^n w_i x_i \leq c \\
x_i \in \{0,1\}, 1 \leq i \leq n
$$
接下来定义子问题，假设 $m(i,j)$ 代表当前背包剩余容量为 $j$ 时，可选物品为 $i,i+1,&hellip;,n$ 时的最大总价值，那么对于第 i 个物品，有两种可能</p>
<ol>
<li>背包剩余容量不足以容纳该物品，此时背包总价值不会变，$m(i,j) = m(i+1,j)$</li>
<li>背包剩余容量可以装下该物品，此时如果装物品，总价值会变为 $m(i+1,j-w_i)+v_i$，如果不装该物品，总价值为 $m(i+1,j)$，需要选择两者中总价值更大的那一个</li>
</ol>
<p>综上我们就得到了递推关系式，然后我们还可以确定边界条件为剩余物品只有一个，也就是  $m(n,j)$，如果能装下第 $n$ 个物品，$m(n,j)=v_n$，否则 $m(n,j)=0$，这样就得到了下面的程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">v</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">}</span>
		<span class="nx">w</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
	<span class="p">)</span>

	<span class="kd">var</span> <span class="nx">Knapsack_Recurrence</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">Knapsack_Recurrence</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="c1">// 边界条件：只有一个物品
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">j</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">j</span> <span class="p">{</span>
			<span class="c1">// 装不下当前物品
</span><span class="c1"></span>			<span class="nx">res</span> <span class="p">=</span> <span class="nf">Knapsack_Recurrence</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 可以装下当前物品
</span><span class="c1"></span>			<span class="nx">t1</span> <span class="o">:=</span> <span class="nf">Knapsack_Recurrence</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
			<span class="nx">t2</span> <span class="o">:=</span> <span class="nf">Knapsack_Recurrence</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">t1</span> <span class="p">&gt;</span> <span class="nx">t2</span> <span class="p">{</span>
				<span class="nx">res</span> <span class="p">=</span> <span class="nx">t1</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="nx">res</span> <span class="p">=</span> <span class="nx">t2</span>
            <span class="p">}</span>		
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Knapsack_Recurrence</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="p">}</span>
<span class="c1">// Output:
</span><span class="c1"></span><span class="mi">37</span>
</code></pre></td></tr></table>
</div>
</div><p>这里时间复杂度为 $O(2^n)$，空间复杂度为 $O(n)$</p>
<h3 id="12-动态规划">1.2 动态规划</h3>
<p>动态规划解法与递归法的区别在于使用数组来存储计算的中间值，从而减少重复计算，上面的递推关系式就是现成的状态转移方程。那上面程序中的输入举例，物品数量为 4，背包容量为 5，问题分析和绘制的动态规划数组如下</p>
<p>编写程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">}</span>
	<span class="nx">w</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Knapsack_dp</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Knapsack_dp</span><span class="p">(</span><span class="nx">N</span><span class="p">,</span> <span class="nx">C</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 状态数组初始化
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">C</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 边界条件
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">C</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">j</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 填写状态数组, 自底向上，自左到右
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">C</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">j</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">C</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="c1">// Output:
</span><span class="c1"></span><span class="mi">37</span>
</code></pre></td></tr></table>
</div>
</div><p>动态规划的时间复杂度为 $O(N<em>C)$，空间复杂度为 $O(N</em>C)$，如果背包容量很大，比如达到了 $2^N$ 基本，性能反而会不如递归方法。</p>
<p>动态规划数组可以进一步优化，主要是因为我们在计算时实际上只用到了前一行的数据，因此二维数组可以简化为一维数组，空间复杂度可以缩减到 $O(C)$</p>
<h3 id="13-贪心">1.3 贪心</h3>
<p>贪心解背包问题就是另一种思路了，核心是选择贪心的策略，这里主要使用价值重量比策略。我们可以将过程总结为三步</p>
<ol>
<li>计算每种物品单位重量的价值 $v_i/w_i$，$O(n)$</li>
<li>将计算得到的价值重量比按降序排列</li>
<li>将尽可能多的单位重量价值最高的物品装入背包，$O(nlogn)$</li>
</ol>
<p>下面解决的问题实际上是背包的一种情况，即物品装入背包时可以选择背包的一部分，而不是必须全部装入。程序实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sort&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">item</span> <span class="p">[][</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="nx">item</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="nx">item</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">this</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">this</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">this</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="nx">item</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">this</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">this</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">}</span>
	<span class="nx">w</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Knapsack_greedy</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Knapsack_greedy</span><span class="p">(</span><span class="nx">N</span><span class="p">,</span> <span class="nx">C</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="c1">// 计算价值重量比，并存入解数组，解数组每个元素是长度为3的数组
</span><span class="c1"></span>	<span class="c1">// 其中，第一个为比值，第二个为物品价值，第三个为物品重量
</span><span class="c1"></span>	<span class="nx">x</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">/</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]})</span>
	<span class="p">}</span>

	<span class="c1">// 对价值重量比进行降序排列
</span><span class="c1"></span>	<span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>

	<span class="c1">// 按序装入背包
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">C</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">res</span> <span class="o">+=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">C</span> <span class="o">-=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="c1">// 装入第 i 个物品的一部分
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">+=</span> <span class="nx">C</span> <span class="o">*</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="c1">// Output:
</span><span class="c1"></span><span class="mi">37</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度为 $O(N)$，空间复杂度为 $O(N)$</p>
<h3 id="14-回溯">1.4 回溯</h3>
<p>回溯也是解背包问题的一种方法，可以和递归法进行对比，递归法其实就相当于对解空间树进行了一次搜索，回溯的目的是减小搜索空间。</p>
<p>设物品重量为 $w=[16,15,15]$，物品价值为 $v=[45,25,25]$，背包容量 $c=30$。定义 $r$ 为当前背包的剩余容量，$v$ 为当前背包的价值。因为物品有 3 个，所以树深为 3+1=4，又因为每个解元素有两种取值，1为放入背包，0为不放入，所以每个结点有两棵子树，最终解空间树绘制如下</p>
<p></p>
<p>约束和限界函数描述如下</p>
<ol>
<li>约束函数：就是不可行的解，比如上图第二层第一个结点，r=14，小于当前物品重量 15，因此所有子树都不可行；</li>
<li>限界函数：就是非最优解，比如上图虚线框起来的结点，因为之前得到的最大价值为 v=50，这里出现的 v 都小于该值，所以不是最优解。右子树价值上界的判断使用的是价值重量比的贪心策略。</li>
</ol>
<p>算法如下</p>
<p></p>
<p></p>
<h3 id="15-分支限界">1.5 分支限界</h3>
<p>如果回溯能解，那么分支限界就能解</p>
<ol>
<li>首先检查当前扩展结点的左儿子结点(x[i]=1)的可行性。 如果该左儿子结点是可行结点，则将它加入到子集树 和活结点优先队列中。</li>
<li>当前扩展结点的右儿子结点(x[i]=0)一定是可行结点，仅 当右儿子结点满足上界约束时才将它加入子集树和活 结点优先队列。
<ul>
<li>节点的优先级由上界函数来决定，即已装袋的物品价值与剩下 的最大单位重量价值的物品装满剩余容量的价值之和。</li>
</ul>
</li>
<li>当扩展到活结点优先队列中的叶结点时得到问题的最 优解。</li>
</ol>
<p></p>
<p></p>
<h2 id="2-完全背包">2. 完全背包</h2>
<p>完全背包问题相比于01背包的区别就是，只要背包装的下，每个物品可以选任意次，而不是只有一次。</p>
<p>此时解向量的值不再是0或者1，而是有了多种可能，注意的是，这里物品不能只装入一部分，因此贪心算法是不可用的。举个反例也非常简单：假设有两个物品A和B，价值分别为5和8，重量分别为5和7，背包容量为10，物品B的价值重量比显然更高，所以贪心算法会放入一个物品B，此时剩余容量不足以放下 A或者B，得到的总价值为8，但实际上，放入两个 A 可以得到更高的价值10。</p>
<p>我们用动态规划求解，$m(i,j)$ 依然代表当前背包剩余容量为 $j$ 时，可选物品为 $i,i+1,&hellip;,n$ 时的最大总价值，对于第 $i$ 中物品，我们有 $k$ 种选择，这样得到状态转移方程
$$
m(i,j) = max{m(i+1,j-w_ik)+v_ik}; 0 \le w_ik \le j
$$
实质就是0-1背包加一层选择物品数量的循环，程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">}</span>
	<span class="nx">w</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Knapsack_dp</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Knapsack_dp</span><span class="p">(</span><span class="nx">N</span><span class="p">,</span> <span class="nx">C</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 状态数组初始化
</span><span class="c1"></span>	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">C</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">C</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">k</span><span class="o">*</span><span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">j</span> <span class="p">{</span>
			<span class="nx">k</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="c1">// 填写状态数组, 自底向上，自左到右
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">C</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span><span class="o">*</span><span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="nx">k</span><span class="o">*</span><span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">+</span><span class="nx">k</span><span class="o">*</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">C</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
<span class="c1">// Output:
</span><span class="c1"></span><span class="mi">50</span>
</code></pre></td></tr></table>
</div>
</div><p>拿上面程序中的测试用例来看，dp 数组绘制如下，数组的格式也是相同的，不同的就是填充每一个元素时是挑选了可得到的最大值填充的。</p>
<p></p>
<p>和01背包一样，dp 数组也可以优化为一维数组。</p>
<h2 id="3-多重背包">3. 多重背包</h2>
<p>多重背包问题是在完全背包的基础上又加了一个条件，那就是每个物品的数量是有限制的，不再是只要背包放得下，就可以无限地往里放。</p>
<p>很容易我们就会发现，解题的程序基本和完全背包没什么区别，只是在填充元素选择最优值时要对物品数量进行判断，不能超过物品数量上限，这里就写程序了。</p>
<p><a href="https://www.cnblogs.com/mfrank/p/10533701.html">https://www.cnblogs.com/mfrank/p/10533701.html</a></p>]]></description></item><item><title>算法-分支限界</title><link>https://shuzang.github.io/algorithm-branch-and-bound/</link><pubDate>Thu, 23 Jul 2020 10:07:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-branch-and-bound/</guid><description><![CDATA[<p>分支限界和回溯都是有效搜索解空间树的方法，不同的是，分支限界使用广度优先或最小耗费/最大效益优先的方式。</p>
<h2 id="1-基本思想">1. 基本思想</h2>
<p>首先介绍几个概念</p>
<ul>
<li>活结点：自身已生成但其儿子节点还未全部生成的结点</li>
<li>扩展结点：当前正在处理的结点</li>
<li>死结点：所有儿子已经生成</li>
<li>叶结点：可行解</li>
</ul>
<p>知道了这几个概念后，分支限界的思想可以描述为：在扩展结点处，先生成其所有儿子结点（分支），在每一个活结点处，估算目标函数的界（限界）。那些导致不可行解或非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中，然后根据已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进。当一个叶结点称为扩展结点时（此时活结点表中其它结点的函数值均不超过该叶结点的函数值），该叶结点相应的解即为问题的最优解。</p>
<p>所以可以看出，剪枝的方法和回溯基本相同，不同的是，同一层的所有可行结点组成了一个活结点列表，每次需要在活结点列表中寻找最优的解，实现活结点列表主要有两种方式</p>
<ul>
<li>队列</li>
<li>优先队列</li>
</ul>
<p></p>
<h2 id="2-旅行旅行商问题">2. 旅行旅行商问题</h2>
<p>某售货员要到若干城市去推销商品，已知 各城市之间的路程(或旅费)。他要选定一条从驻地出发，经过每个城市一次，最后回到驻地的路线，使总的路程(或总旅费)最小。</p>
<p>旅行商问题的解空间树中，从根结点到任一叶结点就是一条售货员的行走路径，所以我们要做的就是构建这棵树然后找到根结点到叶子结点的最小路径和。</p>
<p>如下，假设有一个在 4 个城市推销商品的例子，构建解空间树如下</p>
<p></p>
<p>我们选择第 1 个城市作为起点，所以把它加入活结点列表，由于当前只有它一个活结点，将其作为扩展结点。此时当前路程费用为 0 （因为还没开始走），限界函数 rcost 的值为 18，这个数字是这样得到的</p>
<ul>
<li>rcost 代表限界函数，其作用应当是找到可行的最优解，这里的最优解就是剩下的路程费用之和最低；</li>
<li>剩下的路程费用之和的下界应当这样来计算：所有没有走过的城市相邻边的最小值之和，也就是还没有访问的所有结点的最小出边费用之和，在当前，还位于起点，这就意味着所有的城市都还没走出去，那么四个城市相邻的边的最小值之和就是 rcost = 4(第一个城市) + 5（第2个城市）+ 5（第三个城市）+ 4（第4个城市）= 18</li>
<li>我们应当对活结点列表中所有活结点的 cc 值进行比较（cc 是当前路程费用），选择值最小的那个结点作为扩展结点，不过此时活结点列表只有第一个城市，所以只能选择它。</li>
</ul>
<p>接下来就构建当前扩展结点的儿子结点，遍历所有其它节点，所有与当前扩展结点相邻的城市加入活结点列表，然后计算所有活结点的 cc 值，选择值最小的那一个，这里是第四个城市，以此类推，最终到达叶节点，此时得到了第一个 rcost 值，也就是当前最短回路的费用，其后只要选择 rcost 最小的那个就好。</p>
<p>算法思想可以描述如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//初始化。s：结点在排列树中的层次，cc：当前费用，rcost：x[s:n-1]中顶点,最小出边费用和， bestc：当前最优值
</span><span class="c1"></span><span class="nx">s</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span><span class="p">;</span><span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">+=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="err">…</span><span class="p">,</span><span class="nx">n</span><span class="p">);</span><span class="nx">cc</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">rcost</span><span class="p">=</span><span class="nx">Minout</span><span class="o">*</span><span class="mi">1</span><span class="o">++</span><span class="nx">Minout</span><span class="o">*</span><span class="mi">2</span><span class="o">++</span><span class="err">…</span><span class="o">+</span><span class="nx">Minout</span><span class="o">*</span><span class="nx">n</span><span class="o">+</span>
<span class="nx">bestc</span><span class="p">=</span><span class="nx">NoEdge</span>
<span class="c1">//搜索排列树
</span><span class="c1"></span><span class="nx">While</span> <span class="nx">当前扩展结点非叶结点</span>
	<span class="k">if</span> <span class="nx">当前扩展结点是叶结点的父结点</span>
		<span class="k">if</span> <span class="nx">叶结点存在一条可行回路且该回路的费用小于当前最优值</span>
			<span class="nx">bestc</span> <span class="p">=</span> <span class="nx">该回路的费用</span>
			<span class="nx">将叶结点插入活结点优先队列</span><span class="err">（</span><span class="nx">最小堆</span><span class="err">）</span>
		<span class="k">else</span> <span class="nx">舍弃该扩展结点</span>
	<span class="k">else</span> <span class="nx">产生当前扩展结点的儿子结点</span>
		<span class="k">for</span> <span class="nx">i</span><span class="p">=</span><span class="nx">s</span><span class="o">+</span><span class="mi">1</span> <span class="nx">to</span> <span class="nx">n</span> <span class="nx">do</span>
			<span class="nx">更新可行儿子结点的状态</span><span class="err">：</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">rcost</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">cc</span> <span class="o">+</span> <span class="nx">rcost</span> <span class="c1">//更新子树的下界
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span> <span class="p">&lt;</span> <span class="nx">bestc</span> <span class="c1">//子树可能含最优解
</span><span class="c1"></span>				<span class="nx">将结点插入活结点优先队列</span><span class="err">（</span><span class="nx">最小堆</span><span class="err">）</span>
<span class="c1">// 从活结点优先队列中取下一扩展结点
</span></code></pre></td></tr></table>
</div>
</div><h2 id="3-最大团问题">3. 最大团问题</h2>
<p>给定一个无向图G=(V,E)。如果U包含于V，且对任 意u,v属于U有(u,v)属于E，则称U是G的一个完全子 图。G的完全子图U是G的一个团当且仅当U不包含 在G的更大的完全子图中。G的最大团是指G中所 含顶点数最多的团。</p>
<p>例如，子集{1,2}是G的一个大小为2的完全子图，但不 是一个团，因为它包含于G的更大的完全子图{1,2,5}中。 {1,2,5}、{1,4,5}和{2,3,5}都是G的最大团。</p>
<p></p>
<p>上面的问题其实是图G的顶点集V的子集选取问题，解空间树可以看作一个子集树，剪枝的方法总结如下</p>
<ul>
<li>左子树：从顶点i到已选入的顶点集中每一个顶点都有边， 否则剪枝</li>
<li>右子树：顶点数上界小于当前最优值时剪枝，顶点数上界 = 已确定的顶点数 + 未确定的顶点数的上界</li>
</ul>]]></description></item><item><title>算法-回溯</title><link>https://shuzang.github.io/algorithm-backtracking/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-backtracking/</guid><description><![CDATA[<p>在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Branch&amp;Bound）就是两种减小搜索空间大小的技术。</p>
<h2 id="1-回溯的基本思想">1. 回溯的基本思想</h2>
<h3 id="11-解空间树">1.1 解空间树</h3>
<p>假设可以用一个 n 元组 $X=(x_1,x_2,……,x_n)$ 来表示所求问题的解，其中 $x_i$ 的取值范围为某个有穷集合 S。我们把 $X=(x_1,x_2,……,x_n)$ 所有可能取值的组合称作问题的解空间。</p>
<p>举个例子，假设 0-1 背包问题中物品有 3 个，用 $X=(x_1,x_2,x_3)$ 表示，其中 $x_i \in \{0,1\}, 1 \leq i \leq 3$，则问题的解空间为 $\{(0,0,0),(0,1,0),(0,0,1),(1,0,0),(0,1,1),(1,0,1),(1,1,0),(1,1,1)\}$</p>
<p>我们用一颗 n+1 层的树来表示解空间，其中，第 i 层和第 i+1 层之间边的标号表示变量 $x_{i+1}$ 的可能取值，从根结点到叶节点路径上的标号就构成问题的一个可能的解。</p>
<p></p>
<p>我们还可以这样理解解空间，将解空间划分为两个维度：一个可行解中元素的个数和每个元素的取值范围。这两者正好对应解空间树的深度（实际是深度-1）和宽度。比如在上面的 0-1 背包问题中，问题的一个解由一个 3 元组 $X=(x_1,x_2,x_3)$  表示，这里每个解中有 3 个元素，因此解空间树的深度是 4，每个元素有 0 和 1 两个取值，因此每个节点有两棵子树。</p>
<p>注：这里树的深和宽不是标准化的说法，仅为了便于说明。理解上面这段话非常有利于实际解决问题时解空间树的构造。</p>
<h3 id="12-基本思想">1.2 基本思想</h3>
<p>回溯的基本思想是：在问题的解空间树中，按照深度优先的策略，从根结点出发搜索。搜索至任一结点时，先判断该结点和其儿子结点的边所标记的值是否满足解的要求，是就加入到解中，继续向下深度优先搜索以其儿子结点为根的子树，否则就结束对以该儿子结点为根的子树的搜索，选择对另一个儿子结点作为根的子树进行搜索。全部搜索完毕或都不满足就向父节点回溯。</p>
<p>仍以 0-1背包问题为例，设物品重量为 $w=[16,15,15]$，物品价值为 $v=[45,25,25]$，背包容量 $c=30$。定义 $r$ 为当前背包的剩余容量，$v$ 为当前背包的价值。因为物品有 3 个，所以树深为 3+1=4，又因为每个解元素有两种取值，1为放入背包，0为不放入，所以每个结点有两棵子树，最终解空间树绘制如下</p>
<p></p>
<p>遇到某个结点判断与儿子结点的边是否满足条件时，用到剪枝函数，分两种</p>
<ol>
<li>约束函数：就是不可行的解，比如上图第二层第一个结点，r=14，小于当前物品重量 15，因此子树不可行；</li>
<li>限界函数：就是非最优解，比如上图虚线框起来的结点，因为之前得到的最大价值为 v=50，这里出现的 v 都小于该值，所以不是最优解。</li>
</ol>
<p>我们理解了基本思想后，就可以很容易的发现回溯的最坏时间复杂度是 $O(N×2^N)$</p>
<h3 id="13-一般步骤">1.3 一般步骤</h3>
<p>回溯法的一般步骤为</p>
<ol>
<li>针对所给问题，定义问题解空间</li>
<li>确定易于搜索的解空间树</li>
<li>以深度优先的方式搜索解空间树，并在搜索过程中用剪枝函数避免无效搜索
<ul>
<li>用约束函数考察左子树是否可行</li>
<li>用限界函数考察右子树是否（有可能）最优</li>
</ul>
</li>
</ol>
<p>经常用回溯法解决的问题有两类：子集树和排列树。<strong>子集树</strong>是从 n 个元素的集合中找出满足某种性质的子集，<strong>排列树</strong>是确定 n 个元素满足某种性质的排列，下面分别介绍两类问题的思路。</p>
<h2 id="2-子集树">2. 子集树</h2>
<p>给定一个不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener noreffer">leetcode 78题-子集</a></p>
<p>注：解集不能包含重复的子集</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">示例输入: nums = [1,2,3]
示例输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre></td></tr></table>
</div>
</div><p>回溯法可以保证生成的结果完整无冗余，实际上，就是输出整棵子集树（解空间树）。本题中，解向量的维度是 3 ，每个解元素有选择和不选择两种可能，因此解空间树是一颗4层的二叉树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">subsets</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">// 使用闭包可以节省 nums,res,cur 三个参数的传递，同时避免 res 的全局定义
</span><span class="c1"></span>    <span class="c1">// 必须事先声明，否则无法在函数中调用自身
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">backTrace</span> <span class="kd">func</span><span class="p">(</span><span class="nx">level</span> <span class="kt">int</span><span class="p">)</span> 
    <span class="c1">// 回溯的思路是每个元素都有选择与不选择两种可能，解空间树是一棵 n+1 层二叉树
</span><span class="c1"></span>    <span class="nx">backTrace</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">level</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// len(nums)+1 层说明位于叶子节点，将当前可行解加入结果数组
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">level</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 建立一个新切片，将结果复制到新切片，然后再添加到结果集，因为 cur 是指向结果的指针，指向的结果后面还会变动
</span><span class="c1"></span>            <span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">))</span>
            <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">cur</span><span class="p">)</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>

        <span class="c1">// 遍历二叉树的两个分叉
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="c1">// i 为 0 表示当前元素不加入当前解
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">backTrace</span><span class="p">(</span><span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="nx">cur</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="nf">backTrace</span><span class="p">(</span><span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">// 删除当前元素然后进行回溯
</span><span class="c1"></span>                <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nf">backTrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>一种常用的减小时空复杂度的方法是位运算，用于每个元素的可能取值为 0 和 1 的情况。取值只有 0 和 1 的情况下，我们可以将一条完整的路径看作一个二进制数字，比如一个 n+1 层的二叉树的每一个可行解都可以看作一个 n+1 位的二进制数字，二进制数字的每一位代表该层的元素选择或不选择，这样，只要生成所有可能的二进制数就构成了一个完整的解空间，程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">subsets</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">ln</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
    <span class="c1">// 这样移位保证左边0的存在，比如一共3位，保证001而不是0，可以从 1000 到 10000 进行遍历，取每个值的右边三位
</span><span class="c1"></span>    <span class="nx">s</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">ln</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">ln</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> 
    <span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">e</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">tmp</span> <span class="p">[]</span><span class="kt">int</span> 
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">ln</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="c1">// 通过与运算判断当前位是否为1，为1则加入结果，i为当前元素
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">i</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">j</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> 
                <span class="nx">tmp</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的子集树问题还有另一种回溯思路，那就是单独计算每一种可能长度的解的集合，然后统一添加到最终的集合。比如对于 nums=[1,2,3]，一个元素的解集为{[1],[2],[3]}，两个元素的解集为{[1,2],[2,3],[1,3]}，三个元素的解集为{[1,2,3]}，再加上空集，就是总的结果。程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">subsets</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">// 使用闭包可以节省 nums 和 res 两个参数的传递，同时避免 res 的全局定义
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">backTrace</span> <span class="kd">func</span><span class="p">(</span><span class="nx">cur</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span><span class="nx">length</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// 必须事先声明，否则无法在函数中调用自身
</span><span class="c1"></span>    <span class="nx">backTrace</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">cur</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span><span class="nx">length</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 结束条件为元素个数达到了当前限定的长度
</span><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span> <span class="o">==</span> <span class="nx">length</span> <span class="p">{</span>
            <span class="c1">// 将结果复制到新切片后再添加到结果集，因为 cur 是指向结果的指针，指向的结果后面还会变动
</span><span class="c1"></span>            <span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">length</span><span class="p">)</span>
            <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">cur</span><span class="p">)</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>

        <span class="c1">// 可以看作遍历子树，儿子节点所有可能的取值是未使用过的值，也就是索引 index 之后的值
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="c1">// 当前节点加入结果，然后递归遍历子树
</span><span class="c1"></span>            <span class="nx">cur</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
            <span class="nf">backTrace</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">length</span><span class="p">)</span>
            <span class="c1">// 进行回溯，去除当前结果，回到上一层
</span><span class="c1"></span>            <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 对于每个长度的序列，将所有可能加入最终的结果集
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="nf">backTrace</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用回溯法搜索子集树的一般算法为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">Backtrack</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
  <span class="c1">//t：递归深度，即当前活动结点在解空间树中的深度，根节点t=1
</span><span class="c1"></span>  <span class="c1">//n：解空间树的高度，即问题的规模
</span><span class="c1"></span>  <span class="c1">//算法已搜索到一个叶结点，对可行解x进行记录或输出
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">t</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="nf">output</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
  <span class="k">else</span>
  <span class="c1">//搜索当前活动结点的子树
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span> <span class="nx">to</span> <span class="mi">1</span> <span class="nx">do</span> <span class="c1">//以二叉树为例  
</span><span class="c1"></span>      <span class="nx">x</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>  <span class="c1">//当前活动结点x[t]的第i个取值
</span><span class="c1"></span>      <span class="c1">//满足约束条件且目标函数未越界时，搜索子树
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nf">Constraint</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="nx">and</span> <span class="nf">Bound</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span>
        <span class="nf">Backtrack</span><span class="p">(</span><span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果说上面求子集的例子其实是求所有的可能，没有进行剪枝，下面可以给出另一个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">题目：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例：
输入：n = 3
输出：[
       &#34;((()))&#34;,
       &#34;(()())&#34;,
       &#34;(())()&#34;,
       &#34;()(())&#34;,
       &#34;()()()&#34;
     ]
</code></pre></td></tr></table>
</div>
</div><p>程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>

    <span class="kd">var</span> <span class="nx">backTrace</span> <span class="kd">func</span><span class="p">(</span><span class="nx">level</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">backTrace</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">level</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">level</span> <span class="p">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">n</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span> <span class="p">{</span>
                <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">cur</span><span class="p">))</span>
            <span class="p">}</span>            
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
            <span class="nx">a</span><span class="o">++</span>
            <span class="nf">backTrace</span><span class="p">(</span><span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  
            <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="nx">a</span><span class="o">--</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">b</span> <span class="p">&lt;</span> <span class="nx">a</span> <span class="p">{</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
            <span class="nx">b</span><span class="o">++</span>
            <span class="nf">backTrace</span><span class="p">(</span><span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="nx">b</span><span class="o">--</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="nf">backTrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 a &lt; n 和 b &lt; a 就是用来剪枝的，回溯的一个关键步骤就是在调用回溯函数之前添加到结果集，之后从结果集删除，这就是回溯的本质含义。</p>
<h2 id="3-排列树">3. 排列树</h2>
<p>以全排列的例子开头，<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener noreffer">leetcode 64题-全排列</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">题目：给定一个没有重复数字的序列，返回其所有可能的全排列。
示例输入: [1,2,3]
示例输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre></td></tr></table>
</div>
</div><p><strong>排列与子集问题的区别在于每一层子树的个数都减1</strong>，因为已选择的元素不必再次出现，因此，全排列问题是一棵4层，然后每层子树个数依次减一的树，这样时间复杂度也很容易理解，就是 $N!$。</p>
<p>解上面问题的程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">backTrace</span> <span class="kd">func</span><span class="p">(</span><span class="nx">level</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">backTrace</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">level</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">level</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">))</span>
            <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">cur</span><span class="p">)</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">level</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
            <span class="c1">// nums 数组中，level-1 索引前的是已用过的，不能选，只能选 level-1 之后的，在未选元素
</span><span class="c1"></span>            <span class="c1">//集合中选了任何一个元素后，与未选元素集合的第一个交换，相当于把刚刚选择的元素加入了已选元
</span><span class="c1"></span>            <span class="c1">//素集合，到下一层索引向前移动一格，就保证了下一层的未选元素集合正确
</span><span class="c1"></span>            <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="nf">backTrace</span><span class="p">(</span><span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">level</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">backTrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>思路和子集树基本相同，多的一个步骤交换是用来处理每层子树个数减一这个问题的，实质是不断的调整未选择元素的集合。交换是一种高效的做法，除此之外，还可以用一个 Map 来标记已选和未选元素。</p>
<p>用回溯法搜索排列树的一般算法为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Backtrack(k)
  //t：递归深度，即当前活动结点在解空间树中的深度，根节点t=1
  //n：解空间树的高度，即问题的规模
  //算法已搜索到一个叶结点，对可行解x进行记录或输出
  if t &gt; n output(x)
  else
  //搜索当前活动结点的子树
  //处理[t:n]的排列
    for i = t to n do 
      swap(x[t],x[i])
      //满足约束条件且目标函数未越界时，搜索子树
      if (Constraint(t) and Bound(t))
        Backtrack(t+1)
      swap(x[t],x[i]) // 回溯到交换之前
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>算法-贪心</title><link>https://shuzang.github.io/algorithm-greedu/</link><pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-greedu/</guid><description><![CDATA[<p>贪心是一种策略，是一种总是寻求当前最优的策略。因为贪心只关心局部的最优，因此不是总能得到全局的最优解，所以我们选择贪心解决问题时必须保证状态的独立性，即当前最优值只与当前状态有关，不会影响以后的状态。</p>
<p>动态规划与贪心的区别在于动态规划状态之间是有联系的，这也是状态转移方程的制定依据，但它们也有相同之处，那就是原问题的最优解必须包含子问题的最优解，这条性质叫做最优子结构性质，这是一个问题可用动态规划或贪心来解决的基础。</p>
<p>下面我们通过一系列的问题来说明贪心问题，尤其要关注的是贪心策略的选取。</p>
<h2 id="1-背包问题">1. 背包问题</h2>
<p><strong>问题描述</strong>：给定 n 种物品和一个背包。物品 i 的重量是 $w_i$，其价值为 $v_i$，背包的容量为 c。问应如何选择装入背包 的物品，使得装入背包中物品的总价值最大?</p>
<p>背包问题是可用贪心来解决的，直觉上，可以有以下几种贪心选择策略</p>
<ol>
<li>价值贪心：优先选择价值最大的物品，但这种方法如果选择的物品重量很大，背包载重的消耗速度会很快；</li>
<li>重量贪心：优先选择重量最小的物品，这种方法又不能保证价值快速增加；</li>
<li>价值重量比：将物品重量按单位重量的价值降序排列，依次装入，这样能保证最优。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// n 为物品数量，M为背包容量，v,w 分别为单个物品的价值和重量，x为解向量
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Knapsack_greedy</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">M</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span><span class="nx">w</span><span class="p">,</span><span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sort</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">v</span><span class="p">,</span><span class="nx">w</span><span class="p">)</span> <span class="c1">// 按照单位重量价值进行排序
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span> <span class="c1">// 初始化解向量
</span><span class="c1"></span>        <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="nx">c</span> <span class="p">=</span> <span class="nx">M</span> <span class="c1">// c 是背包当前载重
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">c</span> <span class="p">{</span>
            <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="nx">c</span> <span class="o">-=</span> <span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="p">{</span>
        <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span><span class="o">/</span><span class="nx">w</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="c1">// 装入第 i 个物品的部分
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果想要证明该问题使用贪心算法是可行的，可以按如下思路：首先证明原问题的一个最优解是以贪心选择开始。然后假设i次贪心选择能 够得到一个最优解，那么证明i+1次贪心选择也能得到一个最优解。一个图解如下</p>
<p></p>
<h2 id="2-活动安排问题">2. 活动安排问题</h2>
<p>要求高效地安排一系列争用某一公共资源（如会议室）的活动，使尽可能多的活动能兼容使用公共资源，这就是活动安排问题。</p>
<p>设有 n 个活动的集合 $E={e_1 ,e_2…e_n}$，其中每个活动都要求使用同一资源，而在同一时间内只有一个活动能使用 这一资源。每个活动 i 都有一个要求使用该资源的起始 时间 $s_i$ 和一个结束时间 $f_i$，且 $s_i &lt; f_i$。如果选择了活动 i，则它在半开时间区间 $[s_i ,f_i)$内占用资源。若区间$[s_i ,f_i)$与区间$[s_j ,f_j)$不相交，则称 $e_i$和$e_j$ 是相容的。 也就是说，当 $s_i≥f_j$ 或 $s_j≥f_i$ 时，活动 i 和活动 j 相容。</p>
<p>我们可以想到的贪心策略有</p>
<ol>
<li>选择具有最早开始时间的活动</li>
<li>选择具有最早结束时间的活动</li>
<li>选择具有最少占用时间的活动</li>
<li>选择覆盖未选择活动最少的活动</li>
</ol>
<p>但直观上，每次选择具有最早结束时间的相容活动，使剩余 的可安排时间段极大化，以便安排尽可能多的相容活动。事实也是如此，我们用图来说明一个实例</p>
<p></p>
<p>实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// n 为活动数量，s,f分别为每个活动的起始和结束时间，A为结果集合
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GreedySelector</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span><span class="nx">f</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">A</span> <span class="p">[]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">f</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
            <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>算法-动态规划</title><link>https://shuzang.github.io/algorithm-dynamic-programming/</link><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-dynamic-programming/</guid><description><![CDATA[<p>动态规划策略通常用于求解最优化问题。在这类问题中，可能会有许多可行解，每个解对应一个值，我们希望找到具有最优值的那个解，也就是最优解。当题目中涉及「最大」「最小」等词时，很有可能就是这类问题，要考虑是否可用动态规划求解。</p>
<h2 id="1-基本介绍">1. 基本介绍</h2>
<p>动态规划（Dynamic Programming, DP）的思想与分治法很类似，也是把待求解问题分解成若干子问题，不同的是，分治法的子问题是相互独立的，而动态规划的子问题可能重复。我们通过保存已解决的子问题的答案，在需要时就可以直接访问这些已求得的答案，这样可以避免大量重复计算，从而得到多项式时间内的算法。</p>
<p></p>
<h3 id="11-找零钱问题">1.1 找零钱问题</h3>
<p>这里拿一个找零钱的问题举例：假设有4分、3分、1分三种硬币面值，要找给顾客6分钱，应该怎么做？我们按以下步骤来思考：</p>
<ol>
<li>
<p>假设要找给顾客的是1分钱，那么只需要一个1分面值的硬币</p>
</li>
<li>
<p>假设找2分钱，需要两个1分面值的硬币（1分 + 1分）</p>
</li>
<li>
<p>假设找3分钱，需要一个3分面值的硬币</p>
</li>
<li>
<p>假设找4分钱，需要一个4分面值的硬币</p>
</li>
<li>
<p>假设找5分钱，可能是</p>
<ul>
<li>
<p>1 + 4：1个1分面值 + 1个4分面值（硬币数最少）</p>
</li>
<li>
<p>2 + 3：2个1分面值 + 1个3分面值</p>
</li>
</ul>
</li>
<li>
<p>假设找6分钱，可能是</p>
<ul>
<li>
<p>1 + 5：1个1分面值 + （1个1分面值 + 1个4分面值）</p>
</li>
<li>
<p>2 + 4：1个1分面值 + 1个4分面值</p>
</li>
<li>
<p>3 + 3：1个3分面值 + 1个3分面值</p>
</li>
</ul>
</li>
</ol>
<p>找2分钱的时候重复利用了找1分钱的结果，不过这个不是很明显，最明显的是，找6分钱的时候重复利用了找5分钱的结果（5分钱中 1+4 是最优解法）</p>
<h3 id="12-常用概念">1.2 常用概念</h3>
<p>动态规划中涉及的一些术语解释如下</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶段（stage）</td>
<td>将所给问题的过程，按时间或空间特征分解成若干相互联系的阶段，以便按次序去求每阶段的解</td>
</tr>
<tr>
<td>状态（state）</td>
<td>各阶段开始时的客观条件叫做状态</td>
</tr>
<tr>
<td>决策（decision）</td>
<td>当各阶段的状态确定后，就可以做出不同的决定，从而确定下一阶段的状态，这种决定称为决策</td>
</tr>
<tr>
<td>状态转移（transition）</td>
<td>根据上一阶段的状态和决策来导出本阶段的状态</td>
</tr>
</tbody>
</table>
<p>对动态规划思想中<strong><ruby>重叠子问题<rt>overlapping subproblem</rt></ruby></strong>的理解是：前一个阶段的状态可以带当前阶段，当前阶段的状态可以带到下一个阶段，利用表格记录之前所有阶段的状态。放在找零钱问题中，找5分钱得到的状态是 「1个1分 + 1个4分」，这一状态被存起来（通常是一个数组），到下一状态，也就是找6分钱的时候，就可以直接应用这个结果。</p>
<p>从分析中可以看到，我们在每个阶段用的都是上一个阶段的最优解，这就要求我们遇到的问题也必须符合这个性质才能应用动态规划算法。只有原问题的最优解包含子问题的最优解，我们才能自底向上地从子问题的最优解逐步构造出原问题的最优解。</p>
<h3 id="13-算法的基本步骤">1.3 算法的基本步骤</h3>
<ol>
<li><strong>分析最优解的结构</strong>。这一阶段需要我们证明原问题的最优解包含子问题的最优解，运用反证法。首先假设由原问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题的最优解更好的解，从而导致矛盾。</li>
<li><strong>递归定义最优值</strong>。建立当前阶段最优值和前一阶段最优值的递推关系式，当前阶段的决策为：选中可能解中的最优解。</li>
<li><strong>计算最优值</strong>。以自底向上的方式在表格中存储各个阶段的最优值。</li>
<li><strong>构造最优值</strong>。从原问题的最优值开始，根据计算各个阶段最优值时得到的信息回溯。</li>
</ol>
<p>一个容易看懂的步骤为</p>
<ol>
<li>表示解</li>
<li>表示最优解</li>
<li>根据原问题的最优解和子问题的最优解的关系确定状态转移方程</li>
<li>确定边界条件</li>
<li>利用 dp 数组记录状态，编写程序解决</li>
</ol>
<p>以最长公共子序列问题为例，使用上述步骤解决，问题描述如下</p>
<blockquote>
<p>给定2个序列 $X=\{x_1,x_2,……,x_m\}$ 和 $Y=\{y_1,y_2,……,y_n\}$，找出 X 和 Y 的最长公共子序列。</p>
<ul>
<li>公共子序列只需要保持下标递增的相对顺序即可，元素可以不相邻。例如，序列 $Z=\{B,C,D,B\}$ 是序列 $X=\{A,B,C,B,D,A,B\}$ 的一个子序列，相应的递增下标序列为 $\{2,3,5,7\}$</li>
<li>给定2个序列 X 和 Y ，当另一个序列 Z 既是 X 子序列又是 Y 的子序列时，称 Z 是序列 X 和 Y 的公共子序列</li>
</ul>
</blockquote>
<p><strong>分析最优解结构</strong></p>
<p>设序列 $X=\{x_1,x_2,……,x_m\}$ 和 $Y=\{y_1,y_2,……,y_n\}$ 的最长公共子序列为 $Z=\{z_1,z_2,……,z_k\}$。</p>
<p>$X_{m-1}=\{x_1,x_2,……,x_{m-1}\}$;$Y_{n-1}=\{y_1,y_2,……,y_{n-1}\}$;$Z_{k-1}=\{z_1,z_2,……,z_{k-1}\}$</p>
<ul>
<li>若 $x_m = y_n$，则 $z_k = x_m = y_n$，且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的最长公共子序列</li>
<li>若 $x_m \neq y_n$，且 $z_k \neq x_m$，则 $Z$ 是 $X_{m-1}$ 和 $Y$ 的最长公共子序列</li>
<li>若 $x_m \neq y_n$，且 $z_k \neq y_n$，则 $Z$ 是 $X$ 和 $Y_{n-1}$ 的最长公共子序列</li>
</ul>
<p>这里假设了最优解，然后分析了三种情况的子问题最优解都包含在原问题的最优解中。</p>
<p><strong>递归定义最优值</strong></p>
<p>定义 $C[i][j]$ 是 $X_i$ 和 $Y_j$ 的最长公共子序列的长度，其中， $X_i=\{x_1,x_2,……,x_i\}$ ， $Y_j=\{y_1,y_2,……,y_j\}$ 。</p>
<p>递归关系为：</p>
<p></p>
<p>存储结构的示意图为</p>
<p></p>
<p><strong>计算最优值</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">LCSLength(x,y,c,b) {
  m = x.length - 1
  n = y.length - 1
  for i = 1 to m do c[i][0] = 0
  for j = 1 to n do c[0][j] = 0
  for i = 1 to m do
	for j = 1 to n do
	  if x[i] = y[j]
		c[i][j] = c[i-1][j-1] + 1
		b[i][j] = 1 // 表示对角线值
	  else if c[i-1][j] &gt;= c[i][j-1]
		c[i][j] = c[i-1][j]
		b[i][j] = 2 // 表示上值
	  else
		c[i][j] = c[i][j-1]
		b[i][j] = 3 // 表示左值
}
</code></pre></td></tr></table>
</div>
</div><p><strong>构造最优解</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">LCS(i,j,x,b) {
  if i = 0 or j = 0 return
  if b[i][j] = 1
	Lcs(i-1,j-1,x,b)
	print(x[i])
  else if b[i][j] = 2
	Lcs(i-1,j,x,b)
  else 
	Lcs(i,j-1,x,b)
}
</code></pre></td></tr></table>
</div>
</div><p><strong>结果</strong></p>
<p>设给定的两个序列为 $X={x,y,x,z,y,x,y,z,z,y}$，$Y={x,z,y,z,x,y,z,x,y,z,x,y}$，跟踪算法 LCSLength 和 LCS 的运行结果。为简单计，用 $c[i][j] / b[i][j]$ 表示每个阶段的状态，过程如下</p>
<p></p>
<p>根据 OI Wiki，将 DP 问题主要分为九种，下面进行介绍。</p>
<h2 id="2-背包-dp">2. 背包 DP</h2>
<p>背包问题是最经典的问题之一，普遍出现在动态规划部分和运筹学的书中，下面描述问题</p>
<blockquote>
<p>有 n 个物品和一个容量为 W 的背包，每个物品有重量 $w_i$ 和价值 $v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p>
</blockquote>
<h3 id="21-0-1-背包">2.1 0-1 背包</h3>
<p>如果选择装入背包的物品时，每种物品 $i$ 只有两种选择：装入或不装入。不能将物品 $i$ 装入背包多次，也不能只装入部分物品。这就是 0-1 背包问题。</p>
<p>形式化问题为：找出一个 n 元 0-1 向量$（x_1,x_2,……,x_n）$ ，使得 $max \sum_{i=1}^n v_i x_i$，需满足以下两个约束条件
$$
\sum_{i=1}^n w_i x_i \leq c \\
x_i \in \{0,1\}, 1 \leq i \leq n
$$
下面证明该问题具有最优子结构性质，即原问题的最优解包含子问题的最优解。</p>
<ul>
<li>原问题：假设当前有 n 种物品，背包载重为 c</li>
<li>原问题的最优解：$(y_1,y_2,……,y_n)$</li>
<li>子问题：除第一个物品外的 n-1 种物品，背包载重为 $c-w_1y_1$</li>
<li>子问题的最优解：$(y_2,……,y_n)$</li>
</ul>
<p>可以看出，如果原问题和原问题的最优解成立，那么子问题的最优解就成立且包含在原问题的最优解中。</p>
<p>然后来递归定义最优值，通常这个式子也叫做<strong>状态转移方程</strong>。注意证明过程中给出的最优解的序列先后顺序不一定等于物品的序列顺序。我们定义子问题 $P(i,W)$ 为：在前 i 个物品中挑选总重量不超过 W 的物品，只能挑选一个并使总价值最大，这时的总价值（最优值）记作 $m(i,W)$，其中 $i \leq i \leq n; 1 \leq W \leq C$，得到的状态转移方程如下</p>
<p></p>
<p>如果我们确认了状态转移方程的正确，就不要再想其它的了，不然只会陷入思维陷阱。接下来根据方程编写程序计算最优值与构造最优解即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Input: n,C, w[],v[]
for W=0 to C do m[0][W] = 0
for i=0 to n do m[i][0] = 0
for i=1 to n
  for W=1 to C
    if w[i] &gt; W
      m[i][W] = m[i-1][W]
    else
      m[i][W] = max{m[i-1][W], v[i]+m[i-1][W-w[i]]}
 return m[n][C]
</code></pre></td></tr></table>
</div>
</div><h3 id="22-完全背包">2.2 完全背包</h3>
<p>完全背包问题中一个物品可以选取无数次，而不是一次。子问题的定义与0-1背包相同，但状态转移方程有区别
$$
m(i,W) = max\{m(i-1,W),v_i + m(i,W-w_i)\}
$$</p>]]></description></item><item><title>算法-分治</title><link>https://shuzang.github.io/algorithm-divide-and-conquer/</link><pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-divide-and-conquer/</guid><description><![CDATA[<p>分治，字面意思就是分而治之，意思就是把一个复杂的问题分成两个或更多个相同或相似的子问题，解决子问题后再进行合并。典型的如归并排序和快排，都是以分治为基础的。</p>
<p>我们以 <strong>归并排序</strong> 来说明一个典型的分治算法的思路</p>
<p>分治算法可以分三步走：分解 -&gt; 解决 -&gt; 合并</p>
<ol>
<li>分解原问题为结构相同的子问题。</li>
<li>分解到某个容易求解的边界之后，进行递归求解。</li>
<li>将子问题的解合并成原问题的解。</li>
</ol>
<p>归并排序，我们就叫这个函数 <code>merge_sort</code> 吧，按照我们上面说的，要明确该函数的职责，即 <strong>对传入的一个数组排序</strong> 。OK，那么这个问题能不能分解呢？当然可以！给一个数组排序，不就等于给该数组的两半分别排序，然后合并就完事了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="err">一个数组</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="err">可以很容易处理</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">merge_sort</span><span class="p">(</span><span class="err">左半个数组</span><span class="p">);</span>
  <span class="n">merge_sort</span><span class="p">(</span><span class="err">右半个数组</span><span class="p">);</span>
  <span class="n">merge</span><span class="p">(</span><span class="err">左半个数组</span><span class="p">,</span> <span class="err">右半个数组</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>好了，这个算法也就这样了，完全没有任何难度。记住之前说的，相信函数的能力，传给它半个数组，那么这半个数组就已经被排好了。而且你会发现这不就是个二叉树遍历模板吗？为什么是后序遍历？因为我们分治算法的套路是 <strong>分解 -&gt; 解决（触底）-&gt; 合并（回溯）</strong> 啊，先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于 <code>merge</code> 函数，参考两个有序链表的合并，简直一模一样。</p>
]]></description></item><item><title>算法-递归</title><link>https://shuzang.github.io/algorithm-recursive/</link><pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-recursive/</guid><description><![CDATA[<p>首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。</p>
<ol>
<li>递归是一种编程技巧，一种解决问题的思维方式；</li>
<li>分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；</li>
<li>贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。</li>
</ol>
<h2 id="1-递归原理">1. 递归原理</h2>
<p>递归的基本思想是<strong>某个函数直接或者间接地调用自身</strong>，核心在于将原问题拆解为性质相同但规模更小的子问题，函数不断地调用自身来解决子问题，直到分无可分，也就是到了无需递归就可以解决的地步，原问题就顺利解决掉了。</p>
<p>因此我们在思考递归问题时应明确两点</p>
<ol>
<li>明确递推关系，也就是原问题如何拆分到更小的子问题</li>
<li>明确结束条件，也就是最小的问题如何不使用递归来解决</li>
</ol>
<p>我们将递归的基本思路概述为一个模板如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">func</span> <span class="nf">Recursive</span><span class="p">(</span><span class="err">传入数值</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="err">结束条件</span> 
      <span class="k">return</span> <span class="err">最小子问题解</span>
  <span class="n">Recursive</span><span class="p">(</span><span class="err">缩小规模</span><span class="p">)</span>
  <span class="err">利用递归结果进行计算</span><span class="p">[</span><span class="err">可选</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面以一个简单的问题「以相反的顺序打印字符串」来进行说明。我们将函数定义为 <code>printReverse(str[0…n-1])</code>，其中<code>str[0]</code> 表示字符串的第一个字符，然后进行分析</p>
<ol>
<li>分解子问题。原问题可以拆解为先以相反的顺序打印子字符串 <code>str[1…n-1]</code>，然后打印第一个字符 <code>str[0]</code></li>
<li>结束条件。结束条件为如果当前字符串为空，直接返回。</li>
</ol>
<p>最终得到的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">printReverse</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nf">printReverse</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>需要我们牢记的一个结论是：凡是可计算函数都是一般递归函数，这就是著名的丘奇-图灵论点。</p>
<p>继续以「反转链表」为例进行说明，虽然迭代的方法更优，但这里我们只介绍递归的思路。</p>
<ol>
<li>结束条件是当前节点为 nil 或者当前节点的下一个节点为 nil，这两种情况不需要反转</li>
<li>子问题就是反转当前节点后面的部分</li>
<li>递归后要做的事情就是如何将当前节点添加到后面的反转的链表的末尾</li>
</ol>
<p>因此最后得到的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">reverseList</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">head</span>
    <span class="p">}</span>     
    <span class="nx">tmp</span> <span class="o">:=</span> <span class="nf">reverseList</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
    <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">head</span>
    <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">return</span> <span class="nx">tmp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里最后的处理过程可以这样理解，假设列表为：
$$
n_1 → … → n_{k-1} → n_k → n_{k+1} → … → n_m → Ø
$$
若从节点 $n_{k+1}$ 到 $n_m$ 已经被反转，而我们正处于 $n_k$。
$$
n_1 → … → n_{k-1} → n_k → n_{k+1} ← … ← n_m
$$
我们希望 $n_{k+1}$ 的下一个节点指向 $n_k$, 那么只需要调整 $n_k$ 的指针即可，因为此时后面的链表末尾已经是节点 $n_{k+1}$ 了。所以执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">nk</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">nk</span>
<span class="nx">nk</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// 处理边界条件 n1，否则产生循环
</span></code></pre></td></tr></table>
</div>
</div><p>还应该明白代码最后返回的 <code>tmp</code> 不是当前处理节点的下一个节点，而是后面已反转链表的头结点，这个头结点的指针是一级一级递归传回来的。</p>
<p>写递归最重要的一点是： <strong>明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。</strong> 如果跳进一层又一层的递归函数里思考，就会陷入无穷无尽的细节，人脑不是为了做这个的，递归本身就是在简化思维。比如上面的「反转链表」例子，我们确认了子问题具有与原问题相同的性质，因此 <code>reverseList(head.Next)</code> 可以翻转链表后面的部分，我们需要相信这一点，而不是跟随递归进入一层层的调用栈。</p>
<h2 id="2-记忆化技术">2. 记忆化技术</h2>
<p>递归的过程可能出现大量重复的计算，以斐波那契数列为例，如果我们定义函数 <code>F(n)</code> 表示在索引 <code>n</code> 处的斐波那契数，那么你可以推导出如下的递推关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">F(n) = F(n - 1) + F(n - 2)
</code></pre></td></tr></table>
</div>
</div><p>下面的树显示了在计算 <code>F(4)</code> 时发生的所有重复计算（按颜色分组）。</p>
<p></p>
<p>为了消除上述情况中的重复计算，采用的一种方法是将中间结果存储在缓存中，以便随时重用，而不需要重新计算。这种方式叫做记忆化。</p>
<p>记忆化与动态规划的 DP 数组非常相似，但用在递归过程中，一般作为全局变量声明，或者由父函数通过参数进行传递。斐波那契树计算的记忆化方法举例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">cache</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">fib</span><span class="p">(</span><span class="nx">N</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">N</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">N</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">memoize</span><span class="p">(</span><span class="nx">N</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">memoize</span><span class="p">(</span><span class="nx">N</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">N</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">N</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nx">cache</span><span class="p">[</span><span class="nx">N</span><span class="p">]</span> <span class="p">=</span> <span class="nf">memoize</span><span class="p">(</span><span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">memoize</span><span class="p">(</span><span class="nx">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">memoize</span><span class="p">(</span><span class="nx">N</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-复杂度分析">3. 复杂度分析</h2>
<h3 id="31-时间复杂度">3.1 时间复杂度</h3>
<p>给出一个递归算法，其时间复杂度$O(T)$ 通常是<strong>递归调用的数量</strong>（记作 R） 和计算的时间复杂度的乘积（表示为 $O(s)$）的乘积：
$$
O(T) = R * O(s)
$$
以反转字符串为例，由于每次将问题缩减为除第一个字符外的子串，因此函数一共被递归调用 n 次，n 为字符串长度。每次递归调用完毕后，仅仅将第一个字符输出，该操作的时间复杂度为 $O(1)$，因此总体时间复杂度为 $n * O(1) = O(n)$</p>
<p>对于递推关系涉及多个递归调用的情况，比如斐波那契数，其递推关系被定义为 <code>f(n) = f(n-1) + f(n-2)</code>，最好使用执行树来分析时间复杂度。<strong>执行树</strong>是一棵用于表示递归函数执行流程的树，树中每个节点都表示递归函数的调用，因此树的节点总数就对应递归调用的数量。</p>
<p>递归函数的执行树将形成 <code>n 叉树</code>，其中 <code>n</code> 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树。</p>
<p></p>
<p>如果构成了一棵 n 层的完全二叉树，那么节点总数就是 $2^n - 1$，因此时间复杂度计算中的递归调用数量就是 $O(2^n)$，算上最后的结果处理 $O(1)$，总的时间复杂度为 $O(2^n)$</p>
<p>但是如果我们使用了记忆化技术，从 1 到 n 每个值对应的斐波那契数计算只会发生一次，因此递归调用的数量变为 $O(n)$，最终的时间复杂度为 $O(n) * O(1) = O (n)$</p>
<h3 id="32-空间复杂度">3.2 空间复杂度</h3>
<p>空间复杂度考虑两部分：递归相关空间和非递归相关空间。</p>
<p>递归相关空间指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈，为了完成函数调用，系统会在栈中分配空间来保存三个重要信息</p>
<ol>
<li>函数调用的返回地址</li>
<li>传递给函数调用的参数</li>
<li>函数调用的局部变量</li>
</ol>
<p>该空间在函数调用时产生，在调用完成后释放，但对于递归，栈空间将逐渐累积直到结束条件。递归函数中如果没有额外的空间消耗，则递归调用引起的栈空间消耗是递归空间复杂度的主要来源。</p>
<p>仍以反转字符串为例，函数处理逻辑中只有打印首字符会使用常数级空间，递归调用 n 次一共会产生 n 级的栈空间，因此最终的空间复杂度为 $O(n)$。</p>
<p></p>
<p>由于为程序提供的栈空间通常是有限的，在递归调用层级过多时，可能会发生堆栈溢出的情况，此时无法分配新的栈空间进行下一步的递归调用，因此导致程序执行失败。所以在涉及递归算法时，应仔细评估在输入规模扩大时是否存在堆栈溢出的可能性。</p>
<p>非递归相关空间指与递归过程没有直接关系的内存空间，比如上面讨论中提到的打印首字符使用的空间，除此外还可能包括如全局变量等其它的空间使用，比如在利用记忆化优化递归时使用的全局数组，会占用 O(n) 的空间复杂度。</p>
<p>注意，这里递归相关空间与非递归相关空间不是相乘的关系。</p>
<h2 id="4-尾递归">4. 尾递归</h2>
<p>尾递归是递归函数的一种特殊情况，其中递归调用是递归函数的最后一条指令，并且其返回值不是表达式的一部分。举个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 非尾递归
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">helper</span><span class="p">(</span><span class="nx">start</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ls</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">start</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ls</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ls</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">+</span> <span class="nf">helper</span><span class="p">(</span><span class="nx">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">ls</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 尾递归
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">helper</span><span class="p">(</span><span class="nx">start</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ls</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">acc</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">start</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ls</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">acc</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">helper</span><span class="p">(</span><span class="nx">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">ls</span><span class="p">,</span><span class="nx">acc</span><span class="o">+</span><span class="nx">ls</span><span class="p">[</span><span class="nx">start</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>说的更通俗一点就是，调用语句是函数最后一条语句，且返回值不会被用作其它计算。</p>
<p>尾递归的好处是避免递归调用期间栈空间的累积，因为每一层的返回不做处理直接返回，相当于不需要这一步直接返回元素调用。此时我们无需保存每一层递归的环境，这导致了从最高层级到结束条件我们始终重用一个栈空间。</p>
<p></p>
<p>尾递归当然也可以作为非尾递归函数来执行，此时不会重用栈空间，仍然会逐级累积，不过通常编译器会识别尾递归模式进行优化，但这需要编程语言的支持，C、C++支持尾递归优化，Java、Python，我当前使用的 Go 都不支持尾递归优化。</p>
<h2 id="5-原则">5. 原则</h2>
<p>递归的作用非常强大，但可能出现堆栈溢出，因此，可能的情况下，尽量使用记忆化技术节省调用次数，使用尾递归节省栈空间。</p>]]></description></item><item><title>算法-排序</title><link>https://shuzang.github.io/algorithm-sort/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/algorithm-sort/</guid><description><![CDATA[<p>排序算法分为<strong>内部排序</strong>（待排序记录存放在内存中进行的排序过程）和<strong>外部排序</strong>（由于待排序记录数量大，以致内存一次不能容纳全部记录，在排序过程中需要对外存进行访问）。我们一般提到的基本都属于内部排序，一共可以分为5大类、8小类，如下</p>
<ul>
<li>插入排序：直接插入排序、希尔排序</li>
<li>选择排序：简单选择排序、堆排序</li>
<li>交换排序：冒泡排序、快速排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<p>这篇文章对这 8 类排序算法进行详细说明，不过在此之前，先介绍排序稳定性的概念，因为时间复杂度、空间复杂度和排序稳定性是排序算法的三个重要度量。</p>
<p>排序稳定性其实就是相同的两个数在排序前后的先后位置是否发生了变化，具体的数学定义如下</p>
<blockquote>
<p>假设 $r_i = r_j(1 \le i \le n, 1 \le j \le n, i \ne j)$，且在排序前的序列中 $r_i$ 领先于 $r_j$ （即 $i \le j$）。如果排序后 $r_i$ 仍领先于 $r_j$ ，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 $r_j$ 领先于 $r_i$，则称所用的排序方法是不稳定的。</p>
</blockquote>
<p>注意，下面我们所有的讨论都是基于递增排序的</p>
<h2 id="1-直接插入排序">1. 直接插入排序</h2>
<p>核心思想是：将序列的第一个记录看成是一个有序的子序列，然后从第二个记录开始逐个进行插入，直至整个序列有序为止。</p>
<p></p>
<p>可以使用两层循环实现，第一层循环遍历所有待比较数组元素，第二层循环将本轮选择的元素与已经排好序的元素进行比较。程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">tmp</span> <span class="kt">int</span> <span class="c1">// tmp用来临时存储本轮待比较元素
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">tmp</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="c1">// 临时存储本轮待比较元素
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">tmp</span> <span class="p">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
	  <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// 数组元素后移
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span> <span class="c1">// 在正确的位置插入元素
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度为$O(N^2)$，最好情况，也就是待排序数组有序情况下，时间复杂度为$O(N)$，即单纯的遍历一遍。</p>
<p>空间复杂度为$O(1)$。</p>
<p>直接插入排序是稳定的。</p>
<h2 id="2-希尔排序">2. 希尔排序</h2>
<p>核心思想是：先将整个待排序记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行直接插入排序。实现步骤如下：</p>
<ol>
<li>按照增量分成子序列</li>
<li>对子序列进行排序（直接插入）</li>
<li>缩小增量，重复以上步骤，直到增量为1</li>
</ol>
<p>增量选取待排序序列长度的一半，然后每次取当前增量的一半。</p>
<p></p>
<p>程序实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span>
  <span class="c1">// dk为增量，初始为待排序数组长度的一半，然后每轮循环减半
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">dk</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">dk</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dk</span> <span class="o">/=</span> <span class="mi">2</span> <span class="p">{</span>
	<span class="c1">// 内层循环是间隔为dk的插入排序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="nx">dk</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	  <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	  <span class="k">for</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">dk</span> <span class="o">&amp;&amp;</span> <span class="nx">tmp</span> <span class="p">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">dk</span><span class="p">];</span> <span class="nx">j</span> <span class="o">-=</span> <span class="nx">dk</span> <span class="p">{</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">dk</span><span class="p">]</span>
	  <span class="p">}</span>
	  <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
	<span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>希尔排序是不稳定的，其空间复杂度为$O(1)$，最好情况时间复杂度为$O(N)$，最坏情况为$O(N^2)$</p>
<p>但这是我们按折半方式选取增量时得到的结果，这种情况下，因为增量不互质，小增量很可能不起作用，某些循环的插入排序没有意义。我们可以通过选择较好的增量序列来优化算法，有两个有名的增量序列是</p>
<ol>
<li>Hibbard增量序列：$dk = 2^k -1$，该增量序列最坏情况的时间复杂度为$O(N^{3/2})$，理论上平均时间复杂度为 $T_avg = O(N^{5/4})$</li>
<li>Sedgewick增量序列：${1,5,19,41,109,……}$，计算公式为 $9 \times 4^i - 8 \times 2^i + 1$ 或 $4^i - 3 \times 2^i +1$。理论上其时间复杂度为 $T_avg = O(N^{7/6}), T_worst = O(N^{4/3})$</li>
</ol>
<p>一般没有特别说明的情况下，增量序列可以选择&hellip; 3, 2, 1 或&hellip; 5, 3, 2, 1 这样从1开始的已知质数序列。程序实现时可以定义一个增量序列数组，然后遍历其内容。不过最常使用的依然是按折半方式选取的增量。</p>
<h2 id="3-简单选择排序">3. 简单选择排序</h2>
<p>核心思想是：在要排序的一组数中，选出最小（或者最大）的一个数与第一个位置的数进行交换，然后在剩下的数中再找最小（或者最大）的与第二个位置的数交换，依次类推，直至第 n-1 个元素（倒数第二个数）与第 n 个元素 (最后一个数) 比较为止。</p>
<p></p>
<p>程序实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SelectionSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">min</span> <span class="kt">int</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">min</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
	  <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">min</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">min</span> <span class="p">=</span> <span class="nx">j</span>
	  <span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">min</span> <span class="o">!=</span> <span class="nx">i</span> <span class="p">{</span>
	  <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">min</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">min</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>选择排序是不稳定的，空间复杂度是$O(1)$，时间复杂度为$O(N^2)$</p>
<h2 id="4-堆排序">4. 堆排序</h2>
<p>我们知道一个堆的根元素永远是最小值（小顶堆）或最大值（大顶堆），所以堆排序的核心思想是：首先将传入的所有元素构造成堆，然后每次取出根元素加入新的数组，最后对堆进行调整。直到新的元素都被取出后，新的数组就是原来数组的有序序列。</p>
<p>程序代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 堆排序
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="c1">// 初始化堆
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nf">heapAdjust</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//每次取出根元素并重新调整堆
</span><span class="c1"></span>	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">t</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">nums</span><span class="p">[</span><span class="nx">t</span><span class="p">]},</span> <span class="nx">result</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[:</span><span class="nx">t</span><span class="p">]</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nf">heapAdjust</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 堆调整函数，调整数组使其符合堆的要求
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">heapAdjust</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">child</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="nx">parent</span> <span class="p">=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">parent</span><span class="o">*</span><span class="mi">2</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">parent</span> <span class="p">=</span> <span class="nx">child</span> <span class="p">{</span>
		<span class="nx">child</span> <span class="p">=</span> <span class="nx">parent</span> <span class="o">*</span> <span class="mi">2</span>
		<span class="k">if</span> <span class="nx">child</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">child</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">child</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">parent</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">child</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">parent</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">parent</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>堆排序是不稳定的，空间复杂度是 $O(1)$，时间复杂度是 $O（nlog_2n）$（注：一次堆调整的时间复杂度是 $O（log_2n）$）</p>
<h2 id="5-冒泡排序">5. 冒泡排序</h2>
<p>核心思想是：在要排序的一组数中，自上而下的对相邻的两个数依次进行比较和调整，较大的数往下沉，较小的数往上冒。</p>
<p></p>
<p>冒泡是最简单的排序，代码实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
	  <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
	  <span class="p">}</span>
	<span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>冒泡是稳定的排序算法，空间复杂度是$O(1)$，最好情况下时间复杂度是$O(N)$，最坏情况下时间复杂度是$O(N^2)$。</p>
<p>上面的算法即使数组中途已经有序，也会一遍又一遍的判断，通过加入一个标志字段，可以节省一部分时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">flag</span> <span class="kt">bool</span>  
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
	  <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
	  <span class="p">}</span>
	<span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span> <span class="c1">//如果当前数组已有序，跳出循环
</span><span class="c1"></span>      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="6-快速排序">6. 快速排序</h2>
<p>快排递归方法的核心思想是： 先在待排序的记录中选择一个数（通常是第一个数或者最后一个数）作为基准，设立两个指向标记，分别指向第一个元素和最后一个元素，然后进行第一趟划分，若最后一个数大于或等于基准值，则使指向最后一个数的指向标记向前移动；若最后一个数小于基准值，则将最后一个数与第一个数进行交换，此时将指向第一个数的指向标记向前移动。则第一趟得到的记录刚好以基准值为分界线，以上述同样的方法再对分界线两边的部分进行排序, 基准值就等于说找到了最终位置。</p>
<p>非递归方法的核心思想是：利用栈来存储两个指向标记的值，其它与递归的快速排序不相上下。</p>
<p></p>
<p></p>
<p>递归程序代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="cm">/* 快速排序的递归解法, low 是第一个指向标记，high 是第二个指向标记。
</span><span class="cm">初始参数传入时，low和high应该为第一个元素和最后一个元素
</span><span class="cm">*/</span>

<span class="kd">func</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">low</span><span class="p">,</span> <span class="nx">high</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">low</span> <span class="p">&lt;</span> <span class="nx">high</span> <span class="p">{</span>
		<span class="nx">pivot</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span>
		<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">low</span><span class="p">,</span> <span class="nx">high</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">pivot</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="p">}</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">pivot</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="p">}</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pivot</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">low</span><span class="p">,</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">high</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>快速排序不稳定，平均情况下，时间复杂度为 $ O(nlogn) $，传入数组本身有序是最坏情况，时间复杂度为$O(n^2)$，空间复杂度（考虑递归调用的最大深度）在平均情况下为$O(logn)$，在最坏情况下为$O(n)$</p>
<h2 id="7-归并排序">7. 归并排序</h2>
<p>核心思想是：将两个（或者两个以上）的有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列都是有序的。然后再把有序子序列合并为整体有序序列，两个子序列归并时，准备两个指针从两个子序列从头扫描到尾，将扫描到的元素按序插入结果数组。</p>
<p></p>
<p>两个子序列归并的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 归并两个子序列
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">m</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">left</span><span class="p">[</span><span class="nx">m</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">right</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">right</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>
			<span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">left</span><span class="p">[</span><span class="nx">m</span><span class="p">])</span>
			<span class="nx">m</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">left</span><span class="p">[</span><span class="nx">m</span><span class="p">:]</span><span class="o">...</span><span class="p">),</span> <span class="nx">right</span><span class="p">[</span><span class="nx">n</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>归并排序的递归程序代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">nums</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">i</span><span class="p">])</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">:])</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>归并排序的非递归程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span> <span class="o">*=</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">j</span> <span class="kt">int</span>
		<span class="k">for</span> <span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="o">:=</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">:</span><span class="nx">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="nx">j</span><span class="p">])</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">:</span><span class="nx">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="nx">j</span><span class="p">],</span> <span class="nx">result</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">+</span><span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">:],</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">:]))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">nums</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>归并排序是稳定的，时间复杂度为$O（nlogn）$，空间复杂度为$O(n)$</p>
<h2 id="8-基数排序">8. 基数排序</h2>
<p>以上的排序都是基于大小比较的，这种思路下的最坏时间复杂度的下界是$O(nlogn)$，想要更快，可以在比较大小的同时做一些其它的事情，这就是基数排序。</p>
<p>基数排序是基于桶排序的，假设我们有 N 个数字，每个整数的值在 0到99之间（于是有 M=100 个不同的值），线性时间内对它们进行排序的方法是：建立一个长度为100的数组，每个数组的值是一个指向链表的指针，遍历所有数字，将与数组下标相同的值添加到该数组元素对应的链表中，最后按下标从小到大输出所有非空的数组元素对应的链表。每个数组元素可以看作一个桶，桶里装着所有相同的值，这样排序的时间复杂度是$O(M+N)$</p>
<p></p>
<p>依然假设我们有 N=10 个整数，每个整数的值在0到999之间（于是有 M=1000个不同的值），如果使用同样的方法构造数组，则数组太大，这里使用的办法就是基数排序了。对于序列：64，8，216，512，27，729，0，1，343，125，首先建立长度为10的数组（这里的10就是基数），然后按照个位数字将数据放入与数组下标相同的桶，这是第一趟排序，也就是下图 Pass 1（第2行）行，此时所有元素个位有序；第二趟排序按十位数入桶，对应第3行到第5行，此时得到的序列是：0，1，8，512，216，125，27，729，343，64；最后一趟排序按百位数入桶，对应第6行到最后一行，最终得到序列0，1，8，27，64，125，216，343，512，729，此时得到的序列就是有序的。关键字就是每一位的数字，顺序是从个位到百位，这叫做低位优先。</p>
<p></p>
<p>基数排序是稳定的，时间复杂度为$O(d(n+rd)$，d 代表关键字长度，上例为3（每个数字最多3位），n 代表要排序的数的总数，上例为10，rd代表关键字基数，上例为10（0~9 共10种情况）。空间复杂度为$O(n)$</p>
<p>基数排序不仅用于数字的排序，也用于多关键字的排序，以扑克牌为例，有花色和面值两种关键字，排序如下</p>
<p></p>
<p>注意这里提到用了「主位优先」，在数字排序的例子里含义其实就是高位优先，与我们之前使用的低位优先正好相反。这里如果使用低位优先（也叫做次位优先），就是按面值建立桶。</p>
<h2 id="9-排序算法比较">9. 排序算法比较</h2>
<p>所有排序算法时间, 空间复杂度汇总</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>最好时间</th>
<th>平均时间</th>
<th>最坏时间</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n)$</td>
<td>$O(n^{1.3})$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>简单选择</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n^2)$</td>
<td>$O(logn)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(d(r+n))$</td>
<td>$O(d(r+n))$</td>
<td>$O(d(r+n))$</td>
<td>$O(rd + n)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p>对于链表来说，可执行的排序包括直接插入、简单选择、快排、冒泡、和归并。</p>
]]></description></item></channel></rss>