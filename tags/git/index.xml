<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>git - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/git/</link><description>git - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 30 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://shuzang.github.io/tags/git/" rel="self" type="application/rss+xml"/><item><title>Git深入-子模块, 徽章, 开源协议</title><link>https://shuzang.github.io/git-learning-deep-into/</link><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/git-learning-deep-into/</guid><description><![CDATA[<p>学习一些更高级或更有趣的 Git 用法，包括子模块、徽章、开源协议选择等。</p>
<h2 id="1-开源协议">1. 开源协议</h2>
<p>代码的开源协议比较多，这里附一张阮一峰大神的图片说明如何选择。</p>
<p></p>
<h2 id="2-子模块">2. 子模块</h2>
<p>当我们在一个 Git 项目上工作时，有时候需要在其中使用另外一个 Git 项目。这个情况可以在 Git 中使用子模块 <code>submodule</code> 来进行管理。<code>submodule</code> 允许我们将一个 Git 仓库当作另外一个 Git 仓库的子目录。这允许我们克隆另外一个仓库到自己的项目中并且保持我们的提交相对独立。</p>
<p>Hugo 的博客源码文件中，主题的源码就是作为子模块进行添加和管理。本文中以本地项目 blog 为例，将远程主题项目 LoveIt 作为子模块进行管理。</p>
<h3 id="21-添加子模块">2.1 添加子模块</h3>
<p>将远程项目 <code>LoveIt</code> 克隆到本地 <code>blog/themes</code> 文件夹，<code>blog</code> 需要本身就是一个 Git 项目</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt
</code></pre></td></tr></table>
</div>
</div><p>添加子模块后运行<code>git status</code>, 可以注意增加了一个文件 <code>.gitmodules</code>,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git status
On branch master
Your branch is up to date with <span class="s1">&#39;origin/master&#39;</span>.

Changes to be committed:
  <span class="o">(</span>use <span class="s2">&#34;git reset HEAD &lt;file&gt;...&#34;</span> to unstage<span class="o">)</span>

        new file:   .gitmodules
        new file:   themes/LoveIt
</code></pre></td></tr></table>
</div>
</div><p>这个文件用来保存子模块的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>submodule <span class="s2">&#34;themes/LoveIt&#34;</span><span class="o">]</span>
	<span class="nv">path</span> <span class="o">=</span> themes/LoveIt
	<span class="nv">url</span> <span class="o">=</span> https://github.com/dillonzq/LoveIt.git
</code></pre></td></tr></table>
</div>
</div><h3 id="22-查看子模块">2.2 查看子模块</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule
 bf7c4b5173c3baba02b87a410ce04909c1b86cf6 themes/LoveIt <span class="o">(</span>v0.1.4<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="23-更新子模块">2.3 更新子模块</h3>
<p>作为子模块的主题经常需要追随远程更新，这也是最常见的一种情况，即只使用子项目并不时获取更新，而不在子项目中做任何更改。</p>
<p>最容易的方式是添加参数 <code>--remote</code>，Git 会进入子模块然后抓取并更新</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule update --remote
</code></pre></td></tr></table>
</div>
</div><p>该命令假设我们想要更新子模块仓库的 <code>master</code> 分支，如果想要设置为其它的分支，可以在 <code>.gitmodules</code> 中进行设置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git config -f .gitmodules submodule.themes/LoveIt.branch develop
$ git submodule update --remote
Submodule path <span class="s1">&#39;themes/LoveIt&#39;</span>: checked out <span class="s1">&#39;b6ce753ae7892839899962b879e2cc5808c60732&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>git diff</code> 可以查看到变动，<code>.gitmodules</code>多了一行，子模块的分支号有了变动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git diff
diff --git a/.gitmodules b/.gitmodules
index a6f32d0..5376abf <span class="m">100644</span>
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 <span class="o">[</span>submodule <span class="s2">&#34;themes/LoveIt&#34;</span><span class="o">]</span>
        <span class="nv">path</span> <span class="o">=</span> themes/LoveIt
        <span class="nv">url</span> <span class="o">=</span> https://github.com/dillonzq/LoveIt.git
+       <span class="nv">branch</span> <span class="o">=</span> develop
diff --git a/themes/LoveIt b/themes/LoveIt
index bf7c4b5..b6ce753 <span class="m">160000</span>
--- a/themes/LoveIt
+++ b/themes/LoveIt
@@ -1 +1 @@
-Subproject commit bf7c4b5173c3baba02b87a410ce04909c1b86cf6
+Subproject commit b6ce753ae7892839899962b879e2cc5808c60732
</code></pre></td></tr></table>
</div>
</div><p>当运行 <code>git submodule update --remote</code> 时，Git 默认会尝试更新 <strong>所有</strong> 子模块， 所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule update --remote themes/LoveIt
</code></pre></td></tr></table>
</div>
</div><h3 id="24-克隆包含子模块的项目">2.4 克隆包含子模块的项目</h3>
<p>如果像下面这样直接克隆包含子模块的项目，虽然有子模块目录，但是是空的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"> $ git clone https://github.com/shuzang/blog.git
 $ <span class="nb">cd</span> blog
 $ ls themes/LoveIt
 $
</code></pre></td></tr></table>
</div>
</div><p>查看子模块时前面有一个<code>-</code>，也说明子模块文件还未检入（空文件夹）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule
-87c33888f3fa86b8cc096bc3f6d7f2efe9ccba66 themes/KeepIt
</code></pre></td></tr></table>
</div>
</div><p>此时需要运行两个命令，<code>git submodule init</code> 用来初始化子模块</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule init
Submodule <span class="s1">&#39;themes/KeepIt&#39;</span> <span class="o">(</span>https://github.com/Fastbyte01/KeepIt.git<span class="o">)</span> registered <span class="k">for</span> path <span class="s1">&#39;themes/KeepIt&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>git submodule update</code> 用来抓取数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule update
Cloning into <span class="s1">&#39;C:/Users/lylw1/Desktop/blog/themes/KeepIt&#39;</span>...
Submodule path <span class="s1">&#39;themes/KeepIt&#39;</span>: checked out <span class="s1">&#39;87c33888f3fa86b8cc096bc3f6d7f2efe9ccba66&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>不过有一个更简单的方法，就是给 <code>git clone</code> 命令传递 <code>--recurse-submodules</code> 参数，这样就会自动初始化并更新仓库中每一个子模块，包括可能存在的嵌套子模块</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"> $ git clone https://github.com/shuzang/blog.git --recurse-submodules
</code></pre></td></tr></table>
</div>
</div><h3 id="25-修改子模块">2.5 修改子模块</h3>
<p>在子模块中修改文件后，直接提交到远程项目分支。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git add .
$ git commit -m <span class="s2">&#34;modify submodule&#34;</span>
$ git push origin master
</code></pre></td></tr></table>
</div>
</div><h3 id="26-删除子模块">2.6 删除子模块</h3>
<p>之前从网上找到的办法是，手动删除相关的文件，以删除<code>KeepIt</code>文件夹为例</p>
<ol>
<li>
<p>删除子模块文件夹</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git rm --cached themes/KeepIt
$ rm -rf themes/KeepIt
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>删除<code>.gitmodules</code>文件中相关子模块信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>submodule <span class="s2">&#34;themes/KeepIt&#34;</span><span class="o">]</span>
<span class="nv">path</span> <span class="o">=</span> themes/KeepIt
    <span class="nv">url</span> <span class="o">=</span> https://github.com/Fastbyte01/KeepIt.git
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>删除<code>.git/config</code>中的相关子模块信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>submodule <span class="s2">&#34;themes/KeepIt&#34;</span><span class="o">]</span>
<span class="nv">url</span> <span class="o">=</span> https://github.com/Fastbyte01/KeepIt.git
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>删除<code>.git</code>文件夹中的相关子模块文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ rm -rf .git/modules/themes/KeepIt
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>不过实际上，这是一种比较野的做法，不建议使用。根据官方文档的说明，应该使用 <code>git submodule deinit</code> 命令卸载一个子模块。这个命令如果添加上参数 <code>--force</code>，则子模块工作区内即使有本地的修改，也会被移除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule deinit themes/LoveIt
$ git rm themes/LoveIt
</code></pre></td></tr></table>
</div>
</div><p>执行 <code>deinit</code> 的效果，是自动在 <code>.git/config</code> 中删除了如下信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[submodule &#34;themes/LoveIt&#34;]
	url = https://github.com/dillonzq/LoveIt.git
</code></pre></td></tr></table>
</div>
</div><p>执行 <code>rm</code> 的效果，是移除了 <code>themes/LoveIt</code> 文件夹，并删除了 <code>.gitmodules</code> 中的相关内容</p>
<p>此时关于子模块的信息基本已经删除完毕，只剩 <code>.git/modules</code> 下还有一些残留，但执行 <code>commit</code> 后残留会被删除</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git commit -m <span class="s2">&#34;delete submodule themes/LoveIt&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-徽章">3. 徽章</h2>
<p>逛github的时候，经常能在 README.md 页面看到如下所示的徽章，通常展示了项目的相关信息，这种形式比单纯的文字描述更加吸引人，今天就来学一学如何在项目中插入这些徽章。</p>
<p></p>
<h3 id="31-徽章简介">3.1 徽章简介</h3>
<p>GitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。</p>
<p>这些徽标的本质仍然是图片，并没有脱离markdwon语法的限制。其基本原理是，徽标的官方网站<a href="https://shields.io/" target="_blank" rel="noopener noreffer">shields.io</a>提供了一批“标签小程序”，它们可以抓取一些github项目的动态数据并自动生成标签图片，比如抓取github上项目的最新release版本号生成release标签等。使用这种标签能够保证每次刷新网页都会重新抓取数据，并且更新标签上的文字，这样就实现了动态变化的徽章标签。</p>
<p>徽标图片的话一般由左半部分的名称和右半部分的值组成，徽章则主要由图片和对应的链接（链接可以不填）组成，如下所示，正是github上git项目的唯一徽标的格式，前半部分的方括号里的是图片，后半部分的圆括号里的是链接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>!<span class="o">[</span>Build Status<span class="o">](</span>https://dev.azure.com/git/git/_apis/build/status/git.git<span class="o">)](</span>https://dev.azure.com/git/git/_build/latest?definitionId<span class="o">=</span>11<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以点击<a href="https://github.com/git/git/blob/master/README.md" target="_blank" rel="noopener noreffer">这里</a>看一下Git项目中该徽章表现形式，当然，正式使用时可以在官网<a href="https://shields.io/" target="_blank" rel="noopener noreffer">shields.io</a>中可以预览徽标样式，然后选择自己喜欢的徽标添加到项目中。</p>
<p><strong>注</strong>：徽章不是添加的越多越好，因为徽章的根本作用还是清晰易懂的说明项目相关信息，合理地选择适合项目地徽标做针对性地添加才是理性地做法。</p>
<h3 id="32-徽章添加">3.2 徽章添加</h3>
<p>我们进入<a href="https://shields.io/category/platform-support" target="_blank" rel="noopener noreffer">shields.io</a>的<code>Version</code>标签页，点开GitHub release这一条的链接，如下：</p>
<p></p>
<p>会看到如下界面</p>
<p></p>
<p>在which中选择<code>release</code>或<code>release-pre</code>，在user下填入用户名，在repo下填入项目名，以Tencent的tinker项目为例，徽章预览如图所示，点击下面的Copy Badge URL即可复制链接。然后放到README中使用即可。</p>
<p><strong>注</strong>：style中可以选择徽章形式，链接复制有适用于markdown或其它文本等四种形式。</p>
<h3 id="33-自定义徽章">3.3 自定义徽章</h3>
<p>如果想要生成的徽章字样和颜色shields没有，<a href="https://shields.io/" target="_blank" rel="noopener noreffer">shields.io</a>也支持自定义一个自己想要的徽章，从主页拉到<code>Your Badge</code>部分，如下图</p>
<p></p>
<p>在上图中的框中填入相关信息，三条横线从前到后依次是<code>label</code>,<code>message</code>,<code>color</code>，color有选项可以选择，上图的预览样式如下：</p>
<p></p>
<h3 id="34-常用徽章">3.4 常用徽章</h3>
<h4 id="项目下载量">项目下载量</h4>
<p>项目被下载地次数，各平台统计独立，详见 <a href="https://shields.io/category/platform-support" target="_blank" rel="noopener noreffer">shields.io</a> 的 <code>Downloads</code> 一栏，图标示例如下</p>
<p></p>
<h4 id="项目支持平台">项目支持平台</h4>
<p>详见 <a href="https://shields.io/category/platform-support" target="_blank" rel="noopener noreffer">shields.io</a> 的 <code>Platform &amp; Version Support</code> 一栏，图标示例如下</p>
<p></p>
<h4 id="项目语言">项目语言</h4>
<p>即项目所用编程语言，通过自定义徽标实现，图标示例如下：</p>
<p></p>
<h4 id="开源协议类型">开源协议类型</h4>
<p>详见 <a href="https://shields.io/category/platform-support" target="_blank" rel="noopener noreffer">shields.io</a> 的 <code>License</code> 一栏，图标示例如下</p>
<p></p>
<p>还有其它很多，shields首页标签栏从<code>build</code>,<code>Downloads</code>到<code>Other</code>共提供了17类，还可以自定义标签。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] EyreFree. GitHub项目徽章地添加与设置. <a href="https://juejin.im/post/5a32157c6fb9a0450b6667ac">https://juejin.im/post/5a32157c6fb9a0450b6667ac</a>. 2017.12.</p>
<p>[2]  AnSwEr不是答案. Github徽章整理. <a href="https://blog.csdn.net/u011192270/article/details/51788886">https://blog.csdn.net/u011192270/article/details/51788886</a>. 2016.06.</p>
<p>[3] ShikiEiki. 为你地Github README生成漂亮地徽章和进度条. 2017.03.</p>
<p>[4] Shields项目. <a href="https://github.com/badges/shields">https://github.com/badges/shields</a>.</p>
<p>[5] 知乎-孤单彼岸. <a href="https://zhuanlan.zhihu.com/p/87053283?utm_source=cn.ticktick.task&amp;utm_medium=social&amp;utm_oi=1153472097597743104" target="_blank" rel="noopener noreffer">Git中submodule的使用</a>. 2019-10-17</p>
<p>[6] Git文档. <a href="https://git-scm.com/book/zh/v2/Git-%e5%b7%a5%e5%85%b7-%e5%ad%90%e6%a8%a1%e5%9d%97" target="_blank" rel="noopener noreffer">Git工具-子模块</a>. 2nd Edition.</p>]]></description></item><item><title>Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息</title><link>https://shuzang.github.io/git-learning-improvement/</link><pubDate>Sun, 22 Apr 2018 10:21:16 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/git-learning-improvement/</guid><description><![CDATA[<p>上一篇我们学习了Git的基本知识，包括仓库创建，提交、修改、推送、回退等等操作，本篇学习一些高级的功能。转自 <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener noreffer">廖雪峰的官方网站-git教程</a>。</p>
<h2 id="1-分支管理">1. 分支管理</h2>
<p>每个仓库都可能有几条不同的分支，比如master分支，比如用于开发的dev分支。分支操作的实质是对指针的操作</p>
<h3 id="11-分支管理策略">1.1 分支管理策略</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<ul>
<li>
<p><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面工作；</p>
</li>
<li>
<p>工作都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到大版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布大版本；</p>
</li>
<li>
<p>团队中每个人都在<code>dev</code>分支上干活，但每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了</p>
</li>
</ul>
<h3 id="12-创建分支">1.2 创建分支</h3>
<p>创建dev分支，然后切换到dev分支：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b dev
Switched to a new branch <span class="s1">&#39;dev&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git branch dev
$ git checkout dev
Switched to branch <span class="s1">&#39;dev&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>用<code>git branch</code>命令查看当前分支，该命令会列出所有分支，当前分支前面会标一个<code>*</code>号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git branch
* dev
  master
</code></pre></td></tr></table>
</div>
</div><p>然后就可以在<code>dev</code>分支上进行修改提交，<code>commit</code>操作完成后对分支的操作也就完成，可以切换回<code>master</code>分支</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout master
</code></pre></td></tr></table>
</div>
</div><p>切换回<code>master</code>分支后看不到刚才的修改，因为修改在<code>dev</code>分支上，必须先进行合并</p>
<h3 id="13-合并分支">1.3 合并分支</h3>
<p>将<code>dev</code>分支的修改合并到<code>master</code>分支</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git merge dev
</code></pre></td></tr></table>
</div>
</div><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，就能在<code>master</code>分支查看到刚刚在<code>dev</code>分支做的修改</p>
<p>合并完成后<code>dev</code>分支就没用了，可以删除它</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git branch -d dev
</code></pre></td></tr></table>
</div>
</div><p>强行删除分支使用参数<code>-D</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git branch -D dev
</code></pre></td></tr></table>
</div>
</div><p>删除后查看分支，会发现只剩下<code>master</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git branch
</code></pre></td></tr></table>
</div>
</div><h3 id="14-解决冲突">1.4 解决冲突</h3>
<p>有时候，不同的分支对同一处做了修改，此时合并会产生冲突，因为系统不知道该采用哪种修改。此时若强行合并，是无法通过的，系统会提示必须手动解决冲突后再提交。可以用<code>git status</code>命令查看冲突文件是哪个，手动解决冲突后重新提交即可成功，然后可以用带参数的<code>git log</code>命令查看合并情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git log --graph --pretty<span class="o">=</span>oneline --abbrev-commit
</code></pre></td></tr></table>
</div>
</div><p>合并完成后删除分支</p>
<h3 id="15-bug分支">1.5 Bug分支</h3>
<p>软件开发中，出现bug是正常的事情，有了bug就需要修复。在git中，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除</p>
<p><strong>背景</strong>：当你需要修复某个bug时，当前在<code>dev</code>分支上进行的工作还没有提交，而且因为工作只进行到一半，完全没法提交，但bug却必须马上修复</p>
<p><strong>解决办法</strong>：<code>git stash</code>命令，可以把当前工作现场保存，等以后恢复现场工作后继续工作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git stash
$ git status
</code></pre></td></tr></table>
</div>
</div><p>使用<code>git status</code>查看工作区确认工作区是干净的，然后按如下步骤进行</p>
<ol>
<li>切换到bug所在分支</li>
<li>创建bug修复分支</li>
<li>修复</li>
<li>提交</li>
<li>切换回bug所在分支</li>
<li>合并分支</li>
<li>删除bug修复分支</li>
<li>切换回工作的dev分支</li>
</ol>
<p>查看修复bug前保存的工作现场</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git stash list
</code></pre></td></tr></table>
</div>
</div><p>恢复工作现场</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git stash pop
</code></pre></td></tr></table>
</div>
</div><h2 id="2-多人协作">2. 多人协作</h2>
<p>当我们从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>
要查看远程库的信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git remote
</code></pre></td></tr></table>
</div>
</div><p>显示远程库更详细的信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git remote -v
</code></pre></td></tr></table>
</div>
</div><p>使用<code>-v</code>参数会显示可抓取和推送的<code>orign</code>的地址，但若没有推送权限，则看不到push地址</p>
<h3 id="21-推送分支">2.1 推送分支</h3>
<p>推送分支，就是把该分支上的所有本地提交推送到远程仓库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git push origin master
</code></pre></td></tr></table>
</div>
</div><p>如果要推送其他分支，比如dev，就改成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git push origin dev
</code></pre></td></tr></table>
</div>
</div><p>但是，并不是一定要把本地分支往远程推送</p>
<ul>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，没必要推到远程</li>
</ul>
<p>在git中，分支完全可以在本地自己使用，是否推送，视心情而定</p>
<h3 id="22-抓取分支">2.2 抓取分支</h3>
<p>在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">git checkout -b branch-name origin/branch-name
</code></pre></td></tr></table>
</div>
</div><p>建立本地分支和远程分支的关联</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">git branch --set-upstream branch-name origin/branch-name
</code></pre></td></tr></table>
</div>
</div><p>从远程抓取分支</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">git pull
</code></pre></td></tr></table>
</div>
</div><h2 id="3-标签管理">3. 标签管理</h2>
<p>因为版本号太复杂，所以git提供了标签功能</p>
<p>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为当前分支，也可以指定一个commit id；</p>
<p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p>
<p>命令<code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</p>
<p>命令<code>git tag</code>可以查看所有标签</p>
<p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p>
<p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>
<p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>
<p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</p>
<h2 id="4-忽略特殊文件">4. 忽略特殊文件</h2>
<p>有时候，git工作目录里的某些文件并不想同步到远程的github仓库，此时可以在git工作区根目录下创建<code>.gitignore</code>文件，然后把要忽略的文件名填进去，git会自动忽略这些文件</p>
<p><strong>注</strong>：<code>.gitignore</code>文件本身要上传到版本库进行管理</p>
<h2 id="5-commit-信息编写">5. commit 信息编写</h2>
<p>简单来讲，commit 就是在本地仓库中编写的文件的<strong>快照</strong>。与印象中不同的是，Git 不仅存储不同版本文件之间的差异，还存储了所有文件的完整版本。对于两个 commit 之间没有被修改的文件，Git 只存储指向前一个完全相同的文件的链接。</p>
<p>下面的图片展示了 git 如何随着时间存储数据，其中每个「Version」都是一个 commit：</p>
<p></p>
<h3 id="51-commit-message">5.1 Commit message</h3>
<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git commit -m <span class="s2">&#34;hello world&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面代码的<code>-m</code>参数，就是用来指定 commit mesage 的。</p>
<p>如果一行不够，可以只执行<code>git commit</code>，就会跳出文本编辑器，让你写多行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git commit
</code></pre></td></tr></table>
</div>
</div><p>commit信息可以随意编写，但一般来说，应该清晰明了，说明本次提交的目的。 一个清晰的、规范化的Commit message，有如下好处</p>
<ol>
<li>
<p>提供更多的历史信息，方便快速浏览</p>
</li>
<li>
<p>过滤某些commit（比如文档改动），便于快速查找信息</p>
</li>
<li>
<p>可以直接从commit生成Change log，Change Log 是发布新版本时，用来说明与上一个版本差异的文档</p>
<p></p>
</li>
</ol>
<p>而且，查看commit信息的多数是团队成员或其它对该项目感兴趣的人，规范清晰的commit信息对它们有如下意义</p>
<ul>
<li>加快和简化代码审查（code reviews）</li>
<li>帮助理解一个更改</li>
<li>解释不能只由代码描述的「为什么」</li>
<li>帮助未来的维护人员弄清楚为什么以及如何产生的更改，从而使故障排查和调试更容易</li>
</ul>
<h3 id="52-写法规范">5.2 写法规范</h3>
<p>目前，社区有多种 Commit message 的写法规范。但<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener noreffer">Angular 规范</a>是使用最广的写法，比较合理和系统化，并且有配套的工具，因此学习和使用这种规范。</p>
<p>Commit message分为三部分： Header，Body 和 Footer。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">&lt;type&gt;<span class="o">(</span>&lt;scope&gt;<span class="o">)</span>: &lt;subject&gt;
// 空一行
&lt;body&gt;
// 空一行
&lt;footer&gt;
</code></pre></td></tr></table>
</div>
</div><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p>
<p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p>
<h4 id="header">Header</h4>
<p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p>
<p><strong>type</strong></p>
<p><code>type</code>用于说明 commit 的类别，只允许使用下面7个标识。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">feat：新功能（feature）
fix：修补bug
docs：文档（documentation）
style： 格式（不影响代码运行的变动）
refactor：重构（即不是新增功能，也不是修改bug的代码变动）
test：增加测试
chore：构建过程或辅助工具的变动
</code></pre></td></tr></table>
</div>
</div><p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p>
<p><strong>scope</strong></p>
<p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p><strong>subject</strong></p>
<p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li>
<li>第一个字母小写</li>
<li>结尾不加句号（<code>.</code>）</li>
</ul>
<p>一些例子如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docs(error/$rootScope/inprog): add missing &#34;$timeout&#34;
fix(loader): use `false` as default value for `transclude` in compone
feat($compile): Allow ES6 classes as controllers with `binToControll`
</code></pre></td></tr></table>
</div>
</div><h4 id="body">Body</h4>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">More detailed explanatory text, if necessary.  Wrap it to 
about 72 characters or so. 

Further paragraphs come after blank lines.

- Bullet points are okay, too
- Use a hanging indent
</code></pre></td></tr></table>
</div>
</div><p>有两个注意点。</p>
<ul>
<li>使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</li>
<li>应该说明代码变动的动机，以及与以前行为的对比。</li>
</ul>
<h4 id="footer">Footer</h4>
<p>Footer 部分只用于两种情况。</p>
<p><strong>不兼容变动</strong></p>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">BREAKING CHANGE: isolate scope bindings definition has changed.

    To migrate the code follow the example below:

    Before:

    scope: {
      myAttr: &#39;attribute&#39;,
    }

    After:

    scope: {
      myAttr: &#39;@&#39;,
    }

    The removed `inject` wasn&#39;t generaly useful for directives so there should be no code using it.
</code></pre></td></tr></table>
</div>
</div><p><strong>关闭Issue</strong></p>
<p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Closes #234
</code></pre></td></tr></table>
</div>
</div><p>也可以一次关闭多个 issue 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Closes #123, #245, #992
</code></pre></td></tr></table>
</div>
</div><h4 id="revert">Revert</h4>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">revert: feat(pencil): add &#39;graphiteWidth&#39; option

This reverts commit 667ecc1654a317a13331b17617d973392f415f02.
</code></pre></td></tr></table>
</div>
</div><p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p>
<h3 id="53-生成change-log">5.3 生成Change log</h3>
<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成，如下例</p>
<p></p>
<p>生成的文档包括以下三个部分。</p>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes</li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，还可以添加其他内容。 一般使用相关工具自动生成Change log。</p>
<h3 id="54-相关命令">5.4 相关命令</h3>
<ul>
<li>
<p><code>rebase -i</code>可以用来压缩提交（squash commits）、 编写信息、 重写/删除/重新编排 commit 等。</p>
</li>
<li>
<p><code>fixup</code>可用来清理 commit，而不需要复杂的 rebase。<a href="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html" target="_blank" rel="noopener noreffer">这篇文章</a>提供了很好的示例，说明了如何以及何时进行此操作。</p>
</li>
<li>
<p><code>cherry-pick</code>在你 commit 到了错误的分支而不需要重新编码时非常有用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git cherry-pick 790ab21
<span class="o">[</span>master 094d820<span class="o">]</span> Fix English grammar in Contributing
 Date: Sun Feb <span class="m">25</span> 23:14:23 <span class="m">2018</span> -0300
 <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>, <span class="m">1</span> deletion<span class="o">(</span>-<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="55-其它注意">5.5 其它注意</h3>
<p>遵循以上格式的同时，还有一些建议。</p>
<ol>
<li>
<p>commit message解释当前 commit 所解决的问题，重点描述产生此更改的原因，而不是手段，因为代码会解释一切。应当解释清楚是否存在副作用以及其他不直观的影响。</p>
</li>
<li>
<p>只看注释便可明白而无需查看变更内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Good</span>
Add <span class="sb">`</span>use<span class="sb">`</span> method to Credit model 
为 Credit 模块添加 <span class="sb">`</span>use<span class="sb">`</span> 方法
<span class="c1"># Bad</span>
Add <span class="sb">`</span>use<span class="sb">`</span> method 
添加 <span class="sb">`</span>use<span class="sb">`</span> 方法
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Good</span>
Increase left padding between textbox and layout frame 
在 textbox 和 layout frame 之间添加向左对齐
<span class="c1"># Bad</span>
Adjust css 
就改了下 css
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用信息本身来解释“原因”、“目的”、“手段”和其他的细节</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Good</span>
Fix method name of InventoryBackend child classes
   
Classes derived from InventoryBackend were not
respecting the base class interface.
   
It worked because the cart was calling the backend implementation
incorrectly.
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Good</span>
Serialize and deserialize credits to json in Cart
   
Convert the Credit instances to dict <span class="k">for</span> two main reasons:
   
  - Pickle relies on file path <span class="k">for</span> classes and we <span class="k">do</span> not want to <span class="nb">break</span> up
    everything <span class="k">if</span> a refactor is needed
  - Dict and built-in types are pickleable by default
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Good</span>
Add <span class="sb">`</span>use<span class="sb">`</span> method to Credit
   
Change from namedtuple to class because we need to
setup a new attribute <span class="o">(</span>in_use_amount<span class="o">)</span> with a new value
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>保持语言的一致性</p>
<p>对于项目所有者而言：选择一种语言并使用该语言编写所有的 commit 信息。理想情况下，它应与代码注释、默认翻译区域（用于本地化项目）等相匹配。</p>
<p>对于贡献者而言：使用与现有 commit 历史相同的语言编写 commit 信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Good</span>
ababab Add <span class="sb">`</span>use<span class="sb">`</span> method to Credit model
efefef Use InventoryBackendPool to retrieve inventory backend
bebebe Fix method name of InventoryBackend child classes
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Good (Portuguese example)</span>
ababab Adiciona o método <span class="sb">`</span>use<span class="sb">`</span> ao model Credit
efefef Usa o InventoryBackendPool para recuperar o backend de estoque
bebebe Corrige nome de método na classe InventoryBackend
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Bad (mixes English and Portuguese)</span>
ababab Usa o InventoryBackendPool para recuperar o backend de estoque
efefef Add <span class="sb">`</span>use<span class="sb">`</span> method to Credit model
cdcdcd Agora vai
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="参考及扩展阅读">参考及扩展阅读</h2>
<ul>
<li>
<p><a href="https://github.com/shuzang/books/blob/master/git-cheatsheet.pdf" target="_blank" rel="noopener noreffer">git cheat sheet</a></p>
</li>
<li>
<p><a href="https://git-scm.com/" target="_blank" rel="noopener noreffer">git官网</a></p>
</li>
<li>
<p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener noreffer">git中文指南</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener noreffer">廖雪峰的官方网站-git教程</a></p>
</li>
<li>
<p><a href="https://chris.beams.io/posts/git-commit/" target="_blank" rel="noopener noreffer">如何编写 Git Commit Message</a></p>
</li>
<li>
<p><a href="https://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#_commit_guidelines" target="_blank" rel="noopener noreffer">Pro Git Book - Commit 指南</a></p>
</li>
<li>
<p><a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="noopener noreffer">关于 Git Commit Messages 的说明</a></p>
</li>
<li>
<p><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener noreffer">合并与变基</a></p>
</li>
<li>
<p><a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" target="_blank" rel="noopener noreffer">Pro Git Book - 改写历史</a></p>
</li>
<li>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener noreffer">Commit message 和 Change log 编写指南</a></p>
</li>
<li>
<p><a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener noreffer">AngularJS Git Commit Message Conventions</a></p>
</li>
<li>
<p><a href="https://github.com/RomuloOliveira/commit-messages-guide/blob/master/README_zh-CN.md" target="_blank" rel="noopener noreffer">commit-messages-guide_中文版</a></p>
</li>
<li>
<p><a href="https://nitayneeman.com/posts/understanding-semantic-commit-messages-using-git-and-angular/" target="_blank" rel="noopener noreffer">Understanding Semantic Commit Messages Using Git and Angular</a></p>
</li>
</ul>
]]></description></item><item><title>Git入门-基本概念, 基本原理, 安装使用</title><link>https://shuzang.github.io/git-learning-getting-started/</link><pubDate>Fri, 20 Apr 2018 19:06:20 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/git-learning-getting-started/</guid><description><![CDATA[<p>版本控制系统在代码开发过程中必不可缺，本系列学习 Git 的使用，版本托管服务则是 Github。以廖雪峰大神 <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener noreffer">git教程</a> 为主体，辅以使用过程中遇到的问题和心得。</p>
<h2 id="1-版本控制系统">1. 版本控制系统</h2>
<h3 id="11-作用">1.1 作用</h3>
<p>版本控制系统用来解决两种情况</p>
<ol>
<li>
<p>文章不断进行修改，但又觉得之前的版本可能有用，于是产生大量重命名文件，代码编辑亦如是，而且更加不容易回溯。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">版本1.doc   
版本2.doc   
最终版本.doc   
最终版本改.doc   
真的是最终版本了.doc
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>多人协作，每次都需要校对对方的改动，然后进行合并，会花费大量不必要的精力</p>
</li>
</ol>
<p>版本控制的作用就是记录所有的修改历史，便于需要时回退，同时提供一个协作的平台。</p>
<h3 id="11-历史">1.1 历史</h3>
<p>Git 属于分布式版本控制，在此之前主要是<strong>集中式的版本控制</strong>，基本原理是有一个服务器放所有的代码，要工作的时候下载回来，改动完上传回去，记录不同人的改动和合并都由服务器端完成，这种形式极度依赖于服务器性能和网速。</p>
<p>2005 年 Linux 内核代码版本控制使用的软件失效，Linux 创始人 Linus 花了一周开发了 Git 这个分布式版本控制系统，其后慢慢流行，现在已用于大多数的项目代码管理。</p>
<p><strong>分布式版本控制</strong>和 torrent 差不多，每个人的电脑都是服务器，修改完直接把修改的部分推送给所有拥有这个项目的人。分布式版本控制也有服务器，但主要是负责做备份，并方便大家的交换用的，并不是必要。</p>
<h3 id="12-github">1.2 Github</h3>
<p><strong>Github</strong>，发音为「 ɡɪthʌb 」，是为开源项目免费提供 Git 存储的网站，2008年上线。</p>
<p>注意，Git 和 Github 这两个单词在官方的网站上首字母都是大写，因此我们遵从这样的规则。</p>
<h2 id="2-安装使用">2. 安装使用</h2>
<p>Git 是全平台的软件，命令行界面，连接到服务商（比如 Github）就能使用，目前 Github 已经推出了 windows 上的 GUI 版本，操作更加简便。</p>
<h3 id="21-linux安装">2.1 Linux安装</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt-get install git
$ git version
</code></pre></td></tr></table>
</div>
</div><p>安装完成后还要设置自己的名字和Email地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git config --global  user.name   <span class="s2">&#34;your name&#34;</span>
$ git config --global  user.email  <span class="s2">&#34;email@example.com&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>--global</code>参数的意思是这个名字和邮箱应用于所有git仓库</p>
<h3 id="22-windows安装">2.2 windows安装</h3>
<p>从<a href="https://git-scm.com/" target="_blank" rel="noopener noreffer">官网</a>下载<code>Download x.xx for Windows</code>按照，会自动配置环境变量。我一般使用chocolatey包管理工具，执行命令如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="p">&gt;</span> <span class="n">choco</span> <span class="n">install</span> <span class="n">git</span>
</code></pre></td></tr></table>
</div>
</div><p>Windows下GUI版下载地址为：https://desktop.github.com/ ，嗯，真香，windows下我已经很久不用命令行的git了，一般都当作shell工具来使用，而不是执行git命令。</p>
<h2 id="3-仓库和文件">3. 仓库和文件</h2>
<p><strong><ruby>仓库<rt>repository</rt></ruby></strong>，本质是一个文件夹，存放归属同一个项目的所有文件，是版本控制中的一个重要概念，可分为本地仓库和云端仓库。本地仓库是自己的代码编辑工作区，云端仓库是代码的备份。</p>
<h3 id="31-创建一个仓库">3.1 创建一个仓库</h3>
<p>在本地任意路径创建<code>gittest</code>文件夹，路径自定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ mkdir gittest
</code></pre></td></tr></table>
</div>
</div><p>进入创建的文件夹，使用 <code>git init</code> 命令把该目录变成git的仓库</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> gittest
$ git init
</code></pre></td></tr></table>
</div>
</div><p>然后仓库就建好了，该目录下会多一个<code>.git</code>隐藏文件夹，用来跟踪管理仓库。使用<code>ls -a</code>命令可以看到该文件夹，默认隐藏说明它很重要，里面的文件改动的话很容易导致仓库损坏。<code>.git</code>文件夹下的内容包括</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls .git
config  description  HEAD  hooks/  info/  objects/  refs/
</code></pre></td></tr></table>
</div>
</div><p>一些文件的作用在<code>暂存区和工作区</code>部分解释。</p>
<h3 id="32-在仓库中添加文件">3.2 在仓库中添加文件</h3>
<p>添加文件的类型有讲究</p>
<ul>
<li>
<p>对txt文档、代码文件等文件类型，版本控制系统可记录每次的改动</p>
</li>
<li>
<p>对图片、视频、PDF等文件类型，版本控制系统只能管理，不能记录改动，最多只能记录大小变化，Word文件实质是二进制格式，所以同样没法跟踪改动</p>
</li>
</ul>
<p>首先新建一个txt文件并放在gittest目录下，编辑其文件内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> gittest
$ touch hellogit.txt
$ cat hellogit.txt
hello git
</code></pre></td></tr></table>
</div>
</div><p>用<code>git add</code>命令将该文件添加到暂存区，暂存区的概念之后解释</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git add  hellogit.txt
</code></pre></td></tr></table>
</div>
</div><p>用git  commit命令将文件提交到仓库(这里指本地仓库)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git commit -m <span class="s2">&#34;first commit&#34;</span>
<span class="o">[</span>master <span class="o">(</span>root-commit<span class="o">)</span> a91c248<span class="o">]</span> first commit
 <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>
 create mode <span class="m">100644</span> hellogit.txt
</code></pre></td></tr></table>
</div>
</div><p>双引号中为备注信息，是该次提交的说明，一般情况是描述此次修改的。commit添加的提交信息对于代码review具有重要的作用，要遵循一定的规范。</p>
<p>命令执行完后的提示包括以下内容：</p>
<ol>
<li>提交到了主分支（master)，备注信息为「first commit」</li>
<li>改动了一个文件（hellogit.txt），加了1行内容(注意那个+号)</li>
<li>最后一行中100代表regular file，644代表文件权限</li>
</ol>
<p><code>git add</code>命令可以有多个，分多次将文件添加到暂存区，之后执行<code>git commit</code>命令会一次性将之前add的所有文件一起提交，如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">git add file1.txt
git add file2.txt file3.txt
git commit -m <span class="s2">&#34;add 3 files&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以使用如下命令一次性将所有修改添加到暂存区，然后执行<code>commit</code>命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"> $ git add .
</code></pre></td></tr></table>
</div>
</div><h3 id="33-对文件进行修改">3.3 对文件进行修改</h3>
<p>版本控制的目的就是记录文件的改动，我们将hellogit.txt文件的内容进行第二次修改，用 git status 命令查看仓库当前状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git status
On branch master
Changes not staged <span class="k">for</span> commit:
  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span class="o">)</span>
  <span class="o">(</span>use <span class="s2">&#34;git checkout -- &lt;file&gt;...&#34;</span> to discard changes in working directory<span class="o">)</span>

        modified:   hellogit.txt

no changes added to commit <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> and/or <span class="s2">&#34;git commit -a&#34;</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>返回的提示内容会包括</p>
<ul>
<li>位于哪个分支</li>
<li>修改了哪个文件</li>
<li>「修改尚未加入提交」</li>
</ul>
<p>如果我们想看到具体做了哪些修改，用<code>git diff</code>命令，diff就是diffenence，所以<code>git diff</code>的意思就是查看不同</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git diff hellogit.txt
diff --git a/hellogit.txt b/hellogit.txt
index f09e9c3..a90a76d <span class="m">100644</span>
--- a/hellogit.txt
+++ b/hellogit.txt
@@ -1 +1,2 @@
-hello git
<span class="se">\ </span>No newline at end of file
+hello git
+add a line
<span class="se">\ </span>No newline at end of file
</code></pre></td></tr></table>
</div>
</div><p>提示中说明了我们在末尾添加了一行，其内容为<code>add a line</code>。此时我们确认了做的修改是我们心里所想的，就可以再次提交了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git add hellogit.txt
$ git status
On branch master
Changes to be committed:
  <span class="o">(</span>use <span class="s2">&#34;git reset HEAD &lt;file&gt;...&#34;</span> to unstage<span class="o">)</span>

        modified:   hellogit.txt

$ git commit -m <span class="s2">&#34;add a line&#34;</span>
<span class="o">[</span>master ae3c27f<span class="o">]</span> add a line
 <span class="m">1</span> file changed, <span class="m">2</span> insertions<span class="o">(</span>+<span class="o">)</span>, <span class="m">1</span> deletion<span class="o">(</span>-<span class="o">)</span>

$ git status
On branch master
nothing to commit, working tree clean
</code></pre></td></tr></table>
</div>
</div><p>提交过程中可以每一步都使用<code>git status</code>命令查看当前状态，最后commit提交完的状态提示为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">位于master分支
无文件要提交，干净的工作区
</code></pre></td></tr></table>
</div>
</div><p>此时就放心了，每次修改完或者要离开工作岗位的时候提交一次，就像游戏存档，离开之前或者重要关卡前存档，失败的时候就能读档重来，这里修改出错也可以从上一次的commit重来</p>
<h2 id="4-远程仓库">4. 远程仓库</h2>
<p>本地仓库的代码编辑完成后，需要推送到远程仓库进行备份，我们使用Github提供的免费远程仓库。由于本地Git仓库和GitHub远程仓库之间的传输是通过SSH加密的，所以，需要先设置SSH密钥。</p>
<h3 id="41-创建ssh-key">4.1 创建SSH Key</h3>
<p>在用户主目录下，看看有没有<code>.ssh</code>(默认隐藏)目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开终端，创建SSH Key：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa -C <span class="s2">&#34;youremail@example.com&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>把邮件地址换成自己的邮件地址，然后一路回车，使用默认值即可，是否设置密码自己选择。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有私钥<code>id_rsa</code>和公钥<code>id_rsa.pub</code>两个文件。</p>
<h3 id="42-登陆github">4.2 登陆GitHub</h3>
<p>点击右上角头像，打开<code>Settings——&gt;SSH and GPG Keys——&gt;New SSH Key</code></p>
<p>填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，然后点击<code>Add SSH key</code>就行了</p>
<p>GitHub需要SSH Key识别出你推送的提交确实是你推送的，而不是别人冒充的。当然，GitHub允许添加多个Key。假定有若干电脑，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<h3 id="43-创建远程仓库">4.3 创建远程仓库</h3>
<p>首先在Github创建一个<strong>同名仓库</strong></p>
<p>
</p>
<p>创建完成后跳转界面给我们提供了三个选择</p>
<ul>
<li>
<p>&hellip;or create a new repository on the command line</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&#34;# gittest&#34;</span> &gt;&gt; README.md
git init
git add README.md
git commit -m <span class="s2">&#34;first commit&#34;</span>
git remote add origin https://github.com/shuzang/gittest.git
git push -u origin master
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>&hellip;or push an existing repository from the command line</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">git remote add origin https://github.com/shuzang/gittest.git
git push -u origin master
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>&hellip;or import code from another repository</p>
<p>You can initialize this repository with code from a Subversion, Mercurial, or TFS project.</p>
</li>
</ul>
<p>第一个选项基本就是没有本地仓库的情况下我们要做的所有事情，不过现在我们已经有了本地仓库，所以选择第二个选项，将本地已存在的gittest仓库关联到Github。</p>
<p>按提示执行命令即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git remote add origin https://github.com/shuzang/gittest.git
$ git push -u origin master
Enumerating objects: 6, <span class="k">done</span>.
Counting objects: 100% <span class="o">(</span>6/6<span class="o">)</span>, <span class="k">done</span>.
Delta compression using up to <span class="m">4</span> threads
Compressing objects: 100% <span class="o">(</span>2/2<span class="o">)</span>, <span class="k">done</span>.
Writing objects: 100% <span class="o">(</span>6/6<span class="o">)</span>, <span class="m">448</span> bytes <span class="p">|</span> 448.00 KiB/s, <span class="k">done</span>.
Total <span class="m">6</span> <span class="o">(</span>delta 0<span class="o">)</span>, reused <span class="m">0</span> <span class="o">(</span>delta 0<span class="o">)</span>
To https://github.com/shuzang/gittest.git
 * <span class="o">[</span>new branch<span class="o">]</span>      master -&gt; master
Branch <span class="s1">&#39;master&#39;</span> <span class="nb">set</span> up to track remote branch <span class="s1">&#39;master&#39;</span> from <span class="s1">&#39;origin&#39;</span>.
</code></pre></td></tr></table>
</div>
</div><p>返回的结果告诉我们分支master设置为跟踪来自origin的远程分支master，代码已推送到远程仓库。此时查看远程仓库如下</p>
<p></p>
<p>点击左侧中间的<code>2 commits</code>可以查看提交的具体情况</p>
<p></p>
<p>继续点击每个具体的提交可以查看代码或文件的改动</p>
<p></p>
<p>查看别人的代码时，可以从这里查看一次次提交的改动和commit信息，有助于帮助我们学习别人的代码和编写思路</p>
<p>以后编辑和提交代码，主体就三个命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git add .
$ git commit -m <span class="s2">&#34;commit message&#34;</span>
$ git push origin master
</code></pre></td></tr></table>
</div>
</div><p>其它的git命令都是辅助，之后会慢慢介绍</p>
<h3 id="44-从远程仓库克隆到本地">4.4 从远程仓库克隆到本地</h3>
<p>换到新电脑或者不是自己从头新建仓库，而是使用别人的仓库进行合作开发，使用<code>git clone</code>命令，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git clone 仓库地址
</code></pre></td></tr></table>
</div>
</div><p>如果是下载某个指定分支的内容，命令为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git clone -b 分支名 仓库地址
</code></pre></td></tr></table>
</div>
</div><h2 id="5-历史版本">5. 历史版本</h2>
<p>修改的次数会逐渐变多，随着时间的流逝，我们完全不会记得每次修改了哪些内容，当然，git的出现就是为了帮我们解决这个问题，所以理所当然的会有查看历史版本的能力，以及回退到某个版本的能力，云端查看历史版本如上节所述，本地命令行如何查看在本节详细解释，以及介绍如果丢弃错误的提交。</p>
<h3 id="51-查看历史版本">5.1 查看历史版本</h3>
<p>使用 <code>git log</code> 命令可以查看历史改动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git log
commit ae3c27f99068e6eb301fd7d28960b97ec56b9733 <span class="o">(</span>HEAD -&gt; master, origin/master<span class="o">)</span>
Author: shuzang &lt;844327696@qq.com&gt;
Date:   Tue Jan <span class="m">7</span> 10:52:14 <span class="m">2020</span> +0800

    add a line

commit a91c24851ecd74e933bd638fd30773050bd7c692
Author: shuzang &lt;844327696@qq.com&gt;
Date:   Tue Jan <span class="m">7</span> 10:42:01 <span class="m">2020</span> +0800

    first commit
</code></pre></td></tr></table>
</div>
</div><p>提示内容是按从近到远的顺序把所有改动列举一遍，包括用户名、邮箱、修改日期，当时添加的message信息，不想看名称、邮箱和日期可以使用参数简化显示，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git log --pretty<span class="o">=</span>oneline
ae3c27f99068e6eb301fd7d28960b97ec56b9733 <span class="o">(</span>HEAD -&gt; master, origin/master<span class="o">)</span> add a line
a91c24851ecd74e933bd638fd30773050bd7c692 first commit
</code></pre></td></tr></table>
</div>
</div><p>也可以用以下命令查看参数使用方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git log --help
</code></pre></td></tr></table>
</div>
</div><p>提示内容中每次修改最前面的一串长字符是版本号（commit  id），用十六进制表示，用来代表我们每次修改的版本</p>
<h3 id="52-回退">5.2 回退</h3>
<p>首先，在git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然历史版本数多的时候写<code>^</code>写不过来，所以写成<code>HEAD~number</code>，如往上100个版本就是<code>HEAD-100</code><br>
回退命令为<code>git reset</code>，比如，回退到上一个版本</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git  reset --hard HEAD^
HEAD is now at a91c248 first commit
</code></pre></td></tr></table>
</div>
</div><p>然后我们就看到真的变回去了，如果记下了版本号，我们还可以再跳回最后一个修改版本，也就是说，我们突然不想回退了，或者退多了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git reset  --hard ae3c
HEAD is now at ae3c27f add a line
</code></pre></td></tr></table>
</div>
</div><p><code>ae3c</code>为其版本号，但版本号没必要写全，因为它的作用是为了区分各版本，所以只要找到第一个不相同的那位字母，写到那里就行了</p>
<p>版本切换的速度非常快，主要是因为<code>HEAD</code>只是一个指向当前版本的指针，跳转版本的时候也仅仅移动指针</p>
<p>在不记得版本号的情况下，git还提供了<code>git reflog</code>命令记录每次<code>HEAD</code>指针移动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git reflog
ae3c27f <span class="o">(</span>HEAD -&gt; master, origin/master<span class="o">)</span> HEAD@<span class="o">{</span>0<span class="o">}</span>: reset: moving to ae3c
a91c248 HEAD@<span class="o">{</span>1<span class="o">}</span>: reset: moving to HEAD^
ae3c27f <span class="o">(</span>HEAD -&gt; master, origin/master<span class="o">)</span> HEAD@<span class="o">{</span>2<span class="o">}</span>: commit: add a line
a91c248 HEAD@<span class="o">{</span>3<span class="o">}</span>: commit <span class="o">(</span>initial<span class="o">)</span>: first commit
</code></pre></td></tr></table>
</div>
</div><p>该命令会显示每次修改版本的版本号</p>
<h2 id="6-三大工作区域">6. 三大工作区域</h2>
<p>使用 Git 最好理解它的三大工作区域：工作目录、暂存区和版本仓库。</p>
<p><strong>工作目录</strong>就是代码编辑的主体目录，存放整个项目的源码和相关文件。</p>
<p><strong>暂存区</strong>也叫做索引，用来跟踪工作目录的所有文件。事实上，工作目录中的每一个文件要么处于已跟踪状态，要么处于未跟踪状态，执行这个跟踪动作的，就是索引。索引所对应的静态文件是工作目录下 <code>.git</code> 隐藏文件夹中的 <code>index</code> 文件，其中记录每个已跟踪文件的文件名、文件时间戳、文件长度等元数据信息。需要注意的是，索引并不保持文件的具体内容，只记录文件的改动，文件的具体内容保持在版本仓库中。<code>git add</code> 命令可以将改变提交给暂存区。</p>
<p><strong>版本仓库</strong>就是本地电脑具体保存所有代码的地方。具体位置是 <code>.git/objects</code> 文件夹，暂存区的文件经过 <code>git commit</code> 命令可以提交到本地版本仓库。本地版本仓库需要和远程的云端仓库（也就是存在 Github 服务器里的仓库文件）同步，如果有修改，需要推送到远程仓库，如果远程有别人的提交，需要拉取和本地代码合并。</p>
<p>版本库里有暂存区，还有自动创建的第一个分支master，以及指向master的一个指针叫HEAD

<code>git add</code>实际上是把文件修改添加到暂存区；
<code>git commit</code>实际上是把暂存区的所有内容提交到当前分支</p>
<p>在推送到远程仓库之前，一切修改都有挽救的机会</p>
<h3 id="61-丢弃修改">6.1 丢弃修改</h3>
<p><strong>场景1</strong>：当改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，使用命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 撤销单个文件修改</span>
$ git checkout -- file
<span class="c1"># 撤销从上次提交后所有修改</span>
$ git checkout -- *
</code></pre></td></tr></table>
</div>
</div><p><strong>场景2</strong>：当不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git reset HEAD file
$ git checkout -- file
</code></pre></td></tr></table>
</div>
</div><p><strong>场景3</strong>：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考上一节进行版本回退</p>
<p>最后，如果代码已经提交到了远程仓库，那么只能进行修复然后进行新的提交</p>
<h3 id="62-删除文件">6.2 删除文件</h3>
<p>一般情况，是直接在文件夹中用rm命令删除，但这样工作区和版本库就不一致了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ rm hellogit.txt
$ git status
On branch master
Your branch is up to date with <span class="s1">&#39;origin/master&#39;</span>.

Changes not staged <span class="k">for</span> commit:
  <span class="o">(</span>use <span class="s2">&#34;git add/rm &lt;file&gt;...&#34;</span> to update what will be committed<span class="o">)</span>
  <span class="o">(</span>use <span class="s2">&#34;git checkout -- &lt;file&gt;...&#34;</span> to discard changes in working directory<span class="o">)</span>

        deleted:    hellogit.txt

no changes added to commit <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> and/or <span class="s2">&#34;git commit -a&#34;</span><span class="o">)</span>
$ git add .
$ git commit -m <span class="s2">&#34;remove hellogit.txt&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>可以用命令恢复</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -- hellogit.txt
</code></pre></td></tr></table>
</div>
</div><p>正常从版本库中删除该文件，用<code>git rm</code>命令，并且<code>git commit</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git rm hellogit.txt
rm <span class="s1">&#39;hellogit.txt&#39;</span>
$ git status
On branch master
Your branch is up to date with <span class="s1">&#39;origin/master&#39;</span>.

Changes to be committed:
  <span class="o">(</span>use <span class="s2">&#34;git reset HEAD &lt;file&gt;...&#34;</span> to unstage<span class="o">)</span>

        deleted:    hellogit.txt

$ git commit -m <span class="s2">&#34;remove hellogit.txt&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>两者的区别是直接删除需要额外执行<code>git add</code>命令，而<code>git rm</code>删除后可以直接<code>commit</code>，当然，其实没有多少影响，具体用什么方法，自己选择就好。</p>
<h2 id="参考与扩展">参考与扩展</h2>
<p>[1] <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener noreffer">廖雪峰的官方网站-git教程</a></p>
<p>[2] <a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html" target="_blank" rel="noopener noreffer">猴子都能懂的git入门</a></p>
<p>[3] <a href="https://lab.github.com/" target="_blank" rel="noopener noreffer">Github Learning Lab</a></p>
<p>[4] <a href="https://hellogithub.com/" target="_blank" rel="noopener noreffer">Hellogithub</a></p>]]></description></item></channel></rss>