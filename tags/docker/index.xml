<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Docker - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/docker/</link><description>Docker - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 18 May 2020 17:13:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/tags/docker/" rel="self" type="application/rss+xml"/><item><title>网络</title><link>https://shuzang.github.io/network/</link><pubDate>Mon, 18 May 2020 17:13:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/network/</guid><description><![CDATA[<p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>
<h2 id="1-外部访问容器">1. 外部访问容器</h2>
<p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker container ls</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -P training/webapp python app.py
$ docker container ls -lCONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMESbc533791f3f5  training/webapp:latest  python app.py <span class="m">5</span> seconds ago  Up <span class="m">2</span> seconds  0.0.0.0:49155-&gt;5000/tcp  nostalgic_morse
</code></pre></td></tr></table>
</div>
</div><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker logs -f nostalgic_morse
* Running on http://0.0.0.0:5000/
10.0.2.2 - - <span class="o">[</span>23/May/2014 20:16:31<span class="o">]</span> <span class="s2">&#34;GET / HTTP/1.1&#34;</span> <span class="m">200</span> -
10.0.2.2 - - <span class="o">[</span>23/May/2014 20:16:31<span class="o">]</span> <span class="s2">&#34;GET /favicon.ico HTTP/1.1&#34;</span> <span class="m">404</span> -
</code></pre></td></tr></table>
</div>
</div><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<ul>
<li>
<p>使用 <code>hostPort:containerPort</code> 格式将本地的 5000 端口映射到容器的 5000 端口，可以执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -p 5000:5000 training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div><p>此时默认会绑定本地所有接口上的所有地址。</p>
</li>
<li>
<p>使用 <code>ip:hostPort:containerPort</code> 格式可以指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker port nostalgic_morse <span class="m">5000</span>
127.0.0.1:49155.
</code></pre></td></tr></table>
</div>
</div><p>注意：</p>
<ul>
<li>
<p>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</p>
</li>
<li>
<p><code>-p</code> 标记可以多次使用来绑定多个端口，如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d <span class="se">\
</span><span class="se"></span>    -p 5000:5000 <span class="se">\
</span><span class="se"></span>    -p 3000:80 <span class="se">\
</span><span class="se"></span>    training/webapp <span class="se">\
</span><span class="se"></span>    python app.py
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="2-容器互联">2. 容器互联</h2>
<p>通过将容器加入自定义的 Docker 网络可以连接多个容器</p>
<h3 id="21-新建网络">2.1 新建网络</h3>
<p>下面先创建一个新的 Docker 网络。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker network create -d bridge my-net
</code></pre></td></tr></table>
</div>
</div><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code>和 <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 Swarm mode，暂时不需要理解。</p>
<h3 id="22-连接容器">2.2 连接容器</h3>
<p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -it --rm --name busybox1 --network my-net busybox sh
</code></pre></td></tr></table>
</div>
</div><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -it --rm --name busybox2 --network my-net busybox sh
</code></pre></td></tr></table>
</div>
</div><p>再打开一个新的终端查看容器信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker container ls

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b47060aca56b        busybox             <span class="s2">&#34;sh&#34;</span>                <span class="m">11</span> minutes ago      Up <span class="m">11</span> minutes                           busybox2
8720575823ec        busybox             <span class="s2">&#34;sh&#34;</span>                <span class="m">16</span> minutes ago      Up <span class="m">16</span> minutes                           busybox1
</code></pre></td></tr></table>
</div>
</div><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p>在 <code>busybox1</code> 容器输入以下命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">/ <span class="c1"># ping busybox2</span>
PING busybox2 <span class="o">(</span>172.19.0.3<span class="o">)</span>: <span class="m">56</span> data bytes
<span class="m">64</span> bytes from 172.19.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">0</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.072 ms
<span class="m">64</span> bytes from 172.19.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.118 ms
</code></pre></td></tr></table>
</div>
</div><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">/ <span class="c1"># ping busybox1</span>
PING busybox1 <span class="o">(</span>172.19.0.2<span class="o">)</span>: <span class="m">56</span> data bytes
<span class="m">64</span> bytes from 172.19.0.2: <span class="nv">seq</span><span class="o">=</span><span class="m">0</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.064 ms
<span class="m">64</span> bytes from 172.19.0.2: <span class="nv">seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.143 ms
</code></pre></td></tr></table>
</div>
</div><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<h2 id="3-docker-compose">3. Docker Compose</h2>
<p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。当我们有多个容器之间需要互相连接，需要使用该工具。</p>
<h3 id="31-简单介绍">3.1 简单介绍</h3>
<p><code>Compose</code>允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，因此可以通过 <code>pip</code> 进行安装，也可以从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener noreffer">官方 GitHub Release</a> 处直接下载编译好的二进制文件。根据安装方式的不同，执行 <code>pip uninstall</code> 命令或删除二进制包来卸载 compose。不过值得庆幸的是，<code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p>
<h3 id="32-使用">3.2 使用</h3>
<p>用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站，以此为例进行介绍。首先新建文件夹，在该目录中编写 <code>app.py</code> 文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">redis</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;redis&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s1">&#39;hits&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Hello World! 该页面已被访问 {} 次。</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&#34;0.0.0.0&#34;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>编写 <code>Dockerfile</code> 文件，内容为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> python:3.6-alpine</span><span class="err">
</span><span class="err"></span><span class="k">ADD</span> . /code<span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /code</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> pip install redis flask<span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;python&#34;</span><span class="p">,</span> <span class="s2">&#34;app.py&#34;</span><span class="p">]</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">.</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">     </span>- <span class="s2">&#34;5000:5000&#34;</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">redis</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;redis:alpine&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>运行 compose 项目</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker-compose up
</code></pre></td></tr></table>
</div>
</div><p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h3 id="33-模板文件">3.3 模板文件</h3>
<p>docker-compose 的命令可以执行 <code>docker-compose --help</code> 查看理解。这里要详细说明的是 Compose 模板文件。</p>
<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yml" data-lang="yml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3&#34;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">webapp</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">examples/web</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;80:80&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;/data&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>常用命令介绍如下</p>
<h4 id="build">build</h4>
<p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="nt">&#39;3&#39;services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">webapp:    build</span><span class="p">:</span><span class="w"> </span><span class="l">./dir</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="nt">&#39;3&#39;services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">webapp:    build:      context: ./dir      dockerfile: Dockerfile-alternate      args:        buildno</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">build</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l">.</span><span class="w">
</span><span class="w">  </span><span class="nt">cache_from</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">alpine:latest</span><span class="w">
</span><span class="w">    </span>- <span class="l">corp/web_app:3.14</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="command">command</h4>
<p>覆盖容器启动后默认执行的命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">echo &#34;hello world&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="container_name">container_name</h4>
<p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">docker-web-container</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
<h4 id="devices">devices</h4>
<p>指定设备映射关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">devices</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="s2">&#34;/dev/ttyUSB1:/dev/ttyUSB0&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="depends_on">depends_on</h4>
<p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> 和 <code>db</code> 再启动 <code>web</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">.</span><span class="w">
</span><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">db</span><span class="w">
</span><span class="w">      </span>- <span class="l">redis</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">redis</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">redis</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>
<h4 id="dns">dns</h4>
<p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">dns</span><span class="p">:</span><span class="w"> </span><span class="m">8.8.8.8</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">dns</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="m">8.8.8.8</span><span class="w">
</span><span class="w">  </span>- <span class="m">114.114.114.114</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="dns_search">dns_search</h4>
<p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">dns_search</span><span class="p">:</span><span class="w"> </span><span class="l">example.com</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">dns_search</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">domain1.example.com</span><span class="w">
</span><span class="w">  </span>- <span class="l">domain2.example.com</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="env_file">env_file</h4>
<p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">env_file</span><span class="p">:</span><span class="w"> </span><span class="l">.env</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">env_file</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">./common.env</span><span class="w">
</span><span class="w">  </span>- <span class="l">./apps/web.env</span><span class="w">
</span><span class="w">  </span>- <span class="l">/opt/secrets.env</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># common.env: Set development environment</span><span class="w">
</span><span class="w"></span><span class="l">PROG_ENV=development</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="environment">environment</h4>
<p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">RACK_ENV</span><span class="p">:</span><span class="w"> </span><span class="l">development</span><span class="w">
</span><span class="w">  </span><span class="nt">SESSION_SECRET</span><span class="p">:</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">RACK_ENV=development</span><span class="w">
</span><span class="w">  </span>- <span class="l">SESSION_SECRET</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener noreffer">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="kc">y</span><span class="l">|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="expose">expose</h4>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">expose</span><span class="p">:</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;3000&#34;</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;8000&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="extra_hosts">extra_hosts</h4>
<p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">extra_hosts</span><span class="p">:</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;googledns:8.8.8.8&#34;</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;dockerhub:52.1.157.61&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="m">8.8.8.8</span><span class="w"> </span><span class="l">googledns</span><span class="w">
</span><span class="w"></span><span class="m">52.1.157.61</span><span class="w"> </span><span class="l">dockerhub</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="healthcheck">healthcheck</h4>
<p>通过命令检查容器是否健康运行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">healthcheck</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">test</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;CMD&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;curl&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;-f&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;http://localhost&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">  </span><span class="nt">interval</span><span class="p">:</span><span class="w"> </span><span class="l">1m30s</span><span class="w">
</span><span class="w">  </span><span class="nt">timeout</span><span class="p">:</span><span class="w"> </span><span class="l">10s</span><span class="w">
</span><span class="w">  </span><span class="nt">retries</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="image">image</h4>
<p>指定镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu</span><span class="w">
</span><span class="w"></span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">orchardup/postgresql</span><span class="w">
</span><span class="w"></span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">a4bc65fd</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="labels">labels</h4>
<p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">com.startupteam.description</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;webapp for a startup team&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">com.startupteam.department</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;devops department&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">com.startupteam.release</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;rc3 for v1.0&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="logging">logging</h4>
<p>配置日志选项</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">logging</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="l">syslog</span><span class="w">
</span><span class="w">  </span><span class="nt">options</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">syslog-address</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;tcp://192.168.0.42:123&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>目前支持三种日志驱动类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;json-file&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;syslog&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;none&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>options</code> 配置日志驱动的相关参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">options</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">max-size</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;200k&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">max-file</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;10&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="network_mode">network_mode</h4>
<p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">network_mode</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;bridge&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">network_mode</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;host&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">network_mode</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;none&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">network_mode</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;service:[service name]&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">network_mode</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;container:[container name/id]&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="networks">networks</h4>
<p>配置容器连接的网络。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">some-service</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">     </span>- <span class="l">some-network</span><span class="w">
</span><span class="w">     </span>- <span class="l">other-network</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">some-network</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">other-network</span><span class="p">:</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="pid">pid</h4>
<p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">pid</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;host&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="ports">ports</h4>
<p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;3000&#34;</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;8000:8000&#34;</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;49100:22&#34;</span><span class="w">
</span><span class="w"> </span>- <span class="s2">&#34;127.0.0.1:8001:8001&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><em>注意：当使用</em> <em><code>HOST:CONTAINER</code></em> <em>格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为</em> <em><code>YAML</code></em> <em>会自动解析</em> <em><code>xx:yy</code></em> <em>这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h4 id="secrets">secrets</h4>
<p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.1&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">mysql</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">mysql</span><span class="w">
</span><span class="w">  </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">MYSQL_ROOT_PASSWORD_FILE</span><span class="p">:</span><span class="w"> </span><span class="l">/run/secrets/db_root_password</span><span class="w">
</span><span class="w">  </span><span class="nt">secrets</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">db_root_password</span><span class="w">
</span><span class="w">    </span>- <span class="l">my_other_secret</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">secrets</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">my_secret</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">file</span><span class="p">:</span><span class="w"> </span><span class="l">./my_secret.txt</span><span class="w">
</span><span class="w">  </span><span class="nt">my_other_secret</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">external</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="volumes">volumes</h4>
<p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w"> </span>- <span class="l">/var/lib/mysql</span><span class="w">
</span><span class="w"> </span>- <span class="l">cache/:/tmp/cache</span><span class="w">
</span><span class="w"> </span>- <span class="l">~/configs:/etc/configs/:ro</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3&#34;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">my_src</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">mysql:8.0</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">mysql_data:/var/lib/mysql</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">mysql_data</span><span class="p">:</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="其它">其它</h4>
<p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">entrypoint</span><span class="p">:</span><span class="w"> </span><span class="l">/code/entrypoint.sh</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>指定容器中运行应用的用户名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">user</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>指定容器中工作目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">working_dir</span><span class="p">:</span><span class="w"> </span><span class="l">/code</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>指定容器中搜索域名、主机名、mac 地址等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">domainname</span><span class="p">:</span><span class="w"> </span><span class="l">your_website.com</span><span class="w">
</span><span class="w"></span><span class="nt">hostname</span><span class="p">:</span><span class="w"> </span><span class="l">test</span><span class="w">
</span><span class="w"></span><span class="nt">mac_address</span><span class="p">:</span><span class="w"> </span><span class="m">08-00-27-00</span>-<span class="l">0C-0A</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>允许容器中运行一些特权命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">privileged</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">read_only</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>打开标准输入，可以接受外部输入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">stdin_open</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>模拟一个伪终端。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">tty</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>镜像、容器与仓库</title><link>https://shuzang.github.io/image-container-and-repository/</link><pubDate>Mon, 18 May 2020 09:00:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/image-container-and-repository/</guid><description><![CDATA[<p>Docker 的三个基本概念是镜像（Image）、容器（Container）和仓库（Repository），理解了这三个概念基本就理解了 Docker。</p>
<h2 id="1-镜像">1. 镜像</h2>
<p>尽管都使用了镜像这个词，但 Docker 的镜像和虚拟机上安装的系统镜像并不完全相同。虚拟机安装的镜像是完整的操作系统，包括内核、根文件系统等部分，体积一般较大，比如 ubuntu20.04 LTS 就有2.5GB。而 Docker 的镜像不包括内核，可以看作一个定制的<strong>最小化</strong>的根文件系统，体积往往很小，本文写作时 docker ubuntu latest 仅有73.9MB。实际上，Docker 本身是基于宿主机的内核运行的。</p>
<h3 id="11-union-fs">1.1 Union FS</h3>
<p>Docker 镜像保持的如此之小，仅依靠去除内核和删减根文件系统是不够的，更重要的原因是，Docker 使用了 Union FS 的技术，整体设计是一个分层存储的架构。联合文件系统（UnionFS）是一种轻量级的高性能分层文件系统，它支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，应用看到的是挂载的最终结果。简单来说，镜像不是一整个文件，而是由一组文件系统组成，更具体一点，由多层文件系统组成。镜像构建时，会一层层构建，前一层是后一层的基础，每一层构建完就不会再发生改变，后一层的任何改变只会发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。以 ubuntu 为例，下载镜像时我们可以很清楚的看到分了四层</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker pull ubuntu  
Using default tag: latest
latest: Pulling from library/ubuntu
d51af753c3d3: Pull <span class="nb">complete</span>  
fc878cd0a91c: Pull <span class="nb">complete</span>   
6154df8ff988: Pull <span class="nb">complete</span>   
fee5db0ff82f: Pull <span class="nb">complete</span>    
Digest: sha256:747d2dbbaaee995098c9792d99bd333c6783ce56150d1b11e333bbceed5c54d7
Status: Downloaded newer image <span class="k">for</span> ubuntu:latest
docker.io/library/ubuntu:latest
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>docker history</code> 命令还可以查看镜像构建历史记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">history</span> ubuntu
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
1d622ef86b13        <span class="m">3</span> weeks ago         /bin/sh -c <span class="c1">#(nop)  CMD [&#34;/bin/bash&#34;]            0B</span>
&lt;missing&gt;           <span class="m">3</span> weeks ago         /bin/sh -c mkdir -p /run/systemd <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;do…   7B
</span><span class="s1">&lt;missing&gt;           3 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo &#39;</span><span class="c1">#!/bin/sh&#39; &gt; /…   811B</span>
&lt;missing&gt;           <span class="m">3</span> weeks ago         /bin/sh -c <span class="o">[</span> -z <span class="s2">&#34;</span><span class="k">$(</span>apt-get indextargets<span class="k">)</span><span class="s2">&#34;</span> <span class="o">]</span>     1.01MB
&lt;missing&gt;           <span class="m">3</span> weeks ago         /bin/sh -c <span class="c1">#(nop) ADD file:a58c8b447951f9e30…   72.8MB</span>
</code></pre></td></tr></table>
</div>
</div><p>分层存储的特征使得镜像的复用、定制变得更加容易，甚至可以用之前构建好的镜像作为基础层，然后一步步添加新层，以定制自己需要的内容，构建新的镜像。</p>
<h3 id="12-镜像使用">1.2 镜像使用</h3>
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<h4 id="获取镜像">获取镜像</h4>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker pull <span class="o">[</span>选项<span class="o">]</span> <span class="o">[</span>Docker Registry 地址<span class="o">[</span>:端口号<span class="o">]</span>/<span class="o">]</span>仓库名<span class="o">[</span>:标签<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>选项部分包括三个参数，但很少用到，可以通过 <code>docker pull --help</code> 查看，这里介绍镜像名称的格式</p>
<ul>
<li>
<p>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub（官方仓库地址）。</p>
</li>
<li>
<p>仓库名：仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</p>
</li>
</ul>
<p>仍以 ubuntu 为例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker pull ubuntu  
Using default tag: latest
latest: Pulling from library/ubuntu
d51af753c3d3: Pull <span class="nb">complete</span>  
fc878cd0a91c: Pull <span class="nb">complete</span>   
6154df8ff988: Pull <span class="nb">complete</span>   
fee5db0ff82f: Pull <span class="nb">complete</span>    
Digest: sha256:747d2dbbaaee995098c9792d99bd333c6783ce56150d1b11e333bbceed5c54d7
Status: Downloaded newer image <span class="k">for</span> ubuntu:latest
docker.io/library/ubuntu:latest
</code></pre></td></tr></table>
</div>
</div><p>命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。镜像名称为 <code>ubuntu</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>latest</code> 的镜像。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p>
<p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照</em> <a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener noreffer"><em>镜像加速器</em></a> <em>配置加速器。</em></p>
<h4 id="列出镜像">列出镜像</h4>
<p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              latest              1d622ef86b13        <span class="m">3</span> weeks ago         73.9MB
mysql               8.0                 0c27e8e5fcfa        <span class="m">3</span> weeks ago         546MB
mysql               latest              0c27e8e5fcfa        <span class="m">3</span> weeks ago         546MB
hello-world         latest              bf756fb1ae65        <span class="m">4</span> months ago        13.3kB
</code></pre></td></tr></table>
</div>
</div><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。j镜像ID 是镜像的唯一标识，一个镜像可能对应多个标签，比如上面例子中的 <code>mysql:8.0</code> 和 <code>mysql:latest</code>。</p>
<p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker image ls ubuntu <span class="c1">#根据仓库名列出镜像</span>
$ docker image ls ubuntu:18.04 <span class="c1">#列出指定仓库名和标签的镜像</span>
$ docker image ls -f <span class="nv">since</span><span class="o">=</span>mongo:3.2 <span class="c1">#使用过滤器列出指定条件的镜像</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="删除本地镜像">删除本地镜像</h4>
<p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker image rm <span class="o">[</span>选项<span class="o">]</span> &lt;镜像1&gt; <span class="o">[</span>&lt;镜像2&gt; ...<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker image rm mysql:8.0
Untagged: mysql:8.0
$ docker image rm ubuntu
Untagged: ubuntu:latest
Untagged: ubuntu@sha256:747d2dbbaaee995098c9792d99bd333c6783ce56150d1b11e333bbceed5c54d7
Deleted: sha256:1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01
Deleted: sha256:279e836b58d9996b5715e82a97b024563f2b175e86a53176846684f0717661c3
Deleted: sha256:39865913f677c50ea236b68d81560d8fefe491661ce6e668fd331b4b680b1d47
Deleted: sha256:cac81188485e011e56459f1d9fc9936625a1b62cacdb4fcd3526e5f32e280387
Deleted: sha256:7789f1a3d4e9258fbe5469a8d657deb6aba168d86967063e9b80ac3e1154333f
</code></pre></td></tr></table>
</div>
</div><p>可以注意到删除行为分两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。前面介绍过，镜像的唯一标识是 ID 和摘要，而一个镜像可以有多个标签，因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>镜像的删除也是分层进行的，如果某一层正被其他镜像使用，则不会被删除。另外，如果有基于当前镜像的容器正在进行，该镜像也不会被删除。</p>
<h4 id="虚悬镜像">虚悬镜像</h4>
<p>有时候镜像列表中会出现没有仓库名，也没有标签的特殊镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">&lt;none&gt;               &lt;none&gt;              00285df0df87        <span class="m">5</span> days ago          <span class="m">342</span> MB
</code></pre></td></tr></table>
</div>
</div><p>这个镜像原本应当是有镜像名和标签的，但随着官方镜像维护，发布了新版本后，重新执行 <code>docker pull</code> 时，镜像名和标签被转移到了新下载的镜像上，旧的镜像上的名称则被取消，从而成为 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 `` 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> 。一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker image prune
</code></pre></td></tr></table>
</div>
</div><h2 id="2-容器">2. 容器</h2>
<p>镜像与容器的关系，大致可以比对面向对象中的类与实例。具体来说，容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>
<h3 id="21-启动">2.1 启动</h3>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h4 id="新建并启动">新建并启动</h4>
<p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run ubuntu /bin/echo <span class="s1">&#39;hello world&#39;</span>
<span class="c1"># windows下使用git命令行需要输入 //bin/echo</span>
hello world
</code></pre></td></tr></table>
</div>
</div><p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -t -i ubuntu:18.04 /bin/bash
root@af8bae53bdd3:/#
</code></pre></td></tr></table>
</div>
</div><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。这两个是最常使用的选项</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">root@af8bae53bdd3:/# <span class="nb">pwd</span>
/
root@af8bae53bdd3:/# ls
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</code></pre></td></tr></table>
</div>
</div><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h4 id="启动已终止容器">启动已终止容器</h4>
<p>已启动的容器在执行完毕后不会被自动删除，利用 <code>docker container start</code> 命令，可以将一个已经终止的容器重新启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">root@ba267838cc1b:/# ps
  PID TTY          TIME CMD
    <span class="m">1</span> ?        00:00:00 bash
   <span class="m">11</span> ?        00:00:00 ps
</code></pre></td></tr></table>
</div>
</div><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h3 id="22-守护态运行">2.2 守护态运行</h3>
<p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。比如使用 <code>-d</code> 参数执行上面的命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d ubuntu /bin/echo <span class="s1">&#39;hello&#39;</span>
08e90e1961f8b12434931d5f0a64fa5f4615c9613d4b942310c991de17b9bc40
</code></pre></td></tr></table>
</div>
</div><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面，输出结果可以用 <code>docker logs</code> 查看</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker container logs 08e
hello
</code></pre></td></tr></table>
</div>
</div><p>注：容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关，容器只有在执行完命令后才会关闭，一种极端情况是，执行的命令是一个无限循环，这时容器永远不会关闭。</p>
<h3 id="23-终止">2.3 终止</h3>
<p>我们已经知道，当 Docker 容器中指定的应用终结时，容器也自动终止。不过，也可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>对于前面提到的启动了内置终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -t -i ubuntu:18.04 /bin/bash
root@af8bae53bdd3:/#
<span class="c1"># 输入 exit 或 使用 Ctrl+d 快捷键退出</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>docker container ls</code> 仅能看到运行状态的容器，要查看终止状态的容器需要使用 <code>docker container ls -a</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                               NAMES
08e90e1961f8        ubuntu              <span class="s2">&#34;//bin/echo hello&#34;</span>       <span class="m">9</span> minutes ago       Exited <span class="o">(</span>0<span class="o">)</span> <span class="m">9</span> minutes ago                                           lucid_napier
20cd094abd6c        ubuntu              <span class="s2">&#34;//bin/bash&#34;</span>             <span class="m">16</span> minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> <span class="m">10</span> minutes ago                                          awesome_fermat
b57c3358e522        ubuntu              <span class="s2">&#34;//bin/echo &#39;Hello w…&#34;</span>   <span class="m">18</span> minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> <span class="m">18</span> minutes ago                                          gifted_murdock
e47304d78c1a        ubuntu:latest       <span class="s2">&#34;C:/Program Files/Gi…&#34;</span>   <span class="m">23</span> minutes ago      Created                                                            serene_shamir
81284613ca04        hello-world         <span class="s2">&#34;/hello&#34;</span>                 About an hour ago   Exited <span class="o">(</span>0<span class="o">)</span> About an hour ago                                       nostalgic_meitner
cd6182d13e68        mysql               <span class="s2">&#34;docker-entrypoint.s…&#34;</span>   <span class="m">3</span> weeks ago         Exited <span class="o">(</span>255<span class="o">)</span> <span class="m">3</span> weeks ago       0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   chitchat
</code></pre></td></tr></table>
</div>
</div><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="24-进入容器">2.4 进入容器</h3>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。某些时候可能需要进入容器内进行操作，可以使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐使用 后者。</p>
<h4 id="attach-命令">attach 命令</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -it -d ubuntu
e132b98549ad94ba0809a73e86bd63a3fd5f86067735beb83b6b74a14e51772f

$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e132b98549ad        ubuntu              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">5</span> seconds ago       Up <span class="m">4</span> seconds                            intelligent_galois

$ docker attach e13
root@e132b98549ad:/# 
</code></pre></td></tr></table>
</div>
</div><p>如果从这个 stdin 中 exit，会导致容器的停止</p>
<h4 id="exec-命令">exec 命令</h4>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -it -d ubuntu
8486e83970e0c8d2594dff9277df369a867dc662feb1ac3b28c84dd305c8f078

$ docker <span class="nb">exec</span> -i <span class="m">848</span> bash
ls
bin
boot
dev
...

$ docker <span class="nb">exec</span> -it <span class="m">848</span> bash
root@69d137adef7a:/#
</code></pre></td></tr></table>
</div>
</div><p>如果从这个 stdin 中 exit，不会导致容器的停止，这就是为什么推荐使用 <code>docker exec</code></p>
<h3 id="25-导出与导入">2.5 导出与导入</h3>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
8486e83970e0        ubuntu              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">5</span> minutes ago       Up <span class="m">5</span> minutes                                   hardcore_haslett
e132b98549ad        ubuntu              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">7</span> minutes ago       Exited <span class="o">(</span>0<span class="o">)</span> <span class="m">5</span> minutes ago                       intelligent_galois

$ docker <span class="nb">export</span> <span class="m">848</span> &gt; ubuntu.tar
</code></pre></td></tr></table>
</div>
</div><p>这样将导出容器快照到本地文件，导出的目录为执行该命令的当前目录。</p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cat ubuntu.tar <span class="p">|</span> docker import - test/ubuntu:v1.0
sha256:8b3f836f35916cf3aa2199b06e84e917a6421438a58ed4fc1924cd6d07b85d45

$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
test/ubuntu         v1.0                8b3f836f3591        <span class="m">6</span> seconds ago       73.9MB
ubuntu              latest              1d622ef86b13        <span class="m">3</span> weeks ago         73.9MB
ubuntu              18.04               c3c304cb4f22        <span class="m">3</span> weeks ago         64.2MB
mysql               latest              0c27e8e5fcfa        <span class="m">3</span> weeks ago         546MB
hello-world         latest              bf756fb1ae65        <span class="m">4</span> months ago        13.3kB
</code></pre></td></tr></table>
</div>
</div><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker import http://example.com/exampleimage.tgz example/imagerepo
</code></pre></td></tr></table>
</div>
</div><p><em>注：用户既可以使用</em> <em><code>docker load</code></em> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <em><code>docker import</code></em> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h3 id="26-删除">2.6 删除</h3>
<p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
8486e83970e0        ubuntu              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">11</span> minutes ago      Up <span class="m">11</span> minutes                                   hardcore_haslett
e132b98549ad        ubuntu              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">13</span> minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> <span class="m">11</span> minutes ago                       intelligent_galois

$ docker container rm e13
e13

$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
8486e83970e0        ubuntu              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">11</span> minutes ago      Up <span class="m">11</span> minutes                           hardcore_haslett
</code></pre></td></tr></table>
</div>
</div><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker container rm -f <span class="m">848</span>
<span class="m">848</span>

$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre></td></tr></table>
</div>
</div><p>如果终止状态的容器太多，一个个删除很麻烦，可以使用下面的命令清理所有处于终止状态的容器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker container prune
</code></pre></td></tr></table>
</div>
</div><h2 id="3-仓库">3. 仓库</h2>
<p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener noreffer">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener noreffer">3,480,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>通过 <code>docker search</code> 命令来查找官方仓库中的镜像，通过 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>也可以构建自己的私有仓库，但这里不做介绍。</p>]]></description></item><item><title>Win10 Home版安装Docker Desktop on Windows</title><link>https://shuzang.github.io/install-docker-desktop-on-windows-10-home/</link><pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/install-docker-desktop-on-windows-10-home/</guid><description><![CDATA[<p>Docker Desktop 是 Windows 安装 Docker 的推荐安装方式，然而系统需求是 Pro, Enterprise 或 Education 版本，Home 版不支持，因为没有 Hyper-V。</p>
<p>这篇文章记录网上找到的 Win10 Home 版安装 Docker Desktop 的方式，主要思路是自行安装 Hyper-V 及 相关服务，并修改注册表欺骗 Docker 的安装检测。</p>
<h2 id="1-安装-hyper-v">1. 安装 Hyper-V</h2>
<p>新建 txt 文档，复制以下内容到文档中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-txt" data-lang="txt">pushd &#34;%~dp0&#34;
dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt
for /f %%i in (&#39;findstr /i . hyper-v.txt 2^&gt;nul&#39;) do dism /online /norestart /add-package:&#34;%SystemRoot%\servicing\Packages\%%i&#34;
del hyper-v.txt
Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL
</code></pre></td></tr></table>
</div>
</div><p>将文档格式后缀由 <code>.txt</code> 更改为 <code>.cmd</code>，然后以管理员方式执行。该脚本会自动安装 Hyper-V 服务，安装完成后按提示键入 <code>Y</code>，电脑自动重启。注意，这里键入 <code>Y</code> 后直接就重启了，所以有其它未保存任务及时保存。</p>
<p>重启完成后进入搜索「启用或关闭 Windows 功能」并打开，查看 「Hyper-V」选项是否被选中，如果没有，勾选并重启电脑。</p>
<p>再次新建 txt 文档并填充如下内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-txt" data-lang="txt">pushd &#34;%~dp0&#34;
dir /b %SystemRoot%\servicing\Packages\*containers*.mum &gt;containers.txt
for /f %%i in (&#39;findstr /i . containers.txt 2^&gt;nul&#39;) do dism /online /norestart /add-package:&#34;%SystemRoot%\servicing\Packages\%%i&#34;
del containers.txt
Dism /online /enable-feature /featurename:Containers -All /LimitAccess /ALL
pause
</code></pre></td></tr></table>
</div>
</div><p>更改后缀为 <code>.cmd</code> 并以管理员方式执行，安装完毕后键入 <code>Y</code> 重启电脑。至此第一步完成</p>
<h2 id="2-伪装成专业版绕过安装检测">2. 伪装成专业版绕过安装检测</h2>
<p>Docker Desktop 安装时会检测系统版本，因此我们修改注册表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion

EditionID = Professional
</code></pre></td></tr></table>
</div>
</div><p>然后遵照<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener noreffer">官方文档</a>下载安装 Docker即可。</p>
<p>注：重启后修改的注册表项会自动还原，但不影响 Docker 运行。</p>
<h2 id="3-测试">3. 测试</h2>
<p>查看 Docker 版本</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker --version
Docker version 19.03.8, build afacb8b
</code></pre></td></tr></table>
</div>
</div><p>运行 <code>hello-world</code> 镜像测试安装是否成功</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run hello-world                                                                                                
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the <span class="s2">&#34;hello-world&#34;</span> image from the Docker Hub.
    <span class="o">(</span>amd64<span class="o">)</span>
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre></td></tr></table>
</div>
</div><p>出现 <code>Hello from Docker!</code> 说明安装成功。</p>
]]></description></item><item><title>使用 Docker 安装运行 mysql</title><link>https://shuzang.github.io/using-docker-installation-to-run-mysql/</link><pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/using-docker-installation-to-run-mysql/</guid><description><![CDATA[<p>Docker Hub 中的 mysql 镜像 地址为 <a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a>，安装运行过程如下。</p>
<h2 id="1-拉取镜像">1. 拉取镜像</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker pull mysql
<span class="c1"># 查看</span>
$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mysql               latest              0c27e8e5fcfa        <span class="m">6</span> hours ago         546MB
hello-world         latest              bf756fb1ae65        <span class="m">3</span> months ago        13.3kB
</code></pre></td></tr></table>
</div>
</div><h2 id="2-运行-mysql-容器">2. 运行 mysql 容器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -p 3306:3306 --name some-mysql -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>my-secret-pw -d mysql:tag
</code></pre></td></tr></table>
</div>
</div><p>上面各命令的含义为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">run                 运行一个docker容器
--name           	后面这个是生成的容器的名字some-mysql
-p 3306:3306  		表示这个容器中使用3306（第二个）映射到本机的端口号也为3306（第一个） 
-e MYSQL_ROOT_PASSWORD=123456  初始化root用户的密码
-d                   表示使用守护进程运行，即服务挂在后台
</code></pre></td></tr></table>
</div>
</div><p><code>tag</code> 是 MySQL 版本，比如可以填写 <code>5.7</code>，如果没有设置版本，Dcoker 会自动在本地检测有没有最新的，如果没有会自动去 Docker Hub 下载。该字段的选项如下</p>
<ul>
<li>8.0.19，8.0，8，latest</li>
<li>5.7.29，5.7，5</li>
<li>5.6.47，5.6</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 查看当前容器运行状态</span>
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                 NAMES
94e4725784bb        mysql:8.0           <span class="s2">&#34;docker-entrypoint.s…&#34;</span>   <span class="m">5</span> seconds ago       Up <span class="m">4</span> seconds        3306/tcp, 33060/tcp   chitchat
</code></pre></td></tr></table>
</div>
</div><p>如果暂时关闭了容器界面，隔了一天后回来，使用<code>docker ps</code>命令可能看不到任何东西，这时候添加<code>-a</code>参数</p>
<h2 id="3-进入-mysql-容器">3. 进入 mysql 容器</h2>
<p>执行 <code>docker exec</code> 命令进入 mysql 容器，该命令会在容器中启动一个命令行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -it chitchat bash
</code></pre></td></tr></table>
</div>
</div><p>日志文件可通过如下命令查看</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker logs chitchat
</code></pre></td></tr></table>
</div>
</div><p>之后操作为正常的 mysql 命令操作，如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">root@94e4725784bb:/# mysql -u root -p
Enter password:
Welcome to the MySQL monitor.  Commands end with <span class="p">;</span> or <span class="se">\g</span>.
Your MySQL connection id is <span class="m">8</span>
Server version: 8.0.19 MySQL Community Server - GPL

Copyright <span class="o">(</span>c<span class="o">)</span> 2000, 2020, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type <span class="s1">&#39;help;&#39;</span> or <span class="s1">&#39;\h&#39;</span> <span class="k">for</span> help. Type <span class="s1">&#39;\c&#39;</span> to clear the current input statement.

mysql&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="4-测试连接">4. 测试连接</h2>
<p>第一种是使用 Navicat for MySQL 测试，Navicat 安装在宿主机的 win10系统中</p>
<p></p>
<p>点击「测试连接」查看连接是否成功，成功后点确定可以进入以图形化方式查看数据库</p>
<p>因为我们使用 Golang，这里写一段代码测试Golang连接是否成功</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">tes</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;database/sql&#34;</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="nx">_</span> <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">query</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//&#34;用户名:密码@[连接方式](主机名:端口号)/数据库名&#34;
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:****@(127.0.0.1:3306)/chitchat&#34;</span><span class="p">)</span> <span class="c1">// 设置连接数据库的参数
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>                                                  <span class="c1">//关闭数据库
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Ping</span><span class="p">()</span>                                                  <span class="c1">//连接数据库
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;数据库连接成功&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>如果连接成功，会输出「数据库连接成功」字样，此时同时也说明了我们在 Docker 中部署 MySQL，然后从宿主机连接的方式是可行的，宿主机中不需要再安装 MySQL client 等。</p>
<h2 id="5-退出与重连">5. 退出与重连</h2>
<p>输入<code>exit</code>退出 docker 内的命令行，再次输入 <code>exit</code> 退出 docker，此时退出容器但没有关闭</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -it chitchat bash                                                                                         root@cd6182d13e68:/# <span class="nb">exit</span>
<span class="nb">exit</span>

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
cd6182d13e68        mysql               <span class="s2">&#34;docker-entrypoint.s…&#34;</span>   <span class="m">11</span> hours ago        Up <span class="m">8</span> minutes        0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   chitchat
</code></pre></td></tr></table>
</div>
</div><p>进入已启动的容器可以使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker attach chitchat
</code></pre></td></tr></table>
</div>
</div><p>不过重启电脑后运行 <code>docker ps</code>发现没了，此时执行 <code>docker start</code>命令可以再次启动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker start chitchat
</code></pre></td></tr></table>
</div>
</div><p>不使用docker直接在win10中安装mysql参考<a href="https://www.cnblogs.com/xiaokang01/p/12092160.html" target="_blank" rel="noopener noreffer">win10安装Mysql教程</a></p>
]]></description></item></channel></rss>