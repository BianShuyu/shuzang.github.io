<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Go语法 - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/go%E8%AF%AD%E6%B3%95/</link><description>Go语法 - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 15 Aug 2020 09:47:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/tags/go%E8%AF%AD%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>Golang深入学习9-调用栈</title><link>https://shuzang.github.io/golang-deep-learning-9-call-stack/</link><pubDate>Sat, 15 Aug 2020 09:47:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-9-call-stack/</guid><description><![CDATA[<p>本篇介绍如何分析 Go 的调用栈。</p>
<p>测试使用的版本是Go 1.14.3，下面介绍如何在Go调试的时候查看堆栈跟踪信息及识别传递的参数。</p>
<p>示例程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;runtime/debug&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
	<span class="nf">Example</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Example</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">str</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">debug</span><span class="p">.</span><span class="nf">PrintStack</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在程序中我们使用了 runtime/debug 下的 PrintStack() 函数将调用栈的返回信息打印到标准错误输出，如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="nx">running</span><span class="p">]:</span>
<span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">:</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="o">/</span><span class="nx">stack</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">24</span> <span class="o">+</span><span class="mh">0xa8</span>
<span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="p">.</span><span class="nf">PrintStack</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">:</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="o">/</span><span class="nx">stack</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span> <span class="o">+</span><span class="mh">0x29</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">Example</span><span class="p">(</span><span class="mh">0xc000077f38</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mh">0x4a8534</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">,</span> <span class="mh">0xa</span><span class="p">)</span>
	<span class="nx">f</span><span class="p">:</span><span class="o">/</span><span class="nx">Gotest</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">13</span> <span class="o">+</span><span class="mh">0x2e</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
	<span class="nx">f</span><span class="p">:</span><span class="o">/</span><span class="nx">Gotest</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">9</span> <span class="o">+</span><span class="mh">0xb1</span>
<span class="nx">Process</span> <span class="nx">exiting</span> <span class="nx">with</span> <span class="nx">code</span><span class="p">:</span> <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，在其它编程语言如C中，运行一个程序会启动一个线程来执行，在Go中，启动的是一个 Goroutine。上面第一行就说明了启动了一个 Goroutine，Goroutine ID 为1，其后各行是不同层次的调用，最深的调用最先打印，最浅的调用最后打印。各行说明如下</p>
<p>第8、9行：main package 的 main 函数，代码文件路径为 <code>f:/Gotest/main.go</code>，调用出现在 main.go 文件的第9行</p>
<p>第6、7行：main 函数调用 Example 函数</p>
<p>第4、5行：Example 函数调用 debug.PrintStack 函数</p>
<p>第2，3行：debug.PrintStack 函数调用 debug.Stack 函数</p>
<p>Example 函数传参信息如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用
</span><span class="c1"></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nf">Example</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">// 栈追踪
</span><span class="c1"></span><span class="nx">main</span><span class="p">.</span><span class="nf">Example</span><span class="p">(</span><span class="mh">0xc000077f38</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mh">0x4a8534</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">,</span> <span class="mh">0xa</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>堆栈跟踪信息中，前三个参数分别代表切片的指针、长度、容量，第4和第5个参数代表字符串的指针和大小，最后一个参数指向整型数值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 切片
</span><span class="c1"></span><span class="nx">Pointer</span><span class="p">:</span> <span class="mh">0xc000077f38</span>
<span class="nx">Length</span><span class="p">:</span> <span class="mh">0x2</span>
<span class="nx">Capacity</span><span class="p">:</span> <span class="mh">0x4</span>
<span class="c1">// 字符串
</span><span class="c1"></span><span class="nx">Pointer</span><span class="p">:</span> <span class="mh">0x4a8534</span>
<span class="nx">Length</span><span class="p">:</span> <span class="mh">0x5</span>
<span class="c1">// 整数
</span><span class="c1"></span><span class="nx">base</span> <span class="mi">16</span><span class="p">:</span> <span class="mh">0xa</span>
</code></pre></td></tr></table>
</div>
</div><p>如果是调用方法，跟踪信息会显示接收者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 程序
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;runtime/debug&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">trace</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
   <span class="kd">var</span> <span class="nx">t</span> <span class="nx">trace</span>
   <span class="nx">t</span><span class="p">.</span><span class="nf">Example</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">trace</span><span class="p">)</span> <span class="nf">Example</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">str</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Receiver Address: %p\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
   <span class="nx">debug</span><span class="p">.</span><span class="nf">PrintStack</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// 堆栈信息
</span><span class="c1"></span><span class="nx">Receiver</span> <span class="nx">Address</span><span class="p">:</span> <span class="mh">0x5781c8</span>
<span class="nx">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="nx">running</span><span class="p">]:</span>
<span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="mh">0x15</span><span class="p">,</span> <span class="mh">0xc000071ef0</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">)</span>
	<span class="nx">C</span><span class="p">:</span><span class="o">/</span><span class="nx">Go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="o">/</span><span class="nx">stack</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">24</span> <span class="o">+</span><span class="mh">0xae</span>
<span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="p">.</span><span class="nf">PrintStack</span><span class="p">()</span>
	<span class="nx">C</span><span class="p">:</span><span class="o">/</span><span class="nx">Go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="o">/</span><span class="nx">stack</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span> <span class="o">+</span><span class="mh">0x29</span>
<span class="nx">main</span><span class="p">.(</span><span class="o">*</span><span class="nx">trace</span><span class="p">).</span><span class="nf">Example</span><span class="p">(</span><span class="mh">0x5781c8</span><span class="p">,</span> <span class="mh">0xc000071f48</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mh">0x4c04bb</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">,</span> <span class="mh">0xa</span><span class="p">)</span>
	<span class="nx">D</span><span class="p">:</span><span class="o">/</span><span class="nx">gopath</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span> <span class="o">+</span><span class="mh">0x7c</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
	<span class="nx">D</span><span class="p">:</span><span class="o">/</span><span class="nx">gopath</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">13</span> <span class="o">+</span><span class="mh">0x9a</span>
</code></pre></td></tr></table>
</div>
</div><p>传递的参数全部为值类型时，可能会防止一个32位的字中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 程序
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;runtime/debug&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nf">Example</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Example</span><span class="p">(</span><span class="nx">b1</span><span class="p">,</span> <span class="nx">b2</span><span class="p">,</span> <span class="nx">b3</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint8</span><span class="p">)</span> <span class="p">{</span>

   <span class="nx">debug</span><span class="p">.</span><span class="nf">PrintStack</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// 堆栈信息
</span><span class="c1"></span><span class="nx">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="nx">running</span><span class="p">]:</span>
<span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="mh">0x4</span><span class="p">,</span> <span class="mh">0xc00007a010</span><span class="p">,</span> <span class="mh">0xc000077f88</span><span class="p">)</span>
	<span class="nx">C</span><span class="p">:</span><span class="o">/</span><span class="nx">Go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="o">/</span><span class="nx">stack</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">24</span> <span class="o">+</span><span class="mh">0xae</span>
<span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="p">.</span><span class="nf">PrintStack</span><span class="p">()</span>
	<span class="nx">C</span><span class="p">:</span><span class="o">/</span><span class="nx">Go</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">runtime</span><span class="o">/</span><span class="nx">debug</span><span class="o">/</span><span class="nx">stack</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span> <span class="o">+</span><span class="mh">0x29</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">Example</span><span class="p">(</span><span class="mh">0xc019010001</span><span class="p">)</span>
	<span class="nx">D</span><span class="p">:</span><span class="o">/</span><span class="nx">gopath</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">12</span> <span class="o">+</span><span class="mh">0x27</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
	<span class="nx">D</span><span class="p">:</span><span class="o">/</span><span class="nx">gopath</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">example</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span> <span class="o">+</span><span class="mh">0x30</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到 Example 的参数只有一个，实际上底层四个参数放在一个字中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Parameter values
</span><span class="c1"></span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">25</span>

<span class="c1">// Word value
</span><span class="c1"></span><span class="nx">Bits</span>    <span class="nx">Binary</span>      <span class="nx">Hex</span>   <span class="nx">Value</span>
<span class="mo">00</span><span class="o">-</span><span class="mo">07</span>   <span class="mo">0000</span> <span class="mo">0001</span>   <span class="mo">01</span>    <span class="kc">true</span>
<span class="mi">08</span><span class="o">-</span><span class="mi">15</span>   <span class="mo">0000</span> <span class="mo">0000</span>   <span class="mo">00</span>    <span class="kc">false</span>
<span class="mi">16</span><span class="o">-</span><span class="mi">23</span>   <span class="mo">0000</span> <span class="mo">0001</span>   <span class="mo">01</span>    <span class="kc">true</span>
<span class="mi">24</span><span class="o">-</span><span class="mi">31</span>   <span class="mo">0001</span> <span class="mi">1001</span>   <span class="mi">19</span>    <span class="mi">25</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>Golang深入学习8-堆栈与逃逸分析</title><link>https://shuzang.github.io/golang-deep-learning-8-stack-heap-and-escape-analysis/</link><pubDate>Sat, 15 Aug 2020 08:47:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-8-stack-heap-and-escape-analysis/</guid><description><![CDATA[<p>本篇介绍 Go 的堆栈和逃逸分析。</p>
<h2 id="1-堆栈">1. 堆栈</h2>
<p>栈是一种后入先出的结构，计算机中也有一块满足该特性的动态内存区域，程序可以将数据压入栈中或者将数据从栈中弹出，从而使栈动态的增大或减小。</p>
<p>除此之外，堆也是计算机中的一中内存区域。堆与栈的区别如下</p>
<ol>
<li>栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放。</li>
<li>栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。</li>
<li>栈的访问速度相对比堆快。</li>
<li>一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack 是线程独占的，heap 是线程共用的。</li>
<li>stack 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap的大小是不确定的，需要的话可以不断增加。</li>
<li>栈是由高地址向低地址增长的，而堆是由低地址向高地址增长的。</li>
</ol>
<p>在 C/C++ 中，程序员申请的内存空间使用完毕后需要自己释放，在 Java、Go 等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。</p>
<h2 id="2-go的堆栈">2. Go的堆栈</h2>
<p>首先，Go 是自己管理内存的，而不是交给操作系统，它每次从操作系统申请一大块内存，然后按照 Google 的 <code>TCMalloc</code> 算法进行内存分配，也划分为堆、栈等很多区域。</p>
<p>这里我们主要关心变量究竟放在堆还是栈里，官方有这么一段解释</p>
<blockquote>
<p>只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。</p>
<p>在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。</p>
<p>总之，分配在堆还是栈完全由编译器确定。</p>
</blockquote>
<p>所以 Go 里变量分配在由编译器决定，我们虽然无法通过变量的类型判断它的存储位置，但可以通过打印程序的汇编代码来查看，主要使用 <code>go tool compile</code> 命令，示例程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">int</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[:]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 -S 参数编译，可以输出详细内容。可以看到第 6 行代码出现了 runtime.newobject，这就说明 main.go 第6行 的数组变量 a 分配在堆上。反之，如果没有发现 runtime.newobject 调用，就说明分配在栈上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -S main.go
...   
        0x0028 <span class="m">00040</span> <span class="o">(</span>main.go:6<span class="o">)</span>        PCDATA  <span class="nv">$0</span>, <span class="nv">$1</span>
        0x0028 <span class="m">00040</span> <span class="o">(</span>main.go:6<span class="o">)</span>        PCDATA  <span class="nv">$1</span>, <span class="nv">$0</span>
        0x0028 <span class="m">00040</span> <span class="o">(</span>main.go:6<span class="o">)</span>        LEAQ    type.<span class="o">[</span>1<span class="o">]</span>int<span class="o">(</span>SB<span class="o">)</span>, AX
        0x002f <span class="m">00047</span> <span class="o">(</span>main.go:6<span class="o">)</span>        PCDATA  <span class="nv">$0</span>, <span class="nv">$0</span>
        0x002f <span class="m">00047</span> <span class="o">(</span>main.go:6<span class="o">)</span>        MOVQ    AX, <span class="o">(</span>SP<span class="o">)</span>
        0x0033 <span class="m">00051</span> <span class="o">(</span>main.go:6<span class="o">)</span>        CALL    runtime.newobject<span class="o">(</span>SB<span class="o">)</span>
        0x0038 <span class="m">00056</span> <span class="o">(</span>main.go:6<span class="o">)</span>        PCDATA  <span class="nv">$0</span>, <span class="nv">$1</span>
        0x0038 <span class="m">00056</span> <span class="o">(</span>main.go:6<span class="o">)</span>        MOVQ    8<span class="o">(</span>SP<span class="o">)</span>, AX
        0x003d <span class="m">00061</span> <span class="o">(</span>main.go:8<span class="o">)</span>        PCDATA  <span class="nv">$0</span>, <span class="nv">$0</span>
        0x003d <span class="m">00061</span> <span class="o">(</span>main.go:8<span class="o">)</span>        MOVQ    AX, <span class="o">(</span>SP<span class="o">)</span>
        0x0041 <span class="m">00065</span> <span class="o">(</span>main.go:8<span class="o">)</span>        MOVQ    <span class="nv">$1</span>, 8<span class="o">(</span>SP<span class="o">)</span>
        0x004a <span class="m">00074</span> <span class="o">(</span>main.go:8<span class="o">)</span>        MOVQ    <span class="nv">$1</span>, 16<span class="o">(</span>SP<span class="o">)</span>
...
</code></pre></td></tr></table>
</div>
</div><p>使用 -m 参数可以输出优化后的描述，这里就看起来很清楚了，可以看到 main.go 第 6 行的变量 a 分配到了堆上，在第 8 行时，变量 c 逃逸到了堆上。关于逃逸我们在下一小节介绍。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -m main.go
main.go:8:13: inlining call to fmt.Println
main.go:6:6: moved to heap: a
main.go:8:13: c escapes to heap
main.go:8:13: <span class="o">[]</span>interface <span class="o">{}</span> literal does not escape
&lt;autogenerated&gt;:1: .this does not escape
&lt;autogenerated&gt;:1: .this does not escape
</code></pre></td></tr></table>
</div>
</div><p>也可以直接在 <code>go build</code> 命令中添加 <code>-gcflag=-m</code> 参数，意思是编译的同时以 <code>-m</code> 参数运行 <code>go tool compile</code>  命令，结果是相同的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go build -gcflags<span class="o">=</span>-m main.go
<span class="c1"># command-line-arguments</span>
.<span class="se">\m</span>ain.go:8:13: inlining call to fmt.Println
.<span class="se">\m</span>ain.go:6:6: moved to heap: a
.<span class="se">\m</span>ain.go:8:13: c escapes to heap
.<span class="se">\m</span>ain.go:8:13: <span class="o">[]</span>interface <span class="o">{}</span> literal does not escape
&lt;autogenerated&gt;:1: .this does not escape
&lt;autogenerated&gt;:1: .this does not escape
</code></pre></td></tr></table>
</div>
</div><h2 id="3-逃逸分析">3. 逃逸分析</h2>
<p>前面已经提到，Go 中变量分配在栈还是堆上完全由编译器决定，而原本看起来应该分配在栈上的变量，如果其生命周期获得了延长，被分配在了堆上，就说它发生了逃逸。编译器会自动地去判断变量的生命周期是否获得了延长，整个判断的过程就叫逃逸分析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nf">test</span><span class="p">()</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">2</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>举个例子，上面的程序中 b 作为局部变量，如果是在 C 语言中，<code>return &amp;b</code> 这样的写法无法通过，因为 b 在函数返回后已经消失了，但在 Go 中，编译器做了一下逃逸分析，发现返回 &amp;b 说明之后 b 还要用，于是就把 b 分配在了堆上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -m main.go
main.go:8:6: can inline <span class="nb">test</span>
main.go:3:6: can inline main
main.go:4:11: inlining call to <span class="nb">test</span>
main.go:9:2: moved to heap: b
</code></pre></td></tr></table>
</div>
</div><p>然后我们举另外一个例子如下，一个最简单的输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结果发现变量 a 依然逃逸了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -m main.go
main.go:7:13: inlining call to fmt.Println
main.go:7:13: a escapes to heap
main.go:7:13: <span class="o">[]</span>interface <span class="o">{}</span> literal does not escape
&lt;autogenerated&gt;:1: .this does not escape
&lt;autogenerated&gt;:1: .this does not escape
</code></pre></td></tr></table>
</div>
</div><p>这是因为输出其实是调用了 fmt 包的 Println 函数，变量的生命周期依然得到了扩展，如果我们使用 println 函数，就不会发生逃逸</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -m main.go
main.go:3:6: can inline main
</code></pre></td></tr></table>
</div>
</div><p>所以现在我们可以更好的理解官方说明中的这句话：如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。</p>
<p>变量发生逃逸的情况可以总结如下</p>
<ol>
<li><strong>在方法内把局部变量指针返回</strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li>
<li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li>
<li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li>
<li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li>
<li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li>
</ol>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://segmentfault.com/a/1190000017498101" target="_blank" rel="noopener noreffer">Go堆栈的理解</a></p>
<p>[2] 阮一峰，<a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="noopener noreffer">栈的三种含义</a></p>
<p>[3] <a href="https://golang.org/doc/faq" target="_blank" rel="noopener noreffer">官方关于变量分配在堆还是栈上的说明</a></p>
<p>[4] Young，CSDN，<a href="https://blog.csdn.net/agonie201218/article/details/77574556" target="_blank" rel="noopener noreffer">Go 的变量到底在堆还是栈中分配</a></p>
<p>[5] 胖虎，微信公众号，<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483686&amp;idx=1&amp;sn=e48c51107191f02da5751a19a54f7d41&amp;chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&amp;token=2092782362&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreffer">简单聊聊内存逃逸</a></p>]]></description></item><item><title>Golang查漏补缺-定义与声明的区别</title><link>https://shuzang.github.io/golang-supplement-the-difference-between-definition-and-declaration/</link><pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-supplement-the-difference-between-definition-and-declaration/</guid><description><![CDATA[<p>一直都比较纠结这个问题，所以搜了一下答案，记录在这里。</p>
<p>变量的声明有两种情况：</p>
<ol>
<li>需要建立存储空间，这种称为定义性声明（defining declaration），简称定义</li>
<li>不需要建立存储空间，这种称为引用性声明（referncing declaration）</li>
</ol>
<p>所以广义的讲，声明包含定义，定义是声明的一个特例。</p>
<p>在 Go 中，基本变量类型在声明时都会分配存储空间并分配默认值，因此都属于定义性声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">b</span> <span class="kt">float32</span>
    <span class="nx">c</span> <span class="kt">bool</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>但是，像切片、映射、通道等，声明时不会分配存储空间，要分配空间还必须使用 make 内置函数，因此它们是引用性声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Go 的官方文档中，使用的也都是 declaration 这个词，统一用「声明」来描述</p>]]></description></item><item><title>Golang深入学习7-调度器与垃圾回收</title><link>https://shuzang.github.io/golang-deep-learning-7-scheduler-and-garbage-collection/</link><pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-7-scheduler-and-garbage-collection/</guid><description><![CDATA[<p>调度器和垃圾回收都属于 runtime 的一部分，本文我们介绍 Go 中 runtime 的含义，然后再来分析 Go 的调度器和垃圾回收策略。</p>
<h2 id="1-runtime">1. runtime</h2>
<p>runtime，直译为运行时，之前只听说过这个概念，但要解释 runtime 究竟是什么，还是说不出口。我从 Go 官方文档的问答里找到了下面这段话，可以作为一个很好的开始。</p>
<blockquote>
<p>Go does have an extensive library, called the <em>runtime</em>, that is part of every Go program. The runtime library implements garbage collection, concurrency, stack management, and other critical features of the Go language. Although it is more central to the language, Go&rsquo;s runtime is analogous to <code>libc</code>, the C library.</p>
<p>It is important to understand, however, that Go&rsquo;s runtime does not include a virtual machine, such as is provided by the Java runtime. Go programs are compiled ahead of time to native machine code (or JavaScript or WebAssembly, for some variant implementations). Thus, although the term is often used to describe the virtual environment in which a program runs, in Go the word “runtime” is just the name given to the library providing critical language services.</p>
</blockquote>
<p>Go 的运行时是每个 Go 程序的一部分，负责实施垃圾回收、并发、栈管理以及其它 Go 的一些核心特性。但是，尽管这些都是一个语言的核心，<strong>runtime 在 Go 中实际上是一个库</strong>（标准库的一个）。理解这一点很重要，因为在其它一些语言中，比如 Java，runtime 实际上包含一个虚拟机的概念，是程序运行的环境，但在 Go 中 runtime 就仅仅是一个包含一些关键特性的库。</p>
<p>这里已经说的比较清楚了，接下来我们来看 runtime 库包含哪些东西，实际上，runtime 库下面还有几个子库</p>
<ul>
<li>runtime/cgo：用来支持 C 语言函数的调用</li>
<li>runtime/debug：进行问题排查</li>
<li>runtime/msan</li>
<li>runtime/pprof：进行性能分析</li>
<li>runtime/race：实现了数据静态检测逻辑</li>
<li>runtime/trace：执行跟踪器，捕获各种执行时的事件，比如 goroutine 的创建/阻塞/解除阻塞、系统调用的进入/退出/阻塞、垃圾回收相关的事件、堆大小的改变、处理器的启动和停止等，并将它们写入 io.writer 中</li>
</ul>
<p>需要知道的是，调度器、垃圾回收、各种数据类型的定义和操作(比如切片、接口等)都位于 runtime 库，而不是这几个子库，在电脑中的位置为 <code>$GOROOT/src/runtime</code></p>
<p>Go 的可执行文件一般比相应的源码文件大很多，这是因为 runtime 潜入了每一个可执行文件中，因此，Go 运行不依赖于其它任何文件。</p>
<h2 id="2-调度器">2. 调度器</h2>
<p>这部分关于调度器的介绍，主要翻译自 <a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="noopener noreffer">The Go scheduler</a> 这篇文章，写的非常容易理解。</p>
<p>在操作系统中，调度主要是对 CPU 时间片的分配策略，为了充分利用 CPU，将时间划分为一系列的时间片，然后遵循某种最优的策略（总执行时间最短或其它）将进程分配到某个时间片执行的过程。Go 中的调度做的也是类似的事，也就是如何分配 Goroutine 的执行，做这件事的工具就是调度器，而且我们也可以看出，调度器和 Go 的并发是息息相关的。</p>
<h3 id="21-设计理念">2.1 设计理念</h3>
<p>我们首先来理解为什么 Go 需要一个自己的调度器，而不是使用操作系统的调度器。首先，在操作系统中，线程的上下文切换也需要一定的资源，其中很多开销对 Go 的运行来说是不必要的，而且线程数量越多，这部分开销越大。另外一个重要的原因是交给操作系统调度无法基于 Go 当前的情况做出最优的调度决策，比如 Go 进行垃圾回收的时候，需要暂停正在运行的 Goroutine 和线程，并使内存保持在一个一致的状态，如果交给操作系统的调度器，就失去了对一致性状态的把握，并且需要等待所有相关线程停止工作，正在运行的线程越多，达到这个目的越难。如果 Go 使用自己的调度器，就知道什么时候内存状态是一致的（只针对 Go 程序分配的内存），它会在这些已知的内存一致性的时刻开始垃圾回收，并且此时只需要等待当前正在 CPU 核上执行的那个线程，而不是等待所有的线程。</p>
<p>有三种常见的线程模型，第一种是 N:1，也就是多个用户空间线程运行在一个 OS 线程上，其优点是上下文切换快速，缺点是不能充分利用多核系统的优点；第二种是 1:1，也就是一个用户空间线程对应一个 OS 线程，其优点是充分利用了系统的多个核，缺点是上下文切换的开销有点大。</p>
<p>Go 采用的是一种折衷的办法，即 M:N，也就是将任意数量的 Goroutine 对应到任意数量的 OS 线程，OS 线程的数量通常取决于 CPU 核的数目，这种方式保持了较低的上下文切换开销，并且充分利用了多核系统的优点，它主要的缺点是增加了调度器的复杂性。</p>
<p>Go 的调度器定义在 runtime 包中，具体的文件是 <code>src/runtime/proc.go</code>，最主要的概念有三个：P，M，G。其定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Goroutine scheduler
</span><span class="c1">// The scheduler&#39;s job is to distribute ready-to-run goroutines over worker threads.
</span><span class="c1">//
</span><span class="c1">// The main concepts are:
</span><span class="c1">// G - goroutine.
</span><span class="c1">// M - worker thread, or machine.
</span><span class="c1">// P - processor, a resource that is required to execute Go code.
</span><span class="c1">//     M must have an associated P to execute Go code, however it can be
</span><span class="c1">//     blocked or in a syscall w/o an associated P.
</span><span class="c1">//
</span><span class="c1">// Design doc at https://golang.org/s/go11sched.
</span></code></pre></td></tr></table>
</div>
</div><p>用图形描述更直观一点</p>
<p></p>
<p>M 是 OS 线程，由操作系统管理，是实际的执行者，M 是 Machine 的首字母大写。</p>
<p>G 是 Goroutine，它包括堆栈，指令指针和其他对调度 Goroutine 重要的信息。</p>
<p>P 是调度的上下文，可以看作 Go 自己的调度器，负责将 Goroutine 调度到具体的 OS 线程上执行，他是实现 M:N 模型的关键，P 是 Processor 的首字母大写。</p>
<h3 id="22-调度策略">2.2 调度策略</h3>
<p>我们基于上面的三个概念来描述 Go 的调度策略。</p>
<p></p>
<p>上图中有两个 M，每个线程 M  都持有一个调度器 P，并且运行着一个 G。调度器的数目可以通过设置 GOMAXPROCS 环境变量或者调用 runtime.GOMAXPROCS 函数来设定，通常在设定好后，程序运行期间该值不会改变。事实上，该值的设定是充分利用多核的关键，比如，如果有一个 4 核的计算机，我们通常将 GOMAXPROCS 设定为 4，这样操作系统中会同时有 4 个线程运行 Goroutine。</p>
<p>灰色的 G 意味着 Goroutine 没有在运行，而是处于等待被调度的状态，这里使用了一个队列来存放它们，称为运行队列(runqueue)。每当使用 go 关键字启动一个 Goroutine 时，它就被加入运行队列的尾部，当 P 到达某个调度的时刻，就从运行队列首部取出一个 Goroutine ，设置好堆栈和指令指针，然后分配给关联的 M 运行。为了减少争用，每个 P 都有自己的运行队列。</p>
<p>注：早期的时候所有 P 公用一个运行队列，但这种情况下调度时需要加解锁，线程经常被阻塞。</p>
<p>运行队列不空，P 有用来调度的 Goroutine，那么就不会发生意外，调度会处于一个稳定的状态。但实际环境下是会产生意外的，我们介绍如下：</p>
<ol>
<li>
<p>线程出于某些原因需要阻塞。这时候 P 无法再将 Goroutine 交给自己的 M 运行，然后就会将 Goroutine 移交给其它的 M 运行。</p>
<p></p>
<p>如上图，我们可以看到 M0 由于系统调用（syscall）发生了阻塞，与之相关的 P （实际上是下文）就被移交给了 M1（这里我们可以更好的理解为什么 P 的本质是上下文，只是<strong>可以看作</strong>调度器）。调度程序会确保有足够的 M 来运行 P，上面的 M1 可能仅为了处理移交的 P 和对应的 Goroutine创建，也可能来自线程池。M0 将保留正在执行的 Goroutine，因为实质上它仍然在执行，只是在 OS 中被阻塞。</p>
<p>当 syscall 返回时，M0 必须尝试获取一个 P 用来执行未执行完的 G0，一般情况是从其它线程窃取一个 P，如果无法窃取到，就会把 G0 放到全局的运行队列中，然后把自己放到线程池进入睡眠状态。</p>
<p>全局的运行队列是 P 从自己的运行队列无法获取到 G 时读取的地方，P 会定期检测全局运行队列，防止全局运行队列中的 Goroutine 始终得不到执行。</p>
<p>这种处理过程说明了为什么即使 GOMAXPROCS=1，Go 程序运行也会涉及到多个线程，G0 会停留在syscall 线程上。</p>
</li>
<li>
<p>运行队列中的 Goroutine 被用尽了。如果每个 P 的运行队列上 Goroutine 的数量不平衡，就可能发生这种情况</p>
<p></p>
<p>前面已经提到，P 本身的运行队列空了的时候，会从全局运行队列获取 Goroutine，那么，如果全局运行队列也为空呢。P 就会从其它 P 那里窃取 Goroutine，一般情况下会窃取大约一半的运行队列，这样可以保证两个 P 一直有 Goroutine 可调用，也就是保持平衡，从而保证所有的线程不处于空闲状态。上图中空闲 P 从其它 P 窃取了两个 Goroutine，一个直接开始执行，剩下的放入运行队列，此时两个 P 的运行队列大小相同。</p>
</li>
</ol>
<p>所以，在操作系统层面，Go 采用的是抢占式调度，如果 M 陷入了阻塞，那么会导致当前在它上面的 Goroutine 长时间占用 M，这时候就会发生抢占， P 会寻找其它的 M，然后把 G 交给新的 M 调度。但是在语言层面，后来的 Goroutine 永远假如运行队列的末尾，不会抢占 P。</p>
<blockquote>
<p>非抢占式调度是进程/线程交给 CPU 后，会一直执行完毕，不会被中断；</p>
<p>抢占式调度是 CPU 正在执行的进程/线程会被具有更高优先级的进程/线程抢占掉（可以防止单一进程长时间独占 CPU）。</p>
</blockquote>
<p>其它参考：<a href="https://zhuanlan.zhihu.com/p/27328476" target="_blank" rel="noopener noreffer">说说Golang的runtime</a></p>
<h2 id="3-垃圾回收">3. 垃圾回收</h2>
<p>垃圾回收（Garbage Collection，GC），是一种存储管理机制。我们编写的程序中，变量、函数参数等在内存通常存放在两个不同的区域：栈和堆。栈的分配由操作系统管理，而堆的分配由程序员管理，在 C 和一些语言中，程序员使用 malloc 申请空间后，最后还需要自己使用 free 释放空间，编译器不会辅助完成这个过程，如果忘记释放，就可能造成不可预知的后果（内存泄漏等）。而在 Go 和另一些编程语言中，主动提供了一种机制，它会在后台持续的运行，监控各个变量和参数的状态，识别那些不再使用的对象并释放掉它们的内存空间，这种机制（或者说这个后台进程）叫做<strong>垃圾回收</strong>。</p>
<h3 id="31-常见的gc算法">3.1 常见的GC算法</h3>
<p>有很多用于垃圾回收的算法。</p>
<p>第一个叫做<strong>引用计数</strong>，方法是为每个对象添加一个引用计数器，每当有引用指向该对象，计数器+1，释放时计数器-1，当 GC 检测到计数器为 0 时，说明该对象不再被使用，就回收为它分配的内存。其缺点是无法检测到循环引用，因为循环引用的引用计数永远不可能为 0。</p>
<p>第二个叫做<strong>根搜索算法</strong>，Java 和 C# 使用了这种办法。原理是通过一系列称为 <code>GC Root</code> 的对象作为起点，从这些节点向下搜索，所走过的路径称为引用链（Reference Chain），如果一个对象到 <code>GC Root</code> 没有任何引用链相连，那么就说明该对象的内存可以被回收。Java 中可以作为 GC Root 的对象包括虚拟机栈中的引用对象、类静态属性引用的对象、常量引用的对象和本地方法栈中的引用对象。</p>
<p></p>
<p>第三种叫做<strong>标记-清除算法</strong>。它将垃圾回收划分为两个阶段，在标记阶段标记所有可回收的对象，然后在回收阶段回收被标记对象占用的空间。其缺点主要有两个，第一个是标记时需要暂停整个程序的运行，第二个是会产生大量的内存碎片，如下图，碎片比较多的话后续可能没有足够的连续内存分配给需求较多的对象。</p>
<p></p>
<p>第四种是<strong>复制算法</strong>。复制算法是标记-清除算法的改进，它将内存分为两个相等的区域，每次只使用其中一个区域，进行垃圾回收时，会把当前存活的所有对象复制到另一个空间，然后堆当前空间进行回收。如下图，这种算法解决了内存碎片的问题，代价是可使用的内存为原理的一半，并且由于额外的复制操作，效率会有一定的影响。</p>
<p></p>
<p>第五种是<strong>标记-压缩算法</strong>。标记-压缩算法与复制算法思路相似，都是将内存分两块，不同在于，标记完可回收的对象后，标记-压缩算法会将存活的对象压缩到内存的一端，让它们紧凑的排列在一起，然后对边界以外的空间进行回收，回收后，已用和未用的内存各自在一边。如下图，标记压缩算法解决了内存碎片问题和回收效率低的问题。</p>
<p></p>
<p>第六种是<strong>分代收集</strong>。分代收集是一种思路，研究发现，程序中大部分对象的生命周期都很短，所以根据对象生命周期的长短，使用不同的垃圾回收算法。生命周期比较长的叫做老年代，通常使用标记-压缩算法，生命周期比较短的叫做新生代，通常使用复制算法。</p>
<p>本节主要参考：简书，顾林海，<a href="https://www.jianshu.com/p/4c88861e3b79" target="_blank" rel="noopener noreffer">垃圾回收算法有哪些</a></p>
<h3 id="32-go的垃圾回收">3.2 Go的垃圾回收</h3>
<p>Go 的垃圾回收经历了一个比较长的演变过程，具体可以参考 <a href="https://blog.golang.org/ismmkeynote" target="_blank" rel="noopener noreffer">The Journey of Go&rsquo;s Garbage Collector</a> 这篇文章。</p>
<p>目前 Go 使用的是<strong>三色标记法</strong>。三色标记法是标记-回收算法的一种改进，它将所有的对象用白色、灰色、黑色三种颜色表示，基本步骤如下</p>
<ol>
<li>
<p>开始时将所有对象标记为白色；</p>
<p></p>
</li>
<li>
<p>GC 从根结点开始扫描，下图中，A 和 F 是根结点，所以将它们标记为灰色（注意这一步标记为灰色的是根结点集合的所有对象）</p>
<p></p>
</li>
<li>
<p>遍历灰色节点，将灰色节点所引用的节点也标记为灰色，这里 A 引用了 B、C、D，F 没有引用，然后将分析过的灰色节点标记为黑色，如下图</p>
<p></p>
</li>
<li>
<p>循环遍历灰色节点，直到灰色节点的个数为 0，下图中，B、C、D都没有引用的白色节点，所以这一轮都标记为了黑色</p>
<p></p>
</li>
<li>
<p>此时对白色节点对应的内存空间进行垃圾回收</p>
<p></p>
</li>
<li>
<p>最后，GC 将黑色节点再次重置为白色，供下一次垃圾回收使用。</p>
<p></p>
</li>
</ol>
<p>除了三色标记的主过程外，还需要<strong>写屏障</strong>（Write Barrier）的配合。由于三色标记是可并发执行的，运行过程中就可能出现新分配的对象，对于这些对象如何处理就需要写屏障参与。写屏障类似于写锁，主要用于保证并发的一致性。写屏障在标记开始时打开，在标记结束后关闭。（<strong>需要进一步理解</strong>）</p>
<p>另外一个概念是 <strong>STW</strong>（Stop the world），这是标记阶段产生的一种行为，意思是停止所有的 Goroutine。</p>
<h3 id="33-其它">3.3 其它</h3>
<p>有 GC 不意味着高枕无忧，也可能发生内存泄漏，所以要养成一些良好的习惯，比如不使用的指针置为 Nil。</p>
<p>runtime包有两个关于垃圾回收的 API</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">runtime</span><span class="p">.</span><span class="nx">GC</span><span class="err">：</span><span class="nx">手动触发</span> <span class="nx">GC</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nx">ReadMemStats</span><span class="err">：</span><span class="nx">读取内存相关的统计信息</span><span class="err">，</span><span class="nx">其中包含部分</span> <span class="nx">GC</span> <span class="nx">相关的统计信息</span>
</code></pre></td></tr></table>
</div>
</div><p>自动垃圾回收触发的条件有两个：</p>
<ol>
<li>超过内存大小阈值</li>
<li>达到定时时间（默认2min触发一次）</li>
</ol>
<p>如果想知道当前的内存状态，可以使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// fmt.Printf(&#34;%d\n&#34;, runtime.MemStats.Alloc/1024)
</span><span class="c1">// 此处代码在 Go 1.5.1下不再有效，更正为
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">m</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d Kb\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Alloc</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的程序会给出已分配内存的总量，单位是 Kb。进一步的测量参考 <a href="https://golang.google.cn/pkg/runtime/" target="_blank" rel="noopener noreffer">package runtime</a></p>
<p>垃圾回收参考：</p>
<p>[1] 简书，<a href="https://www.jianshu.com/p/4ca9d583d242" target="_blank" rel="noopener noreffer">Go垃圾回收之三色标记算法</a></p>
<p>[2] 博客园，<a href="https://www.cnblogs.com/CodeWithTxT/p/11366643.html" target="_blank" rel="noopener noreffer">搞懂Go垃圾回收</a></p>
<p>[3] 知乎专栏，张三毛，<a href="https://zhuanlan.zhihu.com/p/101132283" target="_blank" rel="noopener noreffer">Go垃圾回收系列</a></p>]]></description></item><item><title>Golang深入学习6-使用pprof进行性能分析</title><link>https://shuzang.github.io/golang-deep-learning-6-performance-analysis-pprof/</link><pubDate>Mon, 27 Jul 2020 18:46:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-6-performance-analysis-pprof/</guid><description><![CDATA[<p>pprof 用来做 Go 程序的性能监控，让我们知道在什么地方耗费了多少 CPU、memory。</p>
<p>pprof 关注的方面有：</p>
<ul>
<li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li>
<li>Memory Profile（Heap Profile）：报告程序的内存使用情况</li>
<li>Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈</li>
<li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li>
</ul>
<h2 id="1-引入">1. 引入</h2>
<p>pprof 可以从以下两个包中引入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;net/http/pprof&#34;</span>
<span class="kn">import</span> <span class="s">&#34;runtime/pprof&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 net/http/pprof 底层使用 runtime/pprof 包，只是进行了一下封装，并在 http 端口上暴露出来。</p>
<p>如果我们的服务是一直运行的，如 web 应用，通过简单的导入  <code>import _ &quot;net/http/pprof&quot;</code>，就可以在运行 web 应用后在浏览器 http://localhost:port/debug/pprof 直接看到当前 web 服务的状态，包括 CPU 占用情况和内存使用情况等。</p>
<p>如果我们的程序不是 web 应用，而是一个服务进程，那么可以导入 <code>net/http/pprof</code> 包，然后主动开启一个 Goroutine 在端口进行监听</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:6060&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们的程序只是简单的 Go 程序，那么只能使用 <code>runtime/pprof</code> 包，具体做法是在代码中加入下面这段程序，然后在运行时（go run 或 go build等命令）加入 &ndash;cpuprofile 参数，比如 <code>go run demo.go --cpuprofile=demo.prof</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">cpuprofile</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;cpuprofile&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;write cpu profile to file&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
    <span class="k">if</span> <span class="o">*</span><span class="nx">cpuprofile</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">*</span><span class="nx">cpuprofile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">pprof</span><span class="p">.</span><span class="nf">StartCPUProfile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
        <span class="k">defer</span> <span class="nx">pprof</span><span class="p">.</span><span class="nf">StopCPUProfile</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>命令执行完后当前目录会生成 demo.prof 文件，其中记录了 CPU 运行的信息，下一步就可以利用该文件查看相关的信息，使用 go tool pprof 命令来执行，如果要进行可视化，需要安装 <a href="http://www.graphviz.org/" target="_blank" rel="noopener noreffer">graphviz</a></p>
<p>win10 下可以使用 chocolatye 或 winget 安装，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="p">&gt;</span> <span class="n">choco</span> <span class="n">install</span> <span class="n">graphviz</span>
<span class="c"># 或</span>
<span class="p">&gt;</span> <span class="n">winget</span> <span class="n">install</span> <span class="n">graphviz</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-分析普通程序">2. 分析普通程序</h2>
<p>主要参考的文章是 Go Post 中的 <a href="https://blog.go-zh.org/profiling-go-programs" target="_blank" rel="noopener noreffer">Profiling Go Programs</a></p>
<p>测试代码来自于 <a href="https://github.com/rsc/benchgraffiti/tree/master/havlak">https://github.com/rsc/benchgraffiti/tree/master/havlak</a></p>
<p>我们使用 go mod 建立了一个测试项目文件夹，第一次使用测试代码中的 havlak1.go 文件，将该文件复制到测试项目根目录。由于其中已经引入了 <code>runtime/pprof</code> 包并包含了如下代码，我们不需要做修改，执行执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">cpuprofile</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;cpuprofile&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;write cpu profile to file&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
    <span class="k">if</span> <span class="o">*</span><span class="nx">cpuprofile</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">*</span><span class="nx">cpuprofile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">pprof</span><span class="p">.</span><span class="nf">StartCPUProfile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
        <span class="k">defer</span> <span class="nx">pprof</span><span class="p">.</span><span class="nf">StopCPUProfile</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>执行时加入 &ndash;cpuprofile=havlak1.prof 参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go build havlak1.go

$ ./havlak1 --cpuprofile<span class="o">=</span>havlak1.prof
<span class="c1"># of loops: 76000 (including 1 artificial root node)</span>

$ ls
go.mod  havlak1.exe  havlak1.go  havlak1.prof
</code></pre></td></tr></table>
</div>
</div><p>然后运行 <code>go tool pprof</code> 命令与 profile 交互</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool pprof havlak1.exe havlak1.prof
File: havlak1.exe
Type: cpu
Time: Jul 25, <span class="m">2020</span> at 7:23pm <span class="o">(</span>CST<span class="o">)</span>
Duration: 21.52s, Total <span class="nv">samples</span> <span class="o">=</span> 34.77s <span class="o">(</span>161.56%<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>最主要的命令是 <code>topN</code> ，用来输出最耗 CPU 的前N个调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="p">(</span><span class="nx">pprof</span><span class="p">)</span> <span class="nx">top10</span>
<span class="nx">Showing</span> <span class="nx">nodes</span> <span class="nx">accounting</span> <span class="k">for</span> <span class="mi">21340</span><span class="nx">ms</span><span class="p">,</span> <span class="mf">61.37</span><span class="o">%</span> <span class="nx">of</span> <span class="mi">34770</span><span class="nx">ms</span> <span class="nx">total</span>
<span class="nx">Dropped</span> <span class="mi">168</span> <span class="nf">nodes</span> <span class="p">(</span><span class="nx">cum</span> <span class="o">&lt;=</span> <span class="mf">173.85</span><span class="nx">ms</span><span class="p">)</span>
<span class="nx">Showing</span> <span class="nx">top</span> <span class="mi">10</span> <span class="nx">nodes</span> <span class="nx">out</span> <span class="nx">of</span> <span class="mi">89</span>
      <span class="nx">flat</span>  <span class="nx">flat</span><span class="o">%</span>   <span class="nx">sum</span><span class="o">%</span>        <span class="nx">cum</span>   <span class="nx">cum</span><span class="o">%</span>
    <span class="mi">5340</span><span class="nx">ms</span> <span class="mf">15.36</span><span class="o">%</span> <span class="mf">15.36</span><span class="o">%</span>    <span class="mi">12320</span><span class="nx">ms</span> <span class="mf">35.43</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">scanobject</span>
    <span class="mi">3190</span><span class="nx">ms</span>  <span class="mf">9.17</span><span class="o">%</span> <span class="mf">24.53</span><span class="o">%</span>     <span class="mi">3650</span><span class="nx">ms</span> <span class="mf">10.50</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">mapaccess1_fast64</span>
    <span class="mi">2650</span><span class="nx">ms</span>  <span class="mf">7.62</span><span class="o">%</span> <span class="mf">32.15</span><span class="o">%</span>    <span class="mi">16670</span><span class="nx">ms</span> <span class="mf">47.94</span><span class="o">%</span>  <span class="nx">main</span><span class="p">.</span><span class="nx">FindLoops</span>
    <span class="mi">2240</span><span class="nx">ms</span>  <span class="mf">6.44</span><span class="o">%</span> <span class="mf">38.60</span><span class="o">%</span>     <span class="mi">3320</span><span class="nx">ms</span>  <span class="mf">9.55</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">findObject</span>
    <span class="mi">1800</span><span class="nx">ms</span>  <span class="mf">5.18</span><span class="o">%</span> <span class="mf">43.77</span><span class="o">%</span>     <span class="mi">2920</span><span class="nx">ms</span>  <span class="mf">8.40</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">greyobject</span>
    <span class="mi">1490</span><span class="nx">ms</span>  <span class="mf">4.29</span><span class="o">%</span> <span class="mf">48.06</span><span class="o">%</span>     <span class="mi">6540</span><span class="nx">ms</span> <span class="mf">18.81</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">mallocgc</span>
    <span class="mi">1480</span><span class="nx">ms</span>  <span class="mf">4.26</span><span class="o">%</span> <span class="mf">52.32</span><span class="o">%</span>     <span class="mi">4230</span><span class="nx">ms</span> <span class="mf">12.17</span><span class="o">%</span>  <span class="nx">main</span><span class="p">.</span><span class="nx">DFS</span>
    <span class="mi">1230</span><span class="nx">ms</span>  <span class="mf">3.54</span><span class="o">%</span> <span class="mf">55.85</span><span class="o">%</span>     <span class="mi">3510</span><span class="nx">ms</span> <span class="mf">10.09</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">mapassign_fast64ptr</span>
    <span class="mi">1000</span><span class="nx">ms</span>  <span class="mf">2.88</span><span class="o">%</span> <span class="mf">58.73</span><span class="o">%</span>     <span class="mi">1450</span><span class="nx">ms</span>  <span class="mf">4.17</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">heapBitsSetType</span>
     <span class="mi">920</span><span class="nx">ms</span>  <span class="mf">2.65</span><span class="o">%</span> <span class="mf">61.37</span><span class="o">%</span>     <span class="mi">1050</span><span class="nx">ms</span>  <span class="mf">3.02</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nf">spanOf</span> <span class="p">(</span><span class="nx">inline</span><span class="p">)</span>
<span class="p">(</span><span class="nx">pprof</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>flat、flat% 表示函数在 CPU上运行的时间及百分比</li>
<li>sum% 表示列表中自己包括前面的函数CPU使用比例的累积，比如第三行 main.FindLoops 显示的 32.15% 其实就等于前面三个调用的比例之和 15.36% + 9.17% + 7.62% = 32.15%</li>
<li>cum、cum% 表示该函数及其子函数运行所占的时间总和及比例总和，应该大于等于自己执行所占的时间和比例，也就是最前面两列</li>
</ul>
<p>添加 -cum 参数可以按照 cum 来排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="p">(</span><span class="nx">pprof</span><span class="p">)</span> <span class="nx">top5</span> <span class="o">-</span><span class="nx">cum</span>
<span class="nx">Showing</span> <span class="nx">nodes</span> <span class="nx">accounting</span> <span class="k">for</span> <span class="mf">2.67</span><span class="nx">s</span><span class="p">,</span> <span class="mf">7.68</span><span class="o">%</span> <span class="nx">of</span> <span class="mf">34.77</span><span class="nx">s</span> <span class="nx">total</span>
<span class="nx">Dropped</span> <span class="mi">168</span> <span class="nf">nodes</span> <span class="p">(</span><span class="nx">cum</span> <span class="o">&lt;=</span> <span class="mf">0.17</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">Showing</span> <span class="nx">top</span> <span class="mi">5</span> <span class="nx">nodes</span> <span class="nx">out</span> <span class="nx">of</span> <span class="mi">89</span>
      <span class="nx">flat</span>  <span class="nx">flat</span><span class="o">%</span>   <span class="nx">sum</span><span class="o">%</span>        <span class="nx">cum</span>   <span class="nx">cum</span><span class="o">%</span>
         <span class="mi">0</span>     <span class="mi">0</span><span class="o">%</span>     <span class="mi">0</span><span class="o">%</span>     <span class="mf">16.79</span><span class="nx">s</span> <span class="mf">48.29</span><span class="o">%</span>  <span class="nx">main</span><span class="p">.</span><span class="nx">main</span>
         <span class="mi">0</span>     <span class="mi">0</span><span class="o">%</span>     <span class="mi">0</span><span class="o">%</span>     <span class="mf">16.79</span><span class="nx">s</span> <span class="mf">48.29</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nx">main</span>
         <span class="mi">0</span>     <span class="mi">0</span><span class="o">%</span>     <span class="mi">0</span><span class="o">%</span>     <span class="mf">16.67</span><span class="nx">s</span> <span class="mf">47.94</span><span class="o">%</span>  <span class="nx">main</span><span class="p">.</span><span class="nf">FindHavlakLoops</span> <span class="p">(</span><span class="nx">inline</span><span class="p">)</span>
     <span class="mf">2.65</span><span class="nx">s</span>  <span class="mf">7.62</span><span class="o">%</span>  <span class="mf">7.62</span><span class="o">%</span>     <span class="mf">16.67</span><span class="nx">s</span> <span class="mf">47.94</span><span class="o">%</span>  <span class="nx">main</span><span class="p">.</span><span class="nx">FindLoops</span>
     <span class="mf">0.02</span><span class="nx">s</span> <span class="mf">0.058</span><span class="o">%</span>  <span class="mf">7.68</span><span class="o">%</span>     <span class="mf">15.16</span><span class="nx">s</span> <span class="mf">43.60</span><span class="o">%</span>  <span class="nx">runtime</span><span class="p">.</span><span class="nf">systemstack</span>
<span class="p">(</span><span class="nx">pprof</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上 main.FindLoops 和 main.main 的总和应当为 100%，但是 pprof 不会统计所有的调用，递归调用层次过深的一些执行会被忽略。</p>
<p>另外，使用 <code>web</code> 命令可以生成调用关系图，是一个 svg 文件，可视化的方式可以帮助我们更好的理解，该命令需要 graphviz 工具的支持，这也是为什么前面要安装它</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>pprof<span class="o">)</span> web
</code></pre></td></tr></table>
</div>
</div><p>执行该命令后图片会自动打开</p>
<p></p>
<p>图片中每个方框都代表一个函数，方框的大小根据 CPU 占用比例确定，箭头表示调用关系，从上到下调用层次逐渐加深，表示调用的线条上出现的数字表示调用次数，递归调用自身会有一个自己指向自己的箭头。</p>
<p>从图中看到 mapaccess 占用比例较大，我们可以只显示与它相关的调用，从而使图片逻辑更清晰。可以看到 mapaccess1 主要由 main.FindLoops 和 main.DFS 调用。</p>
<p></p>
<p>我们还可以通过指定函数进入某个函数的细节，DFS逻辑比较简单，以它为例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>pprof<span class="o">)</span> web DFS
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>也可以使用命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>pprof<span class="o">)</span> list DFS
Total: 34.77s
<span class="nv">ROUTINE</span> <span class="o">========================</span> main.DFS in F:<span class="se">\G</span>o-web<span class="se">\h</span>avlak1.go
     1.48s      8.38s <span class="o">(</span>flat, cum<span class="o">)</span> 24.10% of Total
         .          .    233:   <span class="k">return</span> <span class="nb">false</span>
         .          .    234:<span class="o">}</span>
         .          .    235:
         .          .    236:// DFS - Depth-First-Search and node numbering.
         .          .    237://
      30ms       30ms    238:func DFS<span class="o">(</span>currentNode *BasicBlock, nodes <span class="o">[]</span>*UnionFindNode, number map<span class="o">[</span>*BasicBlock<span class="o">]</span>int, last <span class="o">[]</span>int, current int<span class="o">)</span> int <span class="o">{</span>
      20ms      240ms    239:   nodes<span class="o">[</span>current<span class="o">]</span>.Init<span class="o">(</span>currentNode, current<span class="o">)</span>
      20ms      340ms    240:   number<span class="o">[</span>currentNode<span class="o">]</span> <span class="o">=</span> current
         .          .    241:
         .          .    242:   lastid :<span class="o">=</span> current
     1.02s      1.02s    243:   <span class="k">for</span> _, target :<span class="o">=</span> range currentNode.OutEdges <span class="o">{</span>
     190ms      1.73s    244:           <span class="k">if</span> number<span class="o">[</span>target<span class="o">]</span> <span class="o">==</span> unvisited <span class="o">{</span>
      80ms      4.23s    245:                   <span class="nv">lastid</span> <span class="o">=</span> DFS<span class="o">(</span>target, nodes, number, last, lastid+1<span class="o">)</span>
         .          .    246:           <span class="o">}</span>
         .          .    247:   <span class="o">}</span>
      80ms      750ms    248:   last<span class="o">[</span>number<span class="o">[</span>currentNode<span class="o">]]</span> <span class="o">=</span> lastid
      40ms       40ms    249:   <span class="k">return</span> lastid
         .          .    250:<span class="o">}</span>
         .          .    251:
         .          .    252:// FindLoops
         .          .    253://
         .          .    254:// Find loops and build loop forest using Havlak<span class="err">&#39;</span>s algorithm, which
<span class="o">(</span>pprof<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>前两列分别是 flat 和 cum，也就是该行执行占用的时间和该行及该行调用的函数执行占用的总时间，第三列是源码行数。所以我们看到第 245 行由于出现了 DFS 这个递归函数，总占用时间为 4.23s，是最多的。除了该行之外，占用最多的就是第239、240、248三行，主要原因是映射的使用占用了大量时间，所以我们在使用中应尽可能使用数组和切片，而减少使用映射。</p>
<h2 id="2-时间与存储优化">2. 时间与存储优化</h2>
<p>将 DFS 函数参数中的 number 由映射更改为切片，可以将运行时间减少两倍，我们使用测试文件列表中的 havlak2.go，执行同样的测试过程可以验证这一点，原先的 DFS cum 是 4230ms，现在已经只有 830ms。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go build havlak2.go

$ ./havlak2 --cpuprofile<span class="o">=</span>havlak2.prof
<span class="c1"># of loops: 76000 (including 1 artificial root node)</span>

$ go tool pprof havlak2.exe havlak2.prof
File: havlak2.exe
Type: cpu
Time: Jul 25, <span class="m">2020</span> at 8:51pm <span class="o">(</span>CST<span class="o">)</span>
Duration: 12.36s, Total <span class="nv">samples</span> <span class="o">=</span> 22.91s <span class="o">(</span>185.34%<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span> top10
Showing nodes accounting <span class="k">for</span> 14360ms, 62.68% of 22910ms total
Dropped <span class="m">132</span> nodes <span class="o">(</span>cum &lt;<span class="o">=</span> 114.55ms<span class="o">)</span>
Showing top <span class="m">10</span> nodes out of <span class="m">85</span>
      flat  flat%   sum%        cum   cum%
    4130ms 18.03% 18.03%     9810ms 42.82%  runtime.scanobject
    1850ms  8.08% 26.10%     2570ms 11.22%  runtime.findObject
    1800ms  7.86% 33.96%    11070ms 48.32%  main.FindLoops
    1530ms  6.68% 40.64%     2510ms 10.96%  runtime.greyobject
    1450ms  6.33% 46.97%     5940ms 25.93%  runtime.mallocgc
     950ms  4.15% 51.11%     1290ms  5.63%  runtime.heapBitsSetType
     680ms  2.97% 54.08%      830ms  3.62%  main.DFS
     670ms  2.92% 57.01%      670ms  2.92%  runtime.memclrNoHeapPointers
     670ms  2.92% 59.93%      670ms  2.92%  runtime.nextFreeFast
     630ms  2.75% 62.68%      630ms  2.75%  runtime.arenaIndex <span class="o">(</span>partial-inline<span class="o">)</span> 
</code></pre></td></tr></table>
</div>
</div><p>附： <a href="https://github.com/rsc/benchgraffiti/commit/58ac27bcac3ffb553c29d0b3fb64745c91c95948" target="_blank" rel="noopener noreffer">diff between havlak1 and havlak2</a></p>
<p>现在，DFS 不再是时间瓶颈，取而代之的是内存分配与垃圾回收，上面的结果中 runtime.mallocgc 占了一大部分。为了找出为什么垃圾回收时间占用这么多，我们来分析内存占用，这时候使用 memprofile ，不再是 cpuprofile。首先在主函数中替换如下部分</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">memprofile</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;memprofile&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;write memory profile to this file&#34;</span><span class="p">)</span>
<span class="o">...</span>

    <span class="nf">FindHavlakLoops</span><span class="p">(</span><span class="nx">cfgraph</span><span class="p">,</span> <span class="nx">lsgraph</span><span class="p">)</span>
    <span class="k">if</span> <span class="o">*</span><span class="nx">memprofile</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">*</span><span class="nx">memprofile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">pprof</span><span class="p">.</span><span class="nf">WriteHeapProfile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
        <span class="k">return</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后使用 &ndash;memprofile 标志编译源码，此时使用测试文件列表中的 havlak3</p>
<p>附：<a href="https://github.com/rsc/benchgraffiti/commit/b78dac106bea1eb3be6bb3ca5dba57c130268232" target="_blank" rel="noopener noreffer">diff from havlak2</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go build havlak3.go

$ ./havlak3 --memprofile<span class="o">=</span>havlak3.mprof

$ go tool pprof havlak3.exe havlak3.mprof
$ go tool pprof havlak3.exe havlak3.mprof
File: havlak3.exe
Type: inuse_space
Time: Jul 25, <span class="m">2020</span> at 9:07pm <span class="o">(</span>CST<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span> top5
Showing nodes accounting <span class="k">for</span> 53.39MB, 100% of 53.39MB total
Showing top <span class="m">5</span> nodes out of <span class="m">13</span>
      flat  flat%   sum%        cum   cum%
   33.10MB 62.00% 62.00%    33.10MB 62.00%  main.FindLoops
   11.50MB 21.54% 83.54%    11.50MB 21.54%  main.NewBasicBlock <span class="o">(</span>inline<span class="o">)</span>
    4.50MB  8.43% 91.96%     4.50MB  8.43%  main.<span class="o">(</span>*BasicBlock<span class="o">)</span>.AddInEdge
    2.29MB  4.29% 96.25%    13.79MB 25.83%  main.<span class="o">(</span>*CFG<span class="o">)</span>.CreateNode
       2MB  3.75%   100%        2MB  3.75%  main.<span class="o">(</span>*BasicBlock<span class="o">)</span>.AddOutEdge
<span class="o">(</span>pprof<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>flat 和 cum 已经从时间占用变成了存储占用，可以看到 main.FindLoops 占用最多，达到了 62.00%，使用 <code>list</code> 命令查看具体情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>pprof<span class="o">)</span> list FindLoops
Total: 53.39MB
<span class="nv">ROUTINE</span> <span class="o">========================</span> main.FindLoops in F:<span class="se">\G</span>o-web<span class="se">\h</span>avlak3.go
   33.10MB    33.10MB <span class="o">(</span>flat, cum<span class="o">)</span> 62.00% of Total
         .          .    261:           <span class="k">return</span>
         .          .    262:   <span class="o">}</span>
         .          .    263:
         .          .    264:   size :<span class="o">=</span> cfgraph.NumNodes<span class="o">()</span>
         .          .    265:
    1.97MB     1.97MB    266:   nonBackPreds :<span class="o">=</span> make<span class="o">([]</span>map<span class="o">[</span>int<span class="o">]</span>bool, size<span class="o">)</span>
    5.77MB     5.77MB    267:   backPreds :<span class="o">=</span> make<span class="o">([][]</span>int, size<span class="o">)</span>
         .          .    268:
    1.97MB     1.97MB    269:   number :<span class="o">=</span> make<span class="o">([]</span>int, size<span class="o">)</span>
    1.97MB     1.97MB    270:   header :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
    1.97MB     1.97MB    271:   types :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
    1.97MB     1.97MB    272:   last :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
    1.97MB     1.97MB    273:   nodes :<span class="o">=</span> make<span class="o">([]</span>*UnionFindNode, size, size<span class="o">)</span>        
         .          .    274:
         .          .    275:   <span class="k">for</span> i :<span class="o">=</span> 0<span class="p">;</span> i &lt; size<span class="p">;</span> i++ <span class="o">{</span>
      11MB       11MB    276:           nodes<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> new<span class="o">(</span>UnionFindNode<span class="o">)</span>
         .          .    277:   <span class="o">}</span>
         .          .    278:
         .          .    279:   // Step a:
         .          .    280:   //   - initialize all nodes as unvisited.
         .          .    281:   //   - depth-first traversal and numbering.        
         .          .    282:   //   - unreached BB<span class="err">&#39;</span>s are marked as dead.
         .          .    283:   //
         .          .    284:   <span class="k">for</span> i, bb :<span class="o">=</span> range cfgraph.Blocks <span class="o">{</span>
         .          .    285:           number<span class="o">[</span>bb.Name<span class="o">]</span> <span class="o">=</span> unvisited
    4.50MB     4.50MB    286:           nonBackPreds<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> make<span class="o">(</span>map<span class="o">[</span>int<span class="o">]</span>bool<span class="o">)</span>       
         .          .    287:   <span class="o">}</span>
         .          .    288:
         .          .    289:   DFS<span class="o">(</span>cfgraph.Start, nodes, number, last, 0<span class="o">)</span>
         .          .    290:
         .          .    291:   // Step b:
<span class="o">(</span>pprof<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>瓶颈依然在于 UnionFindNode 结构体的初始化和映射。</p>
<p>另外，如果我们执行 <code>go tool pprof</code> 加入 <code>--inuse_objects</code> ，看到的不是内存使用而是调用计数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool pprof --inuse_objects havlak3.exe havlak3.mprof
File: havlak3.exe
Type: inuse_objects
Time: Jul 25, <span class="m">2020</span> at 9:07pm <span class="o">(</span>CST<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span> list FindLoops
Total: <span class="m">1171490</span>
<span class="nv">ROUTINE</span> <span class="o">========================</span> main.FindLoops in F:<span class="se">\G</span>o-web<span class="se">\h</span>avlak3.go
    <span class="m">458774</span>     <span class="m">458774</span> <span class="o">(</span>flat, cum<span class="o">)</span> 39.16% of Total
         .          .    261:           <span class="k">return</span>
         .          .    262:   <span class="o">}</span>
         .          .    263:
         .          .    264:   size :<span class="o">=</span> cfgraph.NumNodes<span class="o">()</span>
         .          .    265:
         <span class="m">1</span>          <span class="m">1</span>    266:   nonBackPreds :<span class="o">=</span> make<span class="o">([]</span>map<span class="o">[</span>int<span class="o">]</span>bool, size<span class="o">)</span>
         <span class="m">1</span>          <span class="m">1</span>    267:   backPreds :<span class="o">=</span> make<span class="o">([][]</span>int, size<span class="o">)</span>
         .          .    268:
         <span class="m">1</span>          <span class="m">1</span>    269:   number :<span class="o">=</span> make<span class="o">([]</span>int, size<span class="o">)</span>
         <span class="m">1</span>          <span class="m">1</span>    270:   header :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
         <span class="m">1</span>          <span class="m">1</span>    271:   types :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
         <span class="m">1</span>          <span class="m">1</span>    272:   last :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
         <span class="m">1</span>          <span class="m">1</span>    273:   nodes :<span class="o">=</span> make<span class="o">([]</span>*UnionFindNode, size, size<span class="o">)</span>
         .          .    274:
         .          .    275:   <span class="k">for</span> i :<span class="o">=</span> 0<span class="p">;</span> i &lt; size<span class="p">;</span> i++ <span class="o">{</span>
    <span class="m">360459</span>     <span class="m">360459</span>    276:           nodes<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> new<span class="o">(</span>UnionFindNode<span class="o">)</span>
         .          .    277:   <span class="o">}</span>
         .          .    278:
         .          .    279:   // Step a:
         .          .    280:   //   - initialize all nodes as unvisited.
         .          .    281:   //   - depth-first traversal and numbering.
         .          .    282:   //   - unreached BB<span class="err">&#39;</span>s are marked as dead.
         .          .    283:   //
         .          .    284:   <span class="k">for</span> i, bb :<span class="o">=</span> range cfgraph.Blocks <span class="o">{</span>
         .          .    285:           number<span class="o">[</span>bb.Name<span class="o">]</span> <span class="o">=</span> unvisited
     <span class="m">98308</span>      <span class="m">98308</span>    286:           nonBackPreds<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> make<span class="o">(</span>map<span class="o">[</span>int<span class="o">]</span>bool<span class="o">)</span>
         .          .    287:   <span class="o">}</span>
         .          .    288:
         .          .    289:   DFS<span class="o">(</span>cfgraph.Start, nodes, number, last, 0<span class="o">)</span>
         .          .    290:
         .          .    291:   // Step b:
<span class="o">(</span>pprof<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里依然是解决映射使用带来的影响，主要方式是将映射换成切片，这里使用测试文件列表中的 havlak4，可以看到总耗时又少了一点点。</p>
<p>附：<a href="https://github.com/rsc/benchgraffiti/commit/245d899f7b1a33b0c8148a4cd147cb3de5228c8a" target="_blank" rel="noopener noreffer">diff from havlak3</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go build havlak4.go

$ ./havlak4 --cpuprofile<span class="o">=</span>havlak4.prof
<span class="c1"># of loops: 76000 (including 1 artificial root node)</span>

$ go tool pprof havlak4.exe havlak4.prof
File: havlak4.exe
Type: cpu
Time: Jul 25, <span class="m">2020</span> at 9:25pm <span class="o">(</span>CST<span class="o">)</span>
Duration: 7.35s, Total <span class="nv">samples</span> <span class="o">=</span> 13.03s <span class="o">(</span>177.21%<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span> top10
Showing nodes accounting <span class="k">for</span> 8930ms, 68.53% of 13030ms total
Dropped <span class="m">104</span> nodes <span class="o">(</span>cum &lt;<span class="o">=</span> 65.15ms<span class="o">)</span>
Showing top <span class="m">10</span> nodes out of <span class="m">84</span>
      flat  flat%   sum%        cum   cum%
    2660ms 20.41% 20.41%     6190ms 47.51%  runtime.scanobject
    1450ms 11.13% 31.54%     5860ms 44.97%  main.FindLoops
    1110ms  8.52% 40.06%     1590ms 12.20%  runtime.findObject
     900ms  6.91% 46.97%     1580ms 12.13%  runtime.greyobject
     810ms  6.22% 53.18%     3300ms 25.33%  runtime.mallocgc
     620ms  4.76% 57.94%      820ms  6.29%  main.DFS
     390ms  2.99% 60.94%      500ms  3.84%  runtime.heapBitsSetType
     380ms  2.92% 63.85%      510ms  3.91%  runtime.spanOf <span class="o">(</span>inline<span class="o">)</span>
     310ms  2.38% 66.23%      310ms  2.38%  runtime.arenaIndex <span class="o">(</span>partial-inline<span class="o">)</span>    
     300ms  2.30% 68.53%      300ms  2.30%  runtime.memclrNoHeapPointers
<span class="o">(</span>pprof<span class="o">)</span> 
</code></pre></td></tr></table>
</div>
</div><p>现在，垃圾回收（runtime.mallocgc）占用 53.18%，我们来查看对它的调用</p>
<p></p>
<p>因为时间占比比较小的调用很多，看不出什么，我们可以在 <code>go tool pprof</code> 中添加 <code>--nodefraction=0.1</code> 参数过滤占用低于 10% 的调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go tool pprof --nodefraction<span class="o">=</span>0.1 havlak4.exe havlak4.prof
File: havlak4.exe
Type: cpu
Time: Jul 25, <span class="m">2020</span> at 9:25pm <span class="o">(</span>CST<span class="o">)</span>
Duration: 7.35s, Total <span class="nv">samples</span> <span class="o">=</span> 13.03s <span class="o">(</span>177.21%<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span> web mallocgc
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>这就非常清楚了，FindLoops 是最主要的占用，然后我们查看它</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>pprof<span class="o">)</span> list FindLoops
Total: 13.03s
<span class="nv">ROUTINE</span> <span class="o">========================</span> main.FindLoops in F:<span class="se">\G</span>o-web<span class="se">\h</span>avlak4.go
     1.45s      5.86s <span class="o">(</span>flat, cum<span class="o">)</span> 44.97% of Total
         .          .    270:           <span class="k">return</span>
         .          .    271:   <span class="o">}</span>
         .          .    272:
         .          .    273:   size :<span class="o">=</span> cfgraph.NumNodes<span class="o">()</span>
         .          .    274:
         .       90ms    275:   nonBackPreds :<span class="o">=</span> make<span class="o">([][]</span>int, size<span class="o">)</span>
         .      210ms    276:   backPreds :<span class="o">=</span> make<span class="o">([][]</span>int, size<span class="o">)</span>
         .          .    277:
         .      250ms    278:   number :<span class="o">=</span> make<span class="o">([]</span>int, size<span class="o">)</span>
         .      140ms    279:   header :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
         .       80ms    280:   types :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
         .       60ms    281:   last :<span class="o">=</span> make<span class="o">([]</span>int, size, size<span class="o">)</span>
         .       70ms    282:   nodes :<span class="o">=</span> make<span class="o">([]</span>*UnionFindNode, size, size<span class="o">)</span>        
         .          .    283:
         .          .    284:   <span class="k">for</span> i :<span class="o">=</span> 0<span class="p">;</span> i &lt; size<span class="p">;</span> i++ <span class="o">{</span>
      10ms      590ms    285:           nodes<span class="o">[</span>i<span class="o">]</span> <span class="o">=</span> new<span class="o">(</span>UnionFindNode<span class="o">)</span>
         .          .    286:   <span class="o">}</span>
         .          .    287:
...
</code></pre></td></tr></table>
</div>
</div><p>每次 FindLoops 被调用，都会进行一系列的初始化工作，为了处理这些内存分配，垃圾回收器的占用才会那么高。所以我们要意识到，语言自带垃圾回收不意味着不需要再关心内存分配问题，这里解决该问题的方法是使用缓存，以便每次不需要重新分配和回收内存。</p>
<p>添加一个全局的结构 cache</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">cache</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">size</span> <span class="kt">int</span>
    <span class="nx">nonBackPreds</span> <span class="p">[][]</span><span class="kt">int</span>
    <span class="nx">backPreds</span> <span class="p">[][]</span><span class="kt">int</span>
    <span class="nx">number</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">header</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">types</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">last</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">nodes</span> <span class="p">[]</span><span class="o">*</span><span class="nx">UnionFindNode</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在 FindLoops 中每次访问它而不是重新分配（这种方式并不是一种很好的方式，但是确实能在此程序中提升时间）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">size</span> <span class="p">{</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">size</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">nonBackPreds</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">backPreds</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">number</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">header</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">types</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="nx">cache</span><span class="p">.</span><span class="nx">nodes</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">UnionFindNode</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">nodes</span> <span class="p">{</span>
        <span class="nx">cache</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">UnionFindNode</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">nonBackPreds</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">nonBackPreds</span><span class="p">[:</span><span class="nx">size</span><span class="p">]</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nonBackPreds</span> <span class="p">{</span>
    <span class="nx">nonBackPreds</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nonBackPreds</span><span class="p">[</span><span class="nx">i</span><span class="p">][:</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">backPreds</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">backPreds</span><span class="p">[:</span><span class="nx">size</span><span class="p">]</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nonBackPreds</span> <span class="p">{</span>
    <span class="nx">backPreds</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">backPreds</span><span class="p">[</span><span class="nx">i</span><span class="p">][:</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">number</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">number</span><span class="p">[:</span><span class="nx">size</span><span class="p">]</span>
<span class="nx">header</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">header</span><span class="p">[:</span><span class="nx">size</span><span class="p">]</span>
<span class="nx">types</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">types</span><span class="p">[:</span><span class="nx">size</span><span class="p">]</span>
<span class="nx">last</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">last</span><span class="p">[:</span><span class="nx">size</span><span class="p">]</span>
<span class="nx">nodes</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[:</span><span class="nx">size</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>这一更改实现在了 havlak5 中，我们从测试文件列表中找到该文件并使用，发现时间占用已经减少到了 10s 以下</p>
<p>附：<a href="https://github.com/rsc/benchgraffiti/commit/2d41d6d16286b8146a3f697dd4074deac60d12a4" target="_blank" rel="noopener noreffer">diff from havlak4</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ go build havlak5.go

$ ./havlak5.exe --cpuprofile<span class="o">=</span>havlak5.prof
<span class="c1"># of loops: 76000 (including 1 artificial root node)</span>

$ go tool pprof havlak5.exe havlak5.prof
File: havlak5.exe
Type: cpu
Time: Jul 25, <span class="m">2020</span> at 9:46pm <span class="o">(</span>CST<span class="o">)</span>
Duration: 4.89s, Total <span class="nv">samples</span> <span class="o">=</span> 7.34s <span class="o">(</span>150.01%<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>还有很多的工作可以进行从而使程序更快，但都不需要 pprof 的协助，最终的版本 havlak6 可以减少到 2.29s 和 351M存储占用。</p>
<p>当然，最简单的方式是使用 go test 工具，Go 提供的测试机制可以很容易的提供 CPU 和存储的占用分析。</p>
<h2 id="3-分析网络程序">3. 分析网络程序</h2>
<p>就像我们一开始说的，分析一个网络程序更加的简单，只需要导入 <code>net/http/pprof</code> 包即可，不需要在程序中使用，只需要添加这一条导入语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>导入该包会添加一些 /debug/pprof/ URL 下面的一些处理器函数，之后简单的运行 go tool pprof 然后添加服务器 URL就会实时的检查配置文件。</p>
<p>以我们之前写的一个文件上传下载应用为例，端口使用 8090，添加导入语句后，打开浏览器 http://localhost:8090/debug/pprof/，显示如下</p>
<p></p>
<p>或者在命令行使用 <code>go tool pprof</code> 命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">go tool pprof http://localhost:8090/debug/pprof/profile   <span class="c1"># 30-second CPU profile</span>
go tool pprof http://localhost:8090/debug/pprof/heap      <span class="c1"># heap profile</span>
go tool pprof http://localhost:8090/debug/pprof/block     <span class="c1"># goroutine blocking profile</span>
</code></pre></td></tr></table>
</div>
</div><p>进入 pprof 命令行界面后就和前面的使用没有区别了，这几个文件简单介绍如下</p>
<ul>
<li><code>/debug/pprof/profile</code>：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载</li>
<li><code>/debug/pprof/heap</code>： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</li>
<li><code>/debug/pprof/block</code>：block Profiling 的路径</li>
</ul>
<p>最后，上面的导入形式是基于我们使用默认的 http.DefaultServeMux 的情况，如果使用了其它的包，比如 Mux，需要手动添加路由规则</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/cmdline&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Cmdline</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/profile&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Profile</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/symbol&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Symbol</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/debug/pprof/trace&#34;</span><span class="p">,</span> <span class="nx">pprof</span><span class="p">.</span><span class="nx">Trace</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>之后的使用就没有区别了。</p>]]></description></item><item><title>Golang深入学习5-使用dlv调试程序</title><link>https://shuzang.github.io/golang-deep-learning-5-debug-with-dlv/</link><pubDate>Sun, 26 Jul 2020 09:43:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-5-debug-with-dlv/</guid><description><![CDATA[<p>在C/C++中，使用 GDB 调试程序，但在Go中，看过网上的一些文章后，发现 dlv 是个更好的选择，本文进行介绍。</p>
<p>实际上，<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener noreffer">delve</a> 才是全称，dlv 只是启动命令，如果使用 VScode，默认使用的调试器就是基于 delve 的。</p>
<h2 id="1-基本命令">1. 基本命令</h2>
<p>使用如下命令安装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">get</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="k">go</span><span class="o">-</span><span class="nx">delve</span><span class="o">/</span><span class="nx">delve</span><span class="o">/</span><span class="nx">cmd</span><span class="o">/</span><span class="nx">dlv</span>
</code></pre></td></tr></table>
</div>
</div><p>安装后执行 <code>dlv</code> 命令查看基本信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ dlv
Delve is a <span class="nb">source</span> level debugger <span class="k">for</span> Go programs.

Delve enables you to interact with your program by controlling the execution of the process,
evaluating variables, and providing information of thread / goroutine state, CPU register state and more.

The goal of this tool is to provide a simple yet powerful interface <span class="k">for</span> debugging Go programs.

Pass flags to the program you are debugging using <span class="sb">`</span>--<span class="sb">`</span>, <span class="k">for</span> example:

<span class="sb">`</span>dlv <span class="nb">exec</span> ./hello -- server --config conf/config.toml<span class="sb">`</span>

Usage:
  dlv <span class="o">[</span>command<span class="o">]</span>

Available Commands:
  attach      Attach to running process and begin debugging.
  connect     Connect to a headless debug server.
  core        Examine a core dump.
  debug       Compile and begin debugging main package in current directory, or the package specified.
  <span class="nb">exec</span>        Execute a precompiled binary, and begin a debug session.
  <span class="nb">help</span>        Help about any <span class="nb">command</span>
  run         Deprecated command. Use <span class="s1">&#39;debug&#39;</span> instead.
  <span class="nb">test</span>        Compile <span class="nb">test</span> binary and begin debugging program.
  trace       Compile and begin tracing program.
  version     Prints version.

Flags:
      --accept-multiclient   Allows a headless server to accept multiple client connections.
      --api-version int      Selects API version when headless. <span class="o">(</span>default 1<span class="o">)</span>
      --backend string       Backend selection <span class="o">(</span>see <span class="s1">&#39;dlv help backend&#39;</span><span class="o">)</span>. <span class="o">(</span>default <span class="s2">&#34;default&#34;</span><span class="o">)</span>
      --build-flags string   Build flags, to be passed to the compiler.
      --check-go-version     Checks that the version of Go in use is compatible with Delve. <span class="o">(</span>default <span class="nb">true</span><span class="o">)</span>
      --headless             Run debug server only, in headless mode.
      --init string          Init file, executed by the terminal client.
  -l, --listen string        Debugging server listen address. <span class="o">(</span>default <span class="s2">&#34;127.0.0.1:0&#34;</span><span class="o">)</span>
      --log                  Enable debugging server logging.
      --log-dest string      Writes logs to the specified file or file descriptor <span class="o">(</span>see <span class="s1">&#39;dlv help log&#39;</span><span class="o">)</span>.
      --log-output string    Comma separated list of components that should produce debug output <span class="o">(</span>see <span class="s1">&#39;dlv help log&#39;</span><span class="o">)</span>
      --only-same-user       Only connections from the same user that started this instance of Delve are allowed to connect. <span class="o">(</span>default <span class="nb">true</span><span class="o">)</span>
      --wd string            Working directory <span class="k">for</span> running the program. <span class="o">(</span>default <span class="s2">&#34;.&#34;</span><span class="o">)</span>

Additional <span class="nb">help</span> topics:
  dlv backend Help about the --backend flag.
  dlv log     Help about logging flags.

Use <span class="s2">&#34;dlv [command] --help&#34;</span> <span class="k">for</span> more information about a command.
</code></pre></td></tr></table>
</div>
</div><p>进入调试模式有以下几种办法</p>
<ol>
<li>dlv attach pid：对正在运行的进程直接进行调试（pid 为进程id）；</li>
<li>dlv debug：编译源文件并开始调试，这里应和 main 函数位于同一目录，或者指定完整的 main 函数路径</li>
<li>dlv exec filename：从二进制文件启动调试</li>
</ol>
<p>我们以下面的程序为例进行说明，使用 dlv debug 进入调试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>进入调试，使用 help 可以查看所有可用命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ dlv debug main.go
Type <span class="s1">&#39;help&#39;</span> <span class="k">for</span> list of commands.
<span class="o">(</span>dlv<span class="o">)</span> <span class="nb">help</span>
The following commands are available:
    args ------------------------ Print <span class="k">function</span> arguments.
    <span class="nb">break</span> <span class="o">(</span>alias: b<span class="o">)</span> ------------ Sets a breakpoint.
    breakpoints <span class="o">(</span>alias: bp<span class="o">)</span> ----- Print out info <span class="k">for</span> active breakpoints.
    call ------------------------ Resumes process, injecting a <span class="k">function</span> call <span class="o">(</span>EXPERIMENTAL!!!<span class="o">)</span>
    clear ----------------------- Deletes breakpoint.
    clearall -------------------- Deletes multiple breakpoints.
    condition <span class="o">(</span>alias: cond<span class="o">)</span> ----- Set breakpoint condition.
    config ---------------------- Changes configuration parameters.
    <span class="k">continue</span> <span class="o">(</span>alias: c<span class="o">)</span> --------- Run <span class="k">until</span> breakpoint or program termination.
    deferred -------------------- Executes <span class="nb">command</span> in the context of a deferred call.
    disassemble <span class="o">(</span>alias: disass<span class="o">)</span> - Disassembler.
    down ------------------------ Move the current frame down.
    edit <span class="o">(</span>alias: ed<span class="o">)</span> ------------ Open where you are in <span class="nv">$DELVE_EDITOR</span> or <span class="nv">$EDITOR</span>
    <span class="nb">exit</span> <span class="o">(</span>alias: quit <span class="p">|</span> q<span class="o">)</span> ------ Exit the debugger.
    frame ----------------------- Set the current frame, or execute <span class="nb">command</span> on a different frame.
    funcs ----------------------- Print list of functions.
    goroutine <span class="o">(</span>alias: gr<span class="o">)</span> ------- Shows or changes current goroutine
    goroutines <span class="o">(</span>alias: grs<span class="o">)</span> ----- List program goroutines.
    <span class="nb">help</span> <span class="o">(</span>alias: h<span class="o">)</span> ------------- Prints the <span class="nb">help</span> message.
    libraries ------------------- List loaded dynamic libraries
    list <span class="o">(</span>alias: ls <span class="p">|</span> l<span class="o">)</span> -------- Show <span class="nb">source</span> code.
    locals ---------------------- Print <span class="nb">local</span> variables.
    next <span class="o">(</span>alias: n<span class="o">)</span> ------------- Step over to next <span class="nb">source</span> line.
    on -------------------------- Executes a <span class="nb">command</span> when a breakpoint is hit.
    print <span class="o">(</span>alias: p<span class="o">)</span> ------------ Evaluate an expression.
    regs ------------------------ Print contents of CPU registers.
    restart <span class="o">(</span>alias: r<span class="o">)</span> ---------- Restart process.
    <span class="nb">set</span> ------------------------- Changes the value of a variable.
    <span class="nb">source</span> ---------------------- Executes a file containing a list of delve commands
    sources --------------------- Print list of <span class="nb">source</span> files.
    stack <span class="o">(</span>alias: bt<span class="o">)</span> ----------- Print stack trace.
    step <span class="o">(</span>alias: s<span class="o">)</span> ------------- Single step through program.
    step-instruction <span class="o">(</span>alias: si<span class="o">)</span>  Single step a single cpu instruction.
    stepout <span class="o">(</span>alias: so<span class="o">)</span> --------- Step out of the current <span class="k">function</span>.
    thread <span class="o">(</span>alias: tr<span class="o">)</span> ---------- Switch to the specified thread.
    threads --------------------- Print out info <span class="k">for</span> every traced thread.
    trace <span class="o">(</span>alias: t<span class="o">)</span> ------------ Set tracepoint.
    types ----------------------- Print list of types
    up -------------------------- Move the current frame up.
    vars ------------------------ Print package variables.
    whatis ---------------------- Prints <span class="nb">type</span> of an expression.
Type <span class="nb">help</span> followed by a <span class="nb">command</span> <span class="k">for</span> full documentation.
</code></pre></td></tr></table>
</div>
</div><p>常用的命令总结如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>设置断点</td>
</tr>
<tr>
<td>bp</td>
<td>打印正活动的断点信息</td>
</tr>
<tr>
<td>clear</td>
<td>删除断点</td>
</tr>
<tr>
<td>clearall</td>
<td>删除所有断点</td>
</tr>
<tr>
<td>c</td>
<td>运行直到断点处或程序终止</td>
</tr>
<tr>
<td>n</td>
<td>下一步，不会进入函数</td>
</tr>
<tr>
<td>s</td>
<td>下一步，会进入函数</td>
</tr>
<tr>
<td>so</td>
<td>跳出当前函数</td>
</tr>
<tr>
<td>args</td>
<td>查看函数参数</td>
</tr>
<tr>
<td>locals</td>
<td>查看所有局部变量</td>
</tr>
<tr>
<td>list</td>
<td>打印当前源代码</td>
</tr>
<tr>
<td>on</td>
<td>运行到某断点然后执行相应的命令，比如 on 2 list</td>
</tr>
<tr>
<td>bt</td>
<td>打印当前调用栈</td>
</tr>
<tr>
<td>exit</td>
<td>退出</td>
</tr>
</tbody>
</table>
<h2 id="2-命令使用">2. 命令使用</h2>
<p>下面通过实践说明这些简单命令的使用</p>
<h3 id="21-断点设置">2.1 断点设置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> b main.go:6
Breakpoint <span class="m">1</span> <span class="nb">set</span> at 0x4bd2f8 <span class="k">for</span> main.main<span class="o">()</span> F:/Gotest/main.go:6
</code></pre></td></tr></table>
</div>
</div><h3 id="22-打印断点信息">2.2 打印断点信息</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> bp
Breakpoint runtime-fatal-throw at 0x4377e0 <span class="k">for</span> runtime.fatalthrow<span class="o">()</span> c:/go/src/runtime/panic.go:1162 <span class="o">(</span>0<span class="o">)</span>
Breakpoint unrecovered-panic at 0x437860 <span class="k">for</span> runtime.fatalpanic<span class="o">()</span> c:/go/src/runtime/panic.go:1189 <span class="o">(</span>0<span class="o">)</span>  
        print runtime.curg._panic.arg
Breakpoint <span class="m">1</span> at 0x4bd2f8 <span class="k">for</span> main.main<span class="o">()</span> F:/Gotest/main.go:6 <span class="o">(</span>0<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="23-运行直到断点处">2.3 运行直到断点处</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> c
&gt; main.main<span class="o">()</span> F:/Gotest/main.go:6 <span class="o">(</span>hits goroutine<span class="o">(</span>1<span class="o">)</span>:1 total:1<span class="o">)</span> <span class="o">(</span>PC: 0x4bd2f8<span class="o">)</span>
     1: package main
     2: 
     3: import <span class="s2">&#34;fmt&#34;</span>
     4: 
     5: func main<span class="o">()</span> <span class="o">{</span>
<span class="o">=</span>&gt;   6:         a :<span class="o">=</span> <span class="m">10</span>       
     7:         fmt.Println<span class="o">(</span>a<span class="o">)</span>
     8: <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="24-下一步">2.4 下一步</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> n
&gt; main.main<span class="o">()</span> F:/Gotest/main.go:7 <span class="o">(</span>PC: 0x4bd301<span class="o">)</span>
     2: 
     3: import <span class="s2">&#34;fmt&#34;</span>
     4: 
     5: func main<span class="o">()</span> <span class="o">{</span>
     6:         a :<span class="o">=</span> <span class="nv">10</span>
<span class="o">=</span>&gt;   7:         fmt.Println<span class="o">(</span>a<span class="o">)</span>
     8: <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="25-查看局部变量">2.5 查看局部变量</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> locals
<span class="nv">a</span> <span class="o">=</span> <span class="m">10</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="26-查看当前调用栈">2.6 查看当前调用栈</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> bt
<span class="m">0</span>  0x00000000004bd301 in main.main
   at F:/Gotest/main.go:7
<span class="m">1</span>  0x0000000000439cfa in runtime.main
   at c:/go/src/runtime/proc.go:203
<span class="m">2</span>  0x00000000004643d1 in runtime.goexit
   at c:/go/src/runtime/asm_amd64.s:1373
</code></pre></td></tr></table>
</div>
</div><h3 id="27-打印源代码">2.7 打印源代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> list
&gt; main.main<span class="o">()</span> F:/Gotest/main.go:7 <span class="o">(</span>PC: 0x4bd301<span class="o">)</span>
     2: 
     3: import <span class="s2">&#34;fmt&#34;</span>
     4: 
     5: func main<span class="o">()</span> <span class="o">{</span>
     6:         a :<span class="o">=</span> <span class="nv">10</span>
<span class="o">=</span>&gt;   7:         fmt.Println<span class="o">(</span>a<span class="o">)</span>
     8: <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="28-运行到断点处执行某个命令">2.8 运行到断点处执行某个命令</h3>
<p>1 是断点ID，p a 代表指定到断点处打印变量 a 的值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> on <span class="m">1</span> p a
<span class="o">(</span>dlv<span class="o">)</span> c
<span class="m">10</span>
Process <span class="m">6540</span> has exited with status <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-goroutine-调试">3. Goroutine 调试</h2>
<p>Go 的优势在协程，dlv 相比 GDB 的优点也在于对协程调试的支持，我们以下面的程序为例，给出示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="k">go</span> <span class="nf">printA</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printA</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>设置断点并启动运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">&gt; b main.go:12
Breakpoint <span class="m">1</span> <span class="nb">set</span> at 0x4bd5be <span class="k">for</span> main.main<span class="o">()</span> F:/Gotest/main.go:12
<span class="o">(</span>dlv<span class="o">)</span> c
&gt; main.main<span class="o">()</span> F:/Gotest/main.go:12 <span class="o">(</span>hits goroutine<span class="o">(</span>1<span class="o">)</span>:1 total:1<span class="o">)</span> <span class="o">(</span>PC: 0x4bd5be<span class="o">)</span>
     7: 
     8: func main<span class="o">()</span> <span class="o">{</span>
     9:         a :<span class="o">=</span> <span class="m">10</span>
    10:         go printA<span class="o">(</span>a<span class="o">)</span>
    11: 
<span class="o">=</span>&gt;  12:         time.Sleep<span class="o">(</span>1e9<span class="o">)</span>
    13: <span class="o">}</span>
    14: 
    15: func printA<span class="o">(</span>a int<span class="o">)</span> <span class="o">{</span>
    16:         fmt.Println<span class="o">(</span>a<span class="o">)</span>
    17: <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>查看当前启动的协程，其中 Goroutine 1 是主协程，Goroutine 6 是自行启动的子协程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> goroutines
* Goroutine <span class="m">1</span> - User: F:/Gotest/main.go:12 main.main <span class="o">(</span>0x4bd5be<span class="o">)</span> <span class="o">(</span>thread 11412<span class="o">)</span>
  Goroutine <span class="m">2</span> - User: c:/go/src/runtime/proc.go:305 runtime.gopark <span class="o">(</span>0x43a092<span class="o">)</span>
  Goroutine <span class="m">3</span> - User: c:/go/src/runtime/proc.go:305 runtime.gopark <span class="o">(</span>0x43a092<span class="o">)</span>
  Goroutine <span class="m">4</span> - User: c:/go/src/runtime/proc.go:305 runtime.gopark <span class="o">(</span>0x43a092<span class="o">)</span>
  Goroutine <span class="m">5</span> - User: c:/go/src/runtime/proc.go:305 runtime.gopark <span class="o">(</span>0x43a092<span class="o">)</span>
  Goroutine <span class="m">6</span> - User: F:/Gotest/main.go:15 main.printA <span class="o">(</span>0x4bd5e0<span class="o">)</span>
<span class="o">[</span><span class="m">6</span> goroutines<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>打印主协程当前的变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> locals
<span class="nv">a</span> <span class="o">=</span> <span class="m">10</span>
</code></pre></td></tr></table>
</div>
</div><p>如果要查看子协程的情况，需要先切换到子协程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>dlv<span class="o">)</span> goroutine <span class="m">6</span>
Switched from <span class="m">1</span> to <span class="m">6</span> <span class="o">(</span>thread 11412<span class="o">)</span>
<span class="o">(</span>dlv<span class="o">)</span> bt
<span class="m">0</span>  0x00000000004bd5e0 in main.printA
   at F:/Gotest/main.go:15
<span class="m">1</span>  0x0000000000464621 in runtime.goexit
   at c:/go/src/runtime/asm_amd64.s:1373
<span class="o">(</span>dlv<span class="o">)</span> args
<span class="nv">a</span> <span class="o">=</span> <span class="m">10</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="4-后记">4. 后记</h2>
<p>写到这里好像没发现直接使用 dlv 有什么优势，VScode 在 delve 基础上完成的调试功能更方便，比自己使用命令逐步执行好多了。</p>]]></description></item><item><title>Golang深入学习4-map</title><link>https://shuzang.github.io/golang-deep-learning-4-map/</link><pubDate>Sat, 25 Jul 2020 09:45:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-4-map/</guid><description><![CDATA[<p>本文关心 map 的底层实现、map 的扩容机制和 map 遍历的随机性。</p>
<p>先解答问题</p>
<ol>
<li>map 是实现是哈希表+链地址法解决冲突；</li>
<li>map 扩容每次增加一倍的空间；</li>
<li>map 遍历具有随机性，不要主观地认为遍历的顺序就是插入的顺序。</li>
</ol>
<p>实际上，除了基本的结构定义，map 的初始化、访问、删除、扩容、遍历等操作并没有完全理解，留待之后再说，先占坑。</p>
<h2 id="1-实现">1. 实现</h2>
<p>Go 中映射（map）的底层实现是哈希表，位于 <code>src/runtime/map.go</code> 中，数据被放到一个 buckets 数组里，每个 bucket 包含最多 8 个键值对。key 的哈希值低 8 位用于选择 bucket，高 8 位用于区分 bucket 中存放的多个键值。如果超过 8 个键被放到同一个 bucket，使用一个额外的 bucket 来存储。</p>
<p>核心的结构体主要是 hmap 和 bmap，前者就是这个 bucket 数组，后者就是单个 bucket 的结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// map的基础数据结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">count</span>     <span class="kt">int</span>	 <span class="c1">// map存储的元素对计数，len()函数返回此值，所以map的len()时间复杂度是O(1)
</span><span class="c1"></span>	<span class="nx">flags</span>     <span class="kt">uint8</span>  
	<span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// buckets数组的长度，也就是桶的数量为2^B个
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// 溢出的桶的数量的近似值
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// hash种子
</span><span class="c1"></span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指向2^B个桶组成的数组的指针，数据存在这里
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指向扩容前的旧buckets数组，只在map增长时有效
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// 计数器，标示扩容后搬迁的进度
</span><span class="c1"></span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// 保存溢出桶的指针数组和未使用的溢出桶数组的首地址
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span> <span class="c1">// overflow contains overflow buckets for hmap.buckets.
</span><span class="c1"></span>	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span> <span class="c1">// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span><span class="c1"></span>
	<span class="c1">// nextOverflow holds a pointer to a free overflow bucket.
</span><span class="c1"></span>	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>

<span class="c1">// 桶的实现结构, hmap的buckets指针指向该结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// tophash存储桶内每个key的hash值的高字节
</span><span class="c1"></span>	<span class="c1">// tophash[0] &lt; minTopHash表示桶的疏散状态
</span><span class="c1"></span>	<span class="c1">// 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对
</span><span class="c1"></span>	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
    <span class="c1">// 下面紧跟存放的键值对，存放的格式是所有的 key，然后是所有的 value，
</span><span class="c1"></span>	<span class="c1">// 之所以不是一个 key 跟随一个 value，是为了消除填充所需要的间隙，因为
</span><span class="c1"></span>    <span class="c1">// key 与 value 的类型不一致，占用的内存大小不一致
</span><span class="c1"></span>    
	<span class="c1">// 最后是一个溢出指针
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>hmap 是哈希表的基础结构，hmap.buckets 实际指向 buckets 数组，hmap.oldbuckets 和 hmap.nevacuate 用于扩容，之后介绍，hmap.extra 保存溢出桶的地址的数组以及未使用的溢出桶数组的首地址。</p>
<p>bmap 是单个桶的结构，是一个长度为 8 的数组，数组每个元素的值是 key 的哈希值的高 8 位，数组之后是 8 个 key，然后 8 个 value，最后一个溢出指针，溢出指针指向额外的桶链表，用于存储溢出的数据。用图描述如下</p>
<p></p>
<h2 id="2-访问">2. 访问</h2>
<p>主要是 map.go 文件中的几个 mapaccess 函数，基本逻辑为</p>
<p></p>
<p>找不到 key，就返回该类型的零值。</p>
<h2 id="3-分配">3. 分配</h2>
<p>分配的意思是向 map 中添加新值，主要是 mapassign 函数，基本逻辑与查找相似，但多了写保护和扩容的内容</p>
<p></p>
<h2 id="4-删除">4. 删除</h2>
<p>删除主要是 mapdelete 函数，逻辑如下，删除操作的实质是将值置空，并没有减少内存</p>
<p></p>
<h2 id="5-遍历">5. 遍历</h2>
<p>Go 中 map 遍历的一个突出特征就是元素顺序的随机化，即每次遍历得到的元素的顺序不一定相同，和元素的插入顺序无关。</p>
<p>Go 中遍历的基本逻辑是先调用 mapiterinit 初始化 hiter 结构体，然后利用 该结构体进行遍历。</p>
<h2 id="6-扩容">6. 扩容</h2>
<p>首先，判断是否需要扩容的逻辑是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">growing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="o">!=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>何时h.oldbuckets不为nil呢？在分配assign逻辑中，当没有位置给key使用，而且满足测试条件(装载因子&gt;6.5或有太多溢出通)时，会触发hashGrow逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//判断是否需要sameSizeGrow，否则&#34;真&#34;扩
</span><span class="c1"></span>	<span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
    <span class="c1">// 将buckets复制给oldbuckets
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span>
	<span class="p">}</span>
	<span class="c1">// 更新 hmap 结构
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">flags</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="c1">// 设置溢出桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Promote current overflow buckets to the old generation.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;oldoverflow is not nil&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
	<span class="p">}</span>

	<span class="c1">// the actual copying of the hash table data is done incrementally
</span><span class="c1"></span>	<span class="c1">// by growWork() and evacuate().
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里需要明白，map 扩容时每次增大一倍，方法是分配一个新的 Bucket 数组，然后将就数组复制过去。</p>
<h2 id="参考">参考</h2>
<p>[1] 简书，Love语鬼，<a href="https://www.jianshu.com/p/aa0d4808cbb8" target="_blank" rel="noopener noreffer">Golang map的底层实现</a></p>]]></description></item><item><title>Golang深入学习3-切片</title><link>https://shuzang.github.io/golang-deep-learning-3-slice/</link><pubDate>Fri, 24 Jul 2020 16:13:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-3-slice/</guid><description><![CDATA[<p>本篇理解切片的底层实现和扩容方式。</p>
<h2 id="1-实现">1. 实现</h2>
<p>切片的定义位于 <code>src/runtime/slice.go</code>，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>   <span class="c1">// 用来存储实际数据的数组指针，指向一块连续的内存
</span><span class="c1"></span>    <span class="nx">len</span>   <span class="kt">int</span>              <span class="c1">// 切片中元素的数量
</span><span class="c1"></span>    <span class="nx">cap</span>   <span class="kt">int</span>              <span class="c1">// array数组的长度
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所以可见切片和字符串很相似，实质都是一个指针，只不过除了长度 len 还有一个容量字段 cap。一个简单的图解如下</p>
<p></p>
<p>图中的 x 和 y 都是从数组 [5]int{2,3,5,7,11} 上获取的切片，也就是指向该数组的不同位置。</p>
<p>上篇介绍字符串的时候提到字符串虽然底层是指针，但不允许等于 nil，它的空值是空字符串 <code>&quot;&quot;</code>。但切片是可以等于 nil 的，只要其底层指针等于 nil，一般情况是切片声明而未初始化的时候出现该情况，这个时候因为没有指向任何内存区域，切片的长度和容量信息都是无效的，不过还是可以获取到。</p>
<p>注：因为切片等于 nil 一般意味着没有初始化，也就没有使用的价值，所以很少将切片直接和 nil 作比较，使用更多的还是判断切片的长度是否为0（len(s) == 0）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="p">[]</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="kc">true</span>
</code></pre></td></tr></table>
</div>
</div><p>切片一旦初始化，底层指针就指向了一个确定的内存区域，但指向的内存区域大小可以为0，也就是切片中没有任何元素，此时切片的长度也是 0，但和未初始化时得到的长度绝不是一个含义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="p">[]</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="kc">false</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-扩容">2. 扩容</h2>
<p>切片的长度是当前所包含的元素个数，容量是可容纳的最大元素个数。这里的含义是，初始化时指定的容量就代表在内存已经预分配了与容量相等的空间，其后访问、添加、删除切片的元素都和数组相似，只操作指针，不会造成内存重新分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc000124180</span> <span class="p">[]</span> <span class="mi">0</span> <span class="mi">3</span>
<span class="mh">0xc000124180</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mi">1</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p>但是，如果追加的元素数量超过了容量，那么会导致内存的重新分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc000124180</span> <span class="p">[]</span> <span class="mi">0</span> <span class="mi">3</span>
<span class="mh">0xc000146030</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span> <span class="mi">4</span> <span class="mi">6</span>
</code></pre></td></tr></table>
</div>
</div><p>内存的重新分配就是切片的扩容，其逻辑是，为切片分配一块更大的内存，然后将旧切片的元素复制到新切片中。</p>
<p>一个很有意思的情况如下，将切片 s 赋值给一个新的切片 l，然后对原切片 s 进行扩容和修改，不会影响到切片 l</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[:]</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v&#34;</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc000124180</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="mh">0xc000146030</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
<span class="mh">0xc000124180</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>最后一个值得注意的问题是切片每次扩容会扩大多少，这个逻辑位于 <code>src/runtime/slice.go</code> 文件中的 growslice 函数中，其中 old.len 是旧长度，old.cap 是旧容量，newcap 是新容量，cap 是需要的容量，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ...省略
</span><span class="c1"></span><span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
<span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
<span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
    <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
        <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Check 0 &lt; newcap to detect overflow
</span><span class="c1"></span>        <span class="c1">// and prevent an infinite loop.
</span><span class="c1"></span>        <span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
            <span class="nx">newcap</span> <span class="o">+=</span> <span class="nx">newcap</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="p">}</span>
        <span class="c1">// Set newcap to the requested cap when
</span><span class="c1"></span>        <span class="c1">// the newcap calculation overflowed.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ...省略
</span></code></pre></td></tr></table>
</div>
</div><p>简单描述就是：</p>
<ol>
<li>如果需要的容量超过原切片容量的两倍，直接使用需要的容量作为新容量；</li>
<li>如果原切片的长度小于 1024，新切片的容量翻倍；</li>
<li>如果原切片的长度大于1024，则每次增加25%，直到新容量超过所需要的容量；</li>
</ol>
<p>第二条的翻倍倒是可以确认，但第一条和第三条经验证却不太符合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1. 需要的容量超过原切片容量的两倍，新容量应为需要的容量5
</span><span class="c1"></span>	<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
	<span class="nx">s1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>

	<span class="c1">// 2. 原切片长度小于1024，新容量应当翻倍为4
</span><span class="c1"></span>	<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
	<span class="nx">s2</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>

	<span class="c1">// 3. 原切片长度大于1024，新容量递增25%1次，应当为1500
</span><span class="c1"></span>	<span class="nx">s3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1200</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s3</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s3</span><span class="p">))</span>
	<span class="nx">s3</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v&#34;</span><span class="p">,</span> <span class="nx">s3</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s3</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc0000120b0</span> <span class="mi">2</span>
<span class="mh">0xc00000a390</span> <span class="mi">6</span>
<span class="mh">0xc0000120f0</span> <span class="mi">2</span>
<span class="mh">0xc0000104c0</span> <span class="mi">4</span>
<span class="mh">0xc000100000</span> <span class="mi">1200</span>
<span class="mh">0xc00010c000</span> <span class="mi">1536</span>
</code></pre></td></tr></table>
</div>
</div><p>这是因为扩容的那一段核心源码后面还有一段新容量的处理过程，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">overflow</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">lenmem</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">,</span> <span class="nx">capmem</span> <span class="kt">uintptr</span>
	<span class="c1">// Specialize for common values of et.size.
</span><span class="c1"></span>	<span class="c1">// For 1 we don&#39;t need any division/multiplication.
</span><span class="c1"></span>	<span class="c1">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
</span><span class="c1"></span>	<span class="c1">// For powers of 2, use a variable shift.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">/</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
	<span class="k">case</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">):</span>
		<span class="kd">var</span> <span class="nx">shift</span> <span class="kt">uintptr</span>
		<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
			<span class="c1">// Mask shift for better code generation.
</span><span class="c1"></span>			<span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">63</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">shift</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz32</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">31</span>
		<span class="p">}</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">shift</span><span class="p">)</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nx">maxAlloc</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">&gt;&gt;</span> <span class="nx">shift</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span>
		<span class="nx">capmem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 et 是切片中的元素类型，sys.PtrSize 是一个指针的大小，64位系统中为8，主要调用的处理函数 roundupsize 来自 <code>src/runtime/msize.go</code> 文件，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Returns size of the memory block that mallocgc will allocate if you ask for the size.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
    <span class="c1">// _MaxSmallSize   = 32768
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">_MaxSmallSize</span> <span class="p">{</span>
        <span class="c1">// smallSizeMax    = 1024
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class8</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">smallSizeDiv</span><span class="p">)]])</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class128</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="p">,</span> <span class="nx">largeSizeDiv</span><span class="p">)]])</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// _PageSize = 1 &lt;&lt; 13
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span><span class="o">+</span><span class="nx">_PageSize</span> <span class="p">&lt;</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">size</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">_PageSize</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>这里面涉及到了一些常量和两个函数，内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">_MaxSmallSize</span>   <span class="p">=</span> <span class="mi">32768</span>
	<span class="nx">smallSizeDiv</span>    <span class="p">=</span> <span class="mi">8</span>
	<span class="nx">smallSizeMax</span>    <span class="p">=</span> <span class="mi">1024</span>
	<span class="nx">largeSizeDiv</span>    <span class="p">=</span> <span class="mi">128</span>
	<span class="nx">_NumSizeClasses</span> <span class="p">=</span> <span class="mi">67</span>
	<span class="nx">_PageShift</span>      <span class="p">=</span> <span class="mi">13</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">class_to_size</span> <span class="p">=</span> <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uint16</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">176</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">208</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">288</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">352</span><span class="p">,</span> <span class="mi">384</span><span class="p">,</span> <span class="mi">416</span><span class="p">,</span> <span class="mi">448</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">576</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">704</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="mi">896</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1152</span><span class="p">,</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">1408</span><span class="p">,</span> <span class="mi">1536</span><span class="p">,</span> <span class="mi">1792</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">2304</span><span class="p">,</span> <span class="mi">2688</span><span class="p">,</span> <span class="mi">3072</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">3456</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">4864</span><span class="p">,</span> <span class="mi">5376</span><span class="p">,</span> <span class="mi">6144</span><span class="p">,</span> <span class="mi">6528</span><span class="p">,</span> <span class="mi">6784</span><span class="p">,</span> <span class="mi">6912</span><span class="p">,</span> <span class="mi">8192</span><span class="p">,</span> <span class="mi">9472</span><span class="p">,</span> <span class="mi">9728</span><span class="p">,</span> <span class="mi">10240</span><span class="p">,</span> <span class="mi">10880</span><span class="p">,</span> <span class="mi">12288</span><span class="p">,</span> <span class="mi">13568</span><span class="p">,</span> <span class="mi">14336</span><span class="p">,</span> <span class="mi">16384</span><span class="p">,</span> <span class="mi">18432</span><span class="p">,</span> <span class="mi">19072</span><span class="p">,</span> <span class="mi">20480</span><span class="p">,</span> <span class="mi">21760</span><span class="p">,</span> <span class="mi">24576</span><span class="p">,</span> <span class="mi">27264</span><span class="p">,</span> <span class="mi">28672</span><span class="p">,</span> <span class="mi">32768</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">size_to_class8</span> <span class="p">=</span> <span class="p">[</span><span class="nx">smallSizeMax</span><span class="o">/</span><span class="nx">smallSizeDiv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="kt">uint8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">size_to_class128</span> <span class="p">=</span> <span class="p">[(</span><span class="nx">_MaxSmallSize</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="p">)</span><span class="o">/</span><span class="nx">largeSizeDiv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="kt">uint8</span><span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">66</span><span class="p">}</span>


<span class="c1">// divRoundUp returns ceil(n / a).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">a</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="c1">// a is generally a power of two. This will get inlined and
</span><span class="c1"></span>	<span class="c1">// the compiler will optimize the division.
</span><span class="c1"></span>	<span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// alignUp rounds n up to a multiple of a. a must be a power of 2.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">a</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由此可以得到处理逻辑：对前面的过程得到的新容量 cap，处理后调用 roundupsize 处理，如果容量小于 32768，那么依赖 class_to_size、size_to_class8 和 size_to_class128 三个数组中的两个去调整，得到的结果再稍微处理一下作为新容量。</p>
<p>以前面出错的两个例子计算，首先是需要的容量超过原切片容量两倍的，预处理得到的新容量为 5，然后因为 64 位系统中 int 类型为 8 个字节，调用 roundupsize 的方式是 <code>capmem = roundupsize(uintptr(newcap) * sys.PtrSize)</code>，也就是乘以8再传给 roundupsize 处理，这时 roundupsize 得到的参数是 40，40 &lt; 32768，40 &lt; 1024-8，<code>divRoundUp(size, smallSizeDiv)</code> 计算得到 5，获取 size_to_class8[5] = 4，再获取 class_to_size[4] = 48，最后返回，经过 <code>newcap = int(capmem / sys.PtrSize)</code> 处理得到新容量 48/8 = 6</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 1. 需要的容量超过原切片容量的两倍，新容量应为需要的容量5
</span><span class="c1"></span>	<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
	<span class="nx">s1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>

<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc0000120b0</span> <span class="mi">2</span>
<span class="mh">0xc00000a390</span> <span class="mi">6</span>
</code></pre></td></tr></table>
</div>
</div><p>第二个例子中，预处理得到的新容量是 1500，int 型8个字节，将 1500*8 = 12000 传入 roundupsize，12000 &lt; 32768，但是 12000 &gt; 1024-8，经 <code>divRoundUp(size-smallSizeMax, largeSizeDiv)</code> 计算得到 86，获取 size_to_class128[86] = 55，再获取 class_to_size[55] = 10880，返回后经  <code>newcap = int(capmem / sys.PtrSize)</code> 处理得到新容量 12288/8 = 1536</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 3. 原切片长度大于1024，新容量递增25%1次，应当为1500
</span><span class="c1"></span>	<span class="nx">s3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1200</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v\n&#34;</span><span class="p">,</span> <span class="nx">s3</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s3</span><span class="p">))</span>
	<span class="nx">s3</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p %v&#34;</span><span class="p">,</span> <span class="nx">s3</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s3</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc000100000</span> <span class="mi">1200</span>
<span class="mh">0xc00010c000</span> <span class="mi">1536</span>
</code></pre></td></tr></table>
</div>
</div><p>当然，这个处理过程非常复杂，平常使用一般不会自己去做这么复杂的计算，我们仅仅需要大致估计扩容后的大小就可以了，所以可以简单的使用前面的三条规则做估计，这里重复一下</p>
<ol>
<li>如果需要的容量超过原切片容量的两倍，直接使用需要的容量作为新容量；</li>
<li>如果原切片的长度小于 1024，新切片的容量翻倍；</li>
<li>如果原切片的长度大于1024，则每次增加25%，直到新容量超过所需要的容量；</li>
</ol>]]></description></item><item><title>Golang深入学习2-string</title><link>https://shuzang.github.io/golang-deep-learning-2-string/</link><pubDate>Fri, 24 Jul 2020 11:19:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-2-string/</guid><description><![CDATA[<p>Go 中字符串虽然作为基本数据类型，但本质依然是字符数组，本篇文章理解 Go 底层 string 类型是如何实现的，以及探讨它与 []byte 之间的关系。</p>
<h2 id="1-string">1. string</h2>
<p>标准库 <code>builtin</code> 声明了 Go 所有的预定义标识符，其中对 string 的描述如下</p>
<blockquote>
<p>string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable.</p>
</blockquote>
<p>意思是字符串是字节的一个序列，约定但不必须是 UTF-8 编码的文本。字符串可以为空但不能是nil，其值不可变。Go 中字符串的源码定义在 <code>src/runtime/string.go</code> 中，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">stringStruct</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">len</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所以 Go 中字符串是一个结构体，其中包含两个字段，第一个字段 str 是个指针，第二个字段 len 是字符串长度。str 指针虽然是 unsafe.Pointer 类型，但它最后其实指向了一个 byte 类型的数组，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gostringnocopy</span><span class="p">(</span><span class="nx">str</span> <span class="o">*</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ss</span> <span class="o">:=</span> <span class="nx">stringStruct</span><span class="p">{</span><span class="nx">str</span><span class="p">:</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">str</span><span class="p">),</span> <span class="nx">len</span><span class="p">:</span> <span class="nf">findnull</span><span class="p">(</span><span class="nx">str</span><span class="p">)}</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ss</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所以我们理解了字符串的赋值其实是指针的复制，同时我们还注意到字符串长度其实调用了 findnull 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findnullw</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="kt">uint16</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAlloc</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="kt">uint16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">p</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">l</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 findnull 的实现中，<code>maxAlloc</code> 是<strong>允许用户分配的最大虚拟内存空间</strong>。在 64 位，理论上可分配最大 <code>1 &lt;&lt; heapAddrBits</code> 字节。在 32 位，最大可分配小于 <code>1 &lt;&lt; 32</code> 字节。所以，求长度的逻辑是：如果指针悬空，那么字符串长度为0，否则将指针转换为一个字符数组的指针，然后判断这个字符数组的每个值是否存在，第一个为0的值对应的索引就是字符串的长度。</p>
<p>字符串的值不可改变这个特性是通过禁止访问 str 指针指向的内存的值实现的，但 str 指针本身的值是可以改变的，也就是说它指向的内存区域可以改变，所以字符串可以重复赋值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// str 指针指向&#34;hello&#34;的内存
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;world&#34;</span> <span class="c1">// str 指针指向&#34;world&#34;的内存
</span></code></pre></td></tr></table>
</div>
</div><p>字符串同时也支持切片操作，我们可以理解为 str 的重新赋值和 len 的重新计算，比如下面的语句中，hello 和 world 其实都指向 s 所指向的内存区域，只是指针的位置不一样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;hello, world&#34;</span>
<span class="nx">hello</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="nx">world</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>
</code></pre></td></tr></table>
</div>
</div><p>最后，虽然字符串底层指向一个 byte 数组，单独访问其元素得到的类型也是 byte，但使用 for range 语法遍历时，单个值的类型却是 rune。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="k">break</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="kt">uint8</span> <span class="kt">int32</span>
</code></pre></td></tr></table>
</div>
</div><p>这里主要是因为 Go 专门做了一个解码操作，如下，注意这里的代码不是真的底层实现，只是用来说明逻辑的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">forOnString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">forBody</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">r</span> <span class="kt">rune</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">,</span><span class="nx">size</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">DecodeRuneInString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="nf">forBody</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">r</span><span class="p">)</span>
        <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">size</span><span class="p">:]</span>
        <span class="nx">i</span> <span class="o">+=</span> <span class="nx">size</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-转换">2. 转换</h2>
<p>由以上可知字符串单个字符可能是 byte 或 rune，这也是我们使用字符串时经常做的强制类型转换。它们隐含者内存的重新分配，代价可能是不一样的，所以这里研究一下。</p>
<h3 id="21-string-byte">2.1 string-&gt;[]byte</h3>
<p>string 转换 []byte，源码实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">tmpBuf</span><span class="p">{}</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="c1">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cap</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">cap</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">cap</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)),</span> <span class="nx">cap</span><span class="o">-</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">slice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">cap</span><span class="p">)}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以看到其实做了一次内存的重新分配，得到了新的字符数组 b，然后将 s 复制给 b。至于 copy 函数可以直接把 string 复制给 []byte，是因为 go 源码单独实现了一个<code>slicestringcopy</code>函数来实现，具体可以看<code>src/runtime/slice.go</code>。</p>
<h3 id="22-byte-string">2.2 []byte-&gt;string</h3>
<p>[]byte 转换 string，源码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicebytetostring</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">ptr</span> <span class="o">*</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Turns out to be a relatively common case.
</span><span class="c1"></span>		<span class="c1">// Consider that you want to parse out data between parens in &#34;foo()bar&#34;,
</span><span class="c1"></span>		<span class="c1">// you find the indices and convert the subslice to string.
</span><span class="c1"></span>		<span class="k">return</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ptr</span><span class="p">),</span>
			<span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
			<span class="nf">getcallerpc</span><span class="p">(),</span>
			<span class="nf">funcPC</span><span class="p">(</span><span class="nx">slicebytetostring</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ptr</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">staticuint64s</span><span class="p">[</span><span class="o">*</span><span class="nx">ptr</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">BigEndian</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">str</span> <span class="p">=</span> <span class="nx">p</span>
		<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">len</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">str</span> <span class="p">=</span> <span class="nx">p</span>
	<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">str</span><span class="p">).</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ptr</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">stringStructOf</span><span class="p">(</span><span class="nx">sp</span> <span class="o">*</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">stringStruct</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">stringStruct</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该转换的思路是新分配 s，然后将 b 复制给它，所以依然有内存的重新分配。</p>
<h3 id="23-string-rune">2.3 string-&gt;[]rune</h3>
<p>源码如下，由于 byte 和 rune 类型的差异，比如进行内存的重新分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stringtoslicerune</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="p">[</span><span class="nx">tmpStringBufSize</span><span class="p">]</span><span class="kt">rune</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">rune</span> <span class="p">{</span>
	<span class="c1">// two passes.
</span><span class="c1"></span>	<span class="c1">// unlike slicerunetostring, no race because strings are immutable.
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">n</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">rune</span>
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="nx">buf</span> <span class="p">=</span> <span class="p">[</span><span class="nx">tmpStringBufSize</span><span class="p">]</span><span class="kt">rune</span><span class="p">{}</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="nf">rawruneslice</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
		<span class="nx">n</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// rawruneslice allocates a new rune slice. The rune slice is not zeroed.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">rawruneslice</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">/</span><span class="mi">4</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mem</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">mem</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span> <span class="p">{</span>
		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="nx">mem</span><span class="o">-</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">slice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mem</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="24-rune-string">2.4 []rune-&gt;string</h3>
<p>源码如下，内存分配没得跑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicerunetostring</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="nf">getcallerpc</span><span class="p">(),</span>
			<span class="nf">funcPC</span><span class="p">(</span><span class="nx">slicerunetostring</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">dum</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">size1</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
		<span class="nx">size1</span> <span class="o">+=</span> <span class="nf">encoderune</span><span class="p">(</span><span class="nx">dum</span><span class="p">[:],</span> <span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nf">rawstringtmp</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">size1</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">size2</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
		<span class="c1">// check for race
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">size2</span> <span class="o">&gt;=</span> <span class="nx">size1</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">size2</span> <span class="o">+=</span> <span class="nf">encoderune</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">size2</span><span class="p">:],</span> <span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">size2</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">rawstringtmp</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">l</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">l</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">l</span><span class="p">]</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nf">slicebytetostringtmp</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">,</span> <span class="nx">b</span> <span class="p">=</span> <span class="nf">rawstring</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">rawstring</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

	<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">).</span><span class="nx">str</span> <span class="p">=</span> <span class="nx">p</span>
	<span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">).</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">size</span>

	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">slice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">size</span><span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-总结">3. 总结</h2>
<ol>
<li>string 和 []byte，string 和 []rune 的转换都会进行内存的重新分配，有一定代价；</li>
<li>直接访问 string 中的成员，类型为 byte，使用 for range 结构，类型为 rune；</li>
<li>需要修改 string 中的成员时，需要转换 []byte；</li>
</ol>]]></description></item><item><title>Golang深入学习1-uintptr 和 Unsafe.Pointer</title><link>https://shuzang.github.io/golang-deep-learning-1-uintptr-and-unsafe.pointer/</link><pubDate>Thu, 23 Jul 2020 12:15:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/golang-deep-learning-1-uintptr-and-unsafe.pointer/</guid><description><![CDATA[<p>本篇介绍 Go 中的指针、uintptr 和 unsafe.Pointer 三个概念。</p>
<h2 id="1-指针">1. 指针</h2>
<p>Go 中指针的概念与 C 相同，只是指针本身不能进行运算。</p>
<p>任何一个变量在运行时都有一个地址，这个地址代表它在内存中的位置，在变量名前使用取地址符 <code>&amp;</code> 可以获取该变量的内存地址，比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span> 
</code></pre></td></tr></table>
</div>
</div><p>其中 v 是一个变量，ptr 用来保存它的内存地址，ptr 就是指针。当然，准确的来说，ptr 是一个指针变量，作为变量，仍然是用来保存数据，只不过这里它特别用来保存一个内存地址而已。</p>
<p>一个指针变量需要使用 <code>*</code> 来声明，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ptr</span> <span class="o">*</span><span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p><code>*</code> 代表 ptr 保存一个地址，而 <code>int</code> 代表这个地址指向的内存所保存的数据是 int 类型。这里要注意，*int 和 *string 是不同的指针类型，不能相互赋值，如下例，指针的类型与它所指向的内存地址保存的数据类型有关。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">a</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="p">.</span><span class="err">\</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span> <span class="nx">cannot</span> <span class="nx">use</span> <span class="o">&amp;</span><span class="nf">b</span> <span class="p">(</span><span class="kd">type</span> <span class="o">*</span><span class="kt">string</span><span class="p">)</span> <span class="nx">as</span> <span class="kd">type</span> <span class="o">*</span><span class="kt">int</span> <span class="nx">in</span> <span class="nx">assignment</span>
</code></pre></td></tr></table>
</div>
</div><p>指针在声明但未赋值时其值为 nil，不指向任何内存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="p">&lt;</span><span class="kc">nil</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>将一个变量的地址赋值给指针后，进行使用要利用 <code>*</code> 符号，否则其值就是所保存的内存地址</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">a</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="o">*</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc000012098</span> <span class="mi">10</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-unsafepointer">2. unsafe.Pointer</h2>
<p>我们已经知道不同的指针类型间不能相互赋值，另外，它们也不能进行类型转换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">a</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">float64</span><span class="p">)(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="p">.</span><span class="err">\</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span> <span class="nx">cannot</span> <span class="nx">convert</span> <span class="nf">a</span> <span class="p">(</span><span class="kd">type</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="nx">to</span> <span class="kd">type</span> <span class="o">*</span><span class="kt">float64</span>
</code></pre></td></tr></table>
</div>
</div><p>unsafe.Pointer 是特别定义的一种指针类型，它可以包含任意类型变量的地址，也就是说无论 int、float64 还是其它类型的变量，内存地址都可以交给它保存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Output
</span><span class="c1"></span><span class="mh">0xc000012098</span>
</code></pre></td></tr></table>
</div>
</div><p>从上面的程序注意到两点</p>
<ol>
<li>unsafe.Pointer 来自 unsafe 包，不是内置类型；</li>
<li>unsafe.Pointer 一般作为指针类型转换的桥梁使用</li>
</ol>
<p>unsafe.Pointer 本质是一个 *int，在 unsafe 包中定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ArbitraryType</span> <span class="kt">int</span>
<span class="kd">type</span> <span class="nx">Pointer</span> <span class="o">*</span><span class="nx">ArbitraryType</span>
</code></pre></td></tr></table>
</div>
</div><p>unsafe.Pointer 的使用说明如下</p>
<ol>
<li>任意类型的指针可以转换为一个Pointer类型值</li>
<li>一个Pointer类型值可以转换为任意类型的指针</li>
<li>一个uintptr类型值可以转换为一个Pointer类型值</li>
<li>一个Pointer类型值可以转换为一个uintptr类型值</li>
</ol>
<p>下面是一个使用 unsafe.Pointer 作为桥梁进行类型转换的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">float64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-uintptr">3. uintptr</h2>
<p>uintptr 确确实实是 Go 的基本类型，属于整型的一种，被设计为足够容纳一个指针。在 Go 中指针是不允许进行运算的，但 uintptr 可以，所以它的意义在于将其它类型的指针转换成它进行运算，然后再转换回原本的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Age</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">u</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span>
	<span class="nx">name</span> <span class="o">:=</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">u</span><span class="p">))</span>
	<span class="o">*</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;test&#34;</span>

	<span class="nx">age</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">u</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">Age</span><span class="p">)))</span>
	<span class="o">*</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">18</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>思路: 如果想对 Name 和 Age 进行赋值，那首先应该先拿到相应的地址，然后对地址内容修改，所以我们可以分别定义一个 string 和  int 分别指向 Name 和 Age的地址
对于 u 这个结构体，u 的首地址就是 Name 的地址，但是 u 是结构体指针，所以只需要将u转换成 *string 即可
对于 Age，我们已经拿到了Name的地址，在此基础上进行偏移即可，也就是 unsafe.Offsetof(u.Age) 的偏移量， 但是 <code>Pointer</code>不能进行指针运算，随意需要将 <code>Pointer</code> 转换成 <code>uintptr</code></p>
<h2 id="4-说明">4. 说明</h2>
<p>这里有两点要说明。</p>
<p>第一，理解 unsafe.Pointer 和 uintptr 是因为 Go 源码中很多实现都使用了这两个概念，比如接口类型的定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">iface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tab</span>  <span class="o">*</span><span class="nx">itab</span>
	<span class="nx">data</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">itab</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span> 
	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span> 
	<span class="nx">hash</span>  <span class="kt">uint32</span> 
	<span class="nx">_</span>     <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">fun</span>   <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">uintptr</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第二，使用 unsafe.Pointer 和 uintptr 要非常注意，因为它们绕过了类型系统直接操作内存地址。</p>]]></description></item></channel></rss>