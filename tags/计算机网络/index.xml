<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>计算机网络 - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><description>计算机网络 - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 20 Aug 2020 19:38:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="self" type="application/rss+xml"/><item><title>HTTP方法</title><link>https://shuzang.github.io/http-method/</link><pubDate>Thu, 20 Aug 2020 19:38:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/http-method/</guid><description><![CDATA[<p>理解不同的 HTTP 方法的区别，主要参考 <a href="https://tools.ietf.org/html/rfc7231#section-4.3" target="_blank" rel="noopener noreffer">RFC 7231</a></p>
<h2 id="1-方法的特性">1. 方法的特性</h2>
<p>首先是方法的三个属性：安全性、幂等性和可缓存。</p>
<h3 id="11-安全性">1.1 安全性</h3>
<p>安全性，safe，指的是该方法在语义上是只读的，不会修改服务器的数据。但即使是安全的方法，服务器也可以更改自己的数据，比如记录此次请求的日志。安不安全仅意味着客户端不需要服务端修改数据，因此不用考虑会对服务端造成危害。</p>
<p>安全的方法也不一定知识对服务端静态资源的请求，服务端可以在请求的时候返回即时生成的资源，只要生成资源的脚本保证是安全的即可：也就是说生成资源的时候没有额外影响。就像在一个电商网站添加删除购物车里的物品一样。</p>
<p>安全的方法有 GET，HEAD，OPTIONS，TRACE。</p>
<h3 id="12-幂等性">1.2 幂等性</h3>
<p>幂等性，Idempotent，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说，幂等方法不应该具有副作用。</p>
<p>PUT、DELETE 是幂等的，所有安全的方法都是幂等的</p>
<p>幂等只与后端服务器的实际状态有关，比如，DELETE 删除资源后，第二次调用不应当删除另一个资源，否则服务器的状态将不一致，第一次调用会返回 200，但后续的调用就会返回 404。POST 则不一样，连续调用多次，会增加多个相同的资源。</p>
<h3 id="13-可缓存">1.3 可缓存</h3>
<p>可缓存，Cacheable，指的是可以存储对这些方法的响应以便将来重用。GET、HEAD、POST 方法是可缓存的，不过一般只实现前两个。</p>
<h2 id="2-get">2. GET</h2>
<p>GET 方法用于请求指定的资源，并且只用于获取数据。</p>
<p>使用 GET 方法时请求报文没有实体部分，但成功的响应有实体部分。</p>
<p>GET 方法是安全的、幂等的、可缓存的。浏览器会主动缓存 GET 方法的响应，如果下一次传输的数据相同，就返回缓存中的内容，以求更快的展示。</p>
<p>GET 方法请求的数据一般附在 URL 之后，以 ？分割 URL 和传输数据，多个参数以 &amp; 连接。由于 URL 一般有长度限制，所以即使 HTTP 并未规定 GET 请求的长度，但实际上受 URL 的长度限制。</p>
<h2 id="3-head">3. HEAD</h2>
<p>HEAD 方法请求资源的头部信息，该头部信息与 GET 方法请求返回时的一致。常见的使用场景是在下载一个大文件前先获取其大小再决定是否下载，以此节约带宽资源。</p>
<p>如果 HEAD 请求的结果显示上一次 GET 请求后缓存的资源已过期，那么即使没有再次发出 GET 请求，该缓存也会失效。</p>
<p>HEAD 方法是安全的、幂等的、可缓存的。</p>
<h2 id="4-post">4. POST</h2>
<p>POST 方法发送数据给服务器，因此请求和响应报文都有实体部分，请求报文实体的类型由 <code>Content-Type</code> 首部指定。</p>
<p>POST  请求通常通过表单来发送，此时 <code>content-type</code> 类型是通过在 <code>&lt;form&gt;</code> 元素中设置正确的 <code>enctype</code> 属性, 或是在 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素中设置 <code>formenctype</code> 属性来选择的</p>
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
<p>如果 POST 请求不是通过表单发送，那么实体部分可以是任意类型。</p>
<p>POST 方法不符合安全性和幂等性，但却可以是可缓存的。</p>
<p>由于 POST 方法将提交的数据放在报文的实体部分，因此没有长度的限制。</p>
<p>GET 与 POST 的区别很多都是由于 GET 拼接 URL，POST 传实体部分造成的，包括</p>
<ol>
<li>收藏书签：GET可以，POST不可以，因为 URL 可收藏</li>
<li>保留浏览器历史记录：GET可以，POST不可以，因为 URL 可记录</li>
<li>安全性：GET 稍低，因为 URL 直接可见，可能被劫持</li>
</ol>
<h2 id="5-put">5. PUT</h2>
<p>PUT 方法使用请求报文中的实体部分创建或替换目标资源。它的请求报文有实体部分，但响应报文没有。</p>
<p>PUT 和 POST 的区别在于 PUT 是幂等的，即调用一次与连续调用多次是等价的。举个例子，对于订单提交，多次调用 POST 方法会重复产生多个订单，PUT 方法不会，而是会覆盖掉前一个订单。</p>
<p>使用 PUT 方法时，如果目标资源不存在，则服务器创建一份，并返回 201（Created），通知客户端已创建。如果目标资源已存在，则进行更新，服务器返回 200（OK）或者 204（No Content）表示请求处理成功。</p>
<h2 id="6-delete">6. DELETE</h2>
<p>DELETE 方法用于删除指定的资源，它是幂等的，第一次调用会返回指定资源，第二次会返回 404（Not Found），不会删除另一个资源。</p>
<h2 id="7-connect">7. CONNECT</h2>
<p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p>
<p>例如，CONNECT 可以用来访问采用了 HTTPS 协议的站点。客户端要求代理服务器将 TCP 连接作为通往目的主机隧道。之后该服务器会代替客户端与目的主机建立连接。连接建立好之后，代理服务器会面向客户端发送或接收 TCP 消息流。</p>
<h2 id="8-options">8. OPTIONS</h2>
<p>OPTIONS 方法用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。</p>
<p>比如，检测服务器所支持的请求方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">curl -X OPTIONS http://example.org -i
</code></pre></td></tr></table>
</div>
</div><p>响应报文首部的 <code>Allow</code> 字段值汇报课该服务器支持的所有 HTTP 方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST
Cache-Control: max-age=604800
Date: Thu, 13 Oct 2016 11:45:00 GMT
Expires: Thu, 20 Oct 2016 11:45:00 GMT
Server: EOS (lax004/2813)
x-ec-custom-error: 1
Content-Length: 0
</code></pre></td></tr></table>
</div>
</div><h2 id="9-trace">9 .TRACE</h2>
<p>TRACE 方法使请求的接收者原样返回它收到的消息，一般用于测试或诊断</p>
<h2 id="10-patch">10. PATCH</h2>
<p>PATCH 用于资源的部分修改，不同于 PUT，它是非幂等的，连续多个相同请求会产生不同的效果。</p>
<p>要判断一台服务器是否支持 <code>PATCH </code>方法，那么就看它是否将其添加到了响应首部 <code>Allow</code>或者 <code>Access-Control-Allow-Methods</code>（在跨域访问的场合，CORS）的方法列表中 。</p>]]></description></item><item><title>计算机网络-数据链路层</title><link>https://shuzang.github.io/data-link-layer/</link><pubDate>Sun, 19 Jul 2020 20:25:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/data-link-layer/</guid><description><![CDATA[<p>两台主机间的数据传输，通常不是直达的，而是分成一段一段的链路。两个相邻节点间如何传输数据，是数据链路层关心的事情。</p>
<p>由于物理层已经完成了比特流的传输，数据链路层考虑的就是上一层的事情：如何将网络层交下来的数据报组装成基本传输单位帧，然后将帧发送出去，或者将物理层交上来的比特流划分成帧，取出数据部分后上交给网络层。</p>
<p>尽管传输媒体和通信手段的差异已经被屏蔽，数据链路层依然要考虑两种不同类型的信道：</p>
<ol>
<li>点对点信道：一对一的通信方式；</li>
<li>广播信道：一对多的广播通信方式，同时与多台主机通信。</li>
</ol>
<p>此外，关于传输的基本单位：帧，还要考虑如何对帧进行划分、如何完成差错检测等各种事情。</p>
<h2 id="1-帧">1. 帧</h2>
<p>链路层的基本传输单位叫做<strong>帧</strong>，帧是在网络层交付的 IP 数据报的基础上添加帧头帧尾构成的，然后移交物理层，由物理层作为纯粹的比特流传输给目标主机，目标主机物理层收到后，根据首尾标记，对比特流重新划分形成帧，校验后无差错则去除帧头帧尾交付网络层。</p>
<p>所以数据链路层考虑如何封装成帧，从比特流解析出帧以及进行差错检测，前面两件事是相反的过程。</p>
<h3 id="11-封装成帧">1.1 封装成帧</h3>
<p>封装成帧(framing)就是在一段数据（网络层的 IP 数据报）的前后分别添加首部和尾部，这样就构成了一个帧。</p>
<p>帧所携带的数据长度有一个上限，叫做最大传输单元MTU（Maximum Transfer Unit）。帧首部和尾部的主要作用是进行帧定界（确定帧的界限）以及包括许多控制信息。</p>
<p></p>
<p>对于点对点协议 PPP（Point-to-Point Protocol）来说，帧格式如下</p>
<p></p>
<p>首部和尾部分别为四个字段和两个字段。</p>
<p>首部的第一个字段和尾部的第二个字段都是标志字段F (Flag)，规定为0x7E（十六进制的7E的二进制表示是01111110）。标志字段表示一个帧的开始或结束，也就是定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃</p>
<p>首部中的地址字段A规定为0xFF（即11111111），控制字段C规定为0x03（即00000011）。至今没有实际的意义。首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是 IP 数据报。若为0xC021,则信息字段是 PPP 链路控制协议 LCP 的数据，而 0x8021 表示这是网络层的控制数据。</p>
<p>尾部中的第一个字段（2字节）是使用CRC的帧检验序列 FCS。</p>
<h3 id="12-透明传输">1.2 透明传输</h3>
<p>透明传输的意思是不管什么样的数据都能通过数据链路层，实现这一点解决的主要是一个问题，即帧的数据部分出现了和帧定界符相同的编码，导致无法正确的划分帧。</p>
<p>这种情况广泛出现在传输程序或图像等非 ASCII 码串时，解决方法是在数据中出现帧定界符时在前面加一个转义字符 0x7D（即01111101），如果要传输的字段本身就是转义字符，那么将其变成（0x7D, 0x5D）来传输，接收端在将数据送往网络层前会把转义符删掉。这种方法称为字节填充或字符填充。</p>
<p>上面提到的办法是异步传输时实用的方法，同步传输时采用零比特填充。即在发送端，先扫描整个信息字段，只要发现有5个连续1，则立即填入一个0，从而保证在信息字段中不会出现6个连续1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。</p>
<h3 id="13-差错检测">1.3 差错检测</h3>
<p>差错检测是指检测传输的数据中 0 变成 1，1 变成 0 的情况，使用的方法是<a href="https://baike.baidu.com/item/CRC/1453359" target="_blank" rel="noopener noreffer">循环冗余检验</a>。</p>
<p>在发送端，先把数据划分为组，假定每组 k个比特。现假定待传送的数据 M = 101001 （k =6）。CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位冗余码，然后构成一个帧发送出去，一共发送(k + n)位。这n 位冗余码可用以下方法得出：在 M 后面添加 n 个0，得到的 k + n 位的数除以收发双方事先商定的长度为 n + 1 位的除数P，得出商是 Q 而余数是 R（n 位，比P少一位），这个余数就是冗余码。</p>
<p>下图所示的例子中，M = 101001（即k= 6），假定除数P = 1101（即n = 3），经模2除法运算后的结果是：商Q = 110101（这个商并没有什么用处），而余数 R = 001。这个余数 R 就作为冗余码拼接在数据 M 的后面发送出去。这种为了进行检错而添加的冗余码常称为帧检验序列 FCS(Frame Check Sequence)。</p>
<p></p>
<p>在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以同样的除数P（模2运算），然后检查得到的余数 R。如果无差错，那么余数应当为 0。</p>
<p>除数 P 的生成一般使用多项式，如给定多项式 $P(X) = x^3 + x^2 +1$，那么除数 P = 1101</p>
<p>但链路层的差错检测只检测比特的错误变动，对于 帧丢失、帧重复、帧失序 这些情况不做检测，这些问题由运输层的 TCP 保证。</p>
<h2 id="2-以太网">2. 以太网</h2>
<p>对使用广播信道的数据链路层，主要讨论的是局域网，而由于现在局域网中以太网占主流，实际讨论内容是以太网。另外要注意的是，局域网工作的层次跨越了数据链路层和物理层。由于局域网技术中有关数据链路层的内容比较丰富，因此把局域网的内容放在数据链路层中讨论。但这并不表示局域网仅仅和数据链路层有关。</p>
<h3 id="21-适配器">2.1 适配器</h3>
<p>两台计算机除了需要物理线路（有线或无线）来连接，还必须有一些规范定义这些数据如何传输，实现这些规范的通常是网络适配器（有硬件和软件两方面的含义）</p>
<p>计算机与外界局域网的连接主要是通过适配器，就是我们说的网卡。适配器与局域网的通信是通过双绞线以串行方式进行的，而适配器与计算机的通信是通过主板上的 I/O 总线以并行方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。若在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p>
<p>适配器接收和发送各种帧时不使用计算机的CPU。这时CPU可以处理其他任务。当适配器收到有差错的帧时，就把这个帧丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。我们特别要注意，计算机的硬件地址（MAC地址）在适配器的ROM中，而计算机的软件地址（IP地址）则在计算机的存储器中。</p>
<h3 id="22-csmacd">2.2 CSMA/CD</h3>
<p>在以太网中所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。以太网采用的协议叫做 <a href="https://baike.baidu.com/item/CSMA%2FCD" target="_blank" rel="noopener noreffer">CSMA/CD</a>，意思是载波监听多点接入/碰撞检测(Carrier SenseMultiple Access with Collision Detection)。</p>
<h3 id="23-集线器">2.3 集线器</h3>
<p>集线器工作在物理层，它的每个接口仅仅简单地转发比特——收到1就转发1，收到0就转发0，不进行碰撞检测。若两个接口同时有信号输入（即发生碰撞），那么所有的接口都将收不到正确的帧。</p>
<p></p>
<p>集线器的主要作用是扩展一个以太网的覆盖范围。如下图，使用多个集线器可以构成一个覆盖更大范围的局域网。</p>
<p></p>
<h3 id="24-mac层">2.4 MAC层</h3>
<p>数据链路层分为上层LLC（Logical Links Control，逻辑链路控制），和下层的MAC（媒体访问控制），MAC主要负责控制与连接物理层的物理介质。</p>
<p>IEEE802 标准为局域网规定了一种48位（6字节）的全球地址，这种地址固化在适配器的ROM中，叫做 MAC 地址，除非更换适配器，其它的操作都不会对计算机的 MAC 地址产生影响，因此，MAC 地址实际上可以看作计算机的名字。</p>
<p>48位的 MAC 地址可组成 $2^{46}$ 个地址，超过 70万亿，足够区分全世界所有的计算机。</p>
<p>MAC地址的前三字节由 IEEE 的注册管理机构 RA 分配给世界上所有生产适配器的厂家，后三个字节由厂家自行指派，只要没有重复地址即可。</p>
<p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。</p>
<p>常用的以太网 MAC 帧标准为以太网 V2 标准，帧格式如下</p>
<p></p>
<p>目的地址和源地址指的都是 MAC 地址，类型指上层使用的协议，比如 IP。以太网 MAC 帧的最小长度为 64字节，因此数据部分最小长度为 64-18 = 46 字节，数据部分最大长度为 1500 字节。</p>
<h3 id="25-网桥">2.5 网桥</h3>
<p>集线器工作在物理层，只对数据进行简单转发，网桥工作中数据链路层，会根据 MAC 地址进行针对性转发，这种针对性转发是通过维护一个路由表完成的，路由表中存在网桥接口和MAC地址的对应关系。</p>
<p>两层交换机的本质就是一种多接口网桥。</p>
<p>注意，路由器实际上不属于网桥，它包括网络层，和三层交换机一样，是一个三层设备，不是根据 MAC 地址转发，而是根据网络层的 IP 地址转发。</p>]]></description></item><item><title>计算机网络-物理层</title><link>https://shuzang.github.io/physical-layer/</link><pubDate>Sun, 19 Jul 2020 20:08:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/physical-layer/</guid><description><![CDATA[<p>物理层是 OSI 体系最下面的一层，涉及的多数是关于传输媒体和数据通信的知识，概念居多，本篇不详细解释，仅分辨物理层的主要任务。</p>
<p>物理层考虑的问题是如何传输比特流，它要负责向数据链路层屏蔽掉传输媒体和通信手段的差异，从而使上层能专注自己的协议和服务。</p>
<p>物理层虽然名字中带有「物理」，但并不是指具体的传输媒体，比如各种线缆和硬件接口，而是考虑如何在这些传输媒体上传输数据比特流。</p>
<p>如果我们更具体地阐述物理层的任务，那么包括：</p>
<ul>
<li><strong>机械特性</strong>：定义各种接口所用接线器的形状、尺寸、引脚数目和排列、固定和锁定装置等；</li>
<li><strong>电气特性</strong>：定义在接口电缆的各条线上出现的电压的范围；</li>
<li><strong>功能特性</strong>：定义某条线上出现的某一电平的电压的意义；</li>
<li><strong>过程特性</strong>：定义对于不同功能的可能事件的出现顺序；</li>
</ul>
<p>最后，由于传输媒体中数据的传输一般是串行的，计算机中数据的传输一般是并行的，物理层还要完成数据的串并转换。</p>
<p>因此，我们提到物理层协议的时候，一般是对各种有线传输媒体（双绞线、同轴电缆、光纤等）的接口标准定义和各种无线通信方式的标准定义。此外，介绍物理层还经常介绍一些通信知识，比如信道和各种复用技术。</p>]]></description></item><item><title>HTTP与HTTPS协议</title><link>https://shuzang.github.io/http-and-https/</link><pubDate>Thu, 09 Jul 2020 20:43:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/http-and-https/</guid><description><![CDATA[<p>HTTP 和 HTTPS 是最常用的两个协议，本篇对它们进行介绍。</p>
<h2 id="1-http">1. HTTP</h2>
<h3 id="11-http的概念">1.1 HTTP的概念</h3>
<p>HTTP 全称为超文本传输协议（HyperText Transfer Protocol），它定义了浏览器（客户端进程）如何向网络上的服务器请求网络文档，以及服务器如何将文档传送给浏览器。从层次角度看，HTTP 是一个应用层协议，使用网络层的 TCP 进行可靠传输。</p>
<p>一个大致的工作过程如下所述。每个网络节点都有一个服务器进程，它在后台不间断地监听着 TCP 的 80 端口，以便发现是否有来自浏览器的连接建立请求。一旦监听到连接请求并遵照握手协议建立 TCP 连接后，浏览器就会向该服务器发出浏览某个页面的请求，服务器就返回对应的页面作为响应。最后，TCP 连接被释放掉。</p>
<p>HTTP 就是浏览器和服务器之间请求和响应的交互需要遵循的格式与规则。它规定浏览器与服务器的交互是一个 ASCII 码串，这段字符串的格式就是 HTTP 报文格式。因为 HTTP 是建立在 TCP 上的协议，因此这段字符串也是 TCP 报文的数据部分。</p>
<p>无论是用户主动在浏览器地址栏输入了某个 URL，还是在页面上点击了某个元素，在背后都会转化为一个链接，然后浏览器就会在网络上找到链接对应的页面。假设我输入的 URL 或点击的元素指向了「清华大学院系设置」页面，具体的链接为 <a href="http://www.tsinghua.edu.cn/chn/yxsz/index.htm">http://www.tsinghua.edu.cn/chn/yxsz/index.htm</a>，之后发生的事情如下所述：</p>
<ol>
<li>浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn">www.tsinghua.edu.cn</a> 的 IP 地址；</li>
<li>域名系统返回清华大学服务器的地址 166.111.4.100；</li>
<li>浏览器与服务器建立 TCP 连接；</li>
<li>浏览器发出取文件命令：GET /chn/yxsz/index.htm；</li>
<li>服务器给出响应，把文件 index.htm 发给浏览器；</li>
<li>释放 TCP 连接；</li>
<li>浏览器渲染并显示 index.htm 文件，显示的页面就是「清华大学院系设置」页面</li>
</ol>
<p>数据的可靠性由底层的 TCP 保证，HTTP 本身是无连接的。从上面的过程也可以看出，通信双方并不需要建立和释放 HTTP 连接。同时 HTTP 也是无状态的，无状态的含义是，如果此时浏览器再次访问「清华大学院系设置」页面，服务器会执行一遍重复的过程，再返回一次 index.htm 页面，因为服务器不记得这个浏览器曾经访问过。这种无状态特性既有好处也有坏处，我们以后会介绍这部分内容。</p>
<h3 id="12-http报文结构">1.2 HTTP报文结构</h3>
<p>HTTP 有两类报文：</p>
<ol>
<li>请求报文—从客户向服务器发送请求报文；</li>
<li>响应报文—服务器向客户返回响应；</li>
</ol>
<p>上一小节已经提到过，HTTP 是面向文本的，本质上是一串 ASCII 码字符串，报文的格式就是对字符串的各部分含义进行规定，各部分长度也是不固定的。</p>
<p></p>
<p>HTTP 请求与响应报文都是由三个部分组成：开始行、首部行和实体主体。</p>
<ul>
<li><strong>实体主体</strong>就是数据部分，请求报文一般都不用，响应报文中也可能没有这个字段。</li>
<li><strong>首部行</strong>不一定是一行，可能有多行，也可能没有，每行都是「键：值」形式，其中键叫做首部字段名，每一行结束都要跟一个回车和换行。整个首部行部分结束，还要加一个空行和实体主体分开。首部行的作用是说明浏览器、服务器或报文主体的一些基本信息，首部字段名大都是规定好的。</li>
<li><strong>开始行</strong>是请求和响应报文唯一不同的地方。请求报文的开始行可以叫做请求行，响应报文的开始行叫做状态行，开始行的三个部分都以空格分开，末尾要添加 回车+换行 与首部行部分区分。</li>
</ul>
<h4 id="请求报文">请求报文</h4>
<p>请求报文的第一行请求行包括三部分：方法、URI和版本。</p>
<p><strong>方法</strong>是浏览器希望执行的操作，其实就是一些命令，比如提到的 GET，请求报文的类型一般根据方法的类型进行区分，到 HTTP 1.1共有 9 种方法，如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPTION</td>
<td>请求一些选项的信息</td>
</tr>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>PATCH</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新</td>
</tr>
</tbody>
</table>
<blockquote>
<p>通常，最容易混淆使用的是 PUT 和 POST 两个方法，这里进行说明</p>
<p>PUT 和 POST在使用效果上的区别在于幂等性，幂等性是指，如果一个方法执行多次，产生的效果是一样的，这里 PUT 方法是幂等的，更通俗的解释为</p>
<ul>
<li>PUT：如果两个请求相同，后一个请求会把前一个请求覆盖掉；</li>
<li>POST：后一个请求不会把前一个请求覆盖掉</li>
</ul>
<p>更多的看RFC：https://tools.ietf.org/html/rfc7231#section-4.3</p>
</blockquote>
<p><strong>URI</strong> 是请求资源的 URI，<strong>版本</strong>是指 HTTP 协议的版本，现在一般是 HTTP/1.1。以前面 1.1 小节提到的例子来说明，请求「清华大学院系设置」页面，其 HTTP 请求报文的开始行应当是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">http://www.tsinghua.edu.cn/chn/yxsz/index.htm</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</code></pre></td></tr></table>
</div>
</div><p>这里给出一个完整的请求报文的例子，注意这里请求行使用相对 URL ，这是因为首部行给出了主机域名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">/chn/yxsz/index.htm</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="n">Host</span><span class="o">:</span> <span class="l">www.tsinghua.edu.cn  // 主机域名</span>
<span class="n">Connection</span><span class="o">:</span> <span class="l">close  // 告诉服务器发送完请求的文档后就可以释放连接</span>
<span class="n">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/5.0  // 表明用户代理是使用 Netscape 浏览器</span>
<span class="n">Accept-Language</span><span class="o">:</span> <span class="l">cn  // 表示用户希望优先得到中文版本的文档</span>
<span class="err">//</span> <span class="l">这里有一个空行，后面的实体主体部分为空</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="响应报文">响应报文</h4>
<p>响应报文的状态行同样分三部分：版本，状态码和短语。</p>
<p>版本依然是 HTTP 协议版本，状态码用来说明不同的响应情况，短语是对状态码的简单说明。状态行的示例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">202</span> <span class="ne">Accepted</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP 状态码(tatus Code)都是三位数字，分为 5 大类共 33 种（见RFC 2616），大类的含义如下表。关于更具体地状态码信息，见 附录1。</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1**</td>
<td style="text-align:left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td style="text-align:left">2**</td>
<td style="text-align:left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td style="text-align:left">3**</td>
<td style="text-align:left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4**</td>
<td style="text-align:left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">5**</td>
<td style="text-align:left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p>继续举例，假设请求的网页从 <a href="http://www.ee.xyz.edu/index.html">http://www.ee.xyz.edu/index.html</a> 转移到了一个新的地址，则响应报文的状态行和一个首部行就是下面的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-http" data-lang="http"><span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">301</span> <span class="ne">Moved Permanently</span>
<span class="n">Location</span><span class="o">:</span> <span class="l">http://www.xyz.edu/ee/index.html</span>
</code></pre></td></tr></table>
</div>
</div><p>首部行地键值定义很多都有固定的含义，可以参考附录2。</p>
<h3 id="13-http版本">1.3 HTTP版本</h3>
<p>HTTP 从诞生到现在一共 4 个版本，第一个版本 HTTP/0.9 诞生于1991年，目前已过时，剩下的三个协议比较如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">HTTP1.0</th>
<th style="text-align:left">HTTP1.1</th>
<th>HTTP2.0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">诞生时间</td>
<td style="text-align:left">1992-1996</td>
<td style="text-align:left">1997-1999</td>
<td>2012-2014</td>
</tr>
<tr>
<td style="text-align:left">Host头</td>
<td style="text-align:left">✗</td>
<td style="text-align:left">✔</td>
<td>✔</td>
</tr>
<tr>
<td style="text-align:left">Range头</td>
<td style="text-align:left">✗</td>
<td style="text-align:left">✔</td>
<td>✔</td>
</tr>
<tr>
<td style="text-align:left">长连接</td>
<td style="text-align:left">✗</td>
<td style="text-align:left">✔</td>
<td>✔</td>
</tr>
<tr>
<td style="text-align:left">request method</td>
<td style="text-align:left">GET HEAD POST</td>
<td style="text-align:left">以上+ OPTIONS PUT DELETE TRACE CONNECT</td>
<td>以上全部</td>
</tr>
<tr>
<td style="text-align:left">cache</td>
<td style="text-align:left">Expire Last-Modefied Pragma</td>
<td style="text-align:left">以上+ETag Cache-Control</td>
<td>以上全部</td>
</tr>
<tr>
<td style="text-align:left">header压缩</td>
<td style="text-align:left">✗</td>
<td style="text-align:left">✗</td>
<td>✔</td>
</tr>
<tr>
<td style="text-align:left">多路复用</td>
<td style="text-align:left">✗</td>
<td style="text-align:left">✗</td>
<td>✔</td>
</tr>
<tr>
<td style="text-align:left">服务器推送</td>
<td style="text-align:left">✗</td>
<td style="text-align:left">✗</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p>目前多数都已经切换到了 HTTP/1.1，但由于现在的网页元素越来越丰富（文字、图片、视频等等），使用 HTTP/2.0 会有更低的延迟和更快的加载效果。</p>
<h2 id="2-https">2. HTTPS</h2>
<p>HTTPS 全称为安全超文本传输协议（Secure Hypertext Transfer Protocol），主要是为了解决身份认证和 HTTP 明文传输的问题。</p>
<p>本质上，HTTPS 是在 HTTP 的基础上添加了 SSL/TLS 协议，因此接下来我们先介绍 SSL/TLS 协议。</p>
<h3 id="21-ssltls-协议">2.1 SSL/TLS 协议</h3>
<p>SSL 全称为安全套接字层（Secure Socket Layer），是网景公司在1994年开发的安全协议，是一个运输层协议（实际上是位于运输层和应用层之间）。1995年 SSL 就被转交给了 IETF（互联网工程任务组），开始进行标准化。IETF 在 SSL 3.0 的基础上设计了 TLS 协议，现在使用的基本都是2008年发布的 TLS 1.2，不过在2018年已经发布了最新的 TLS 1.3。<code>F12</code>打开浏览器控制台，在安全选项卡可以看到当前网页使用的 TLS 版本。至此我们知道，SSL和TLS不是两个协议，而是一个协议的不同阶段。</p>
<p></p>
<p>SSL/TLS 协议主要是解决 HTTP 身份认证和明文传输问题，以网上购物为例，假如购物网站使用 HTTP 协议，那么可能出现如下问题</p>
<ol>
<li>浏览器无法确认访问的服务器确实是销售商的，销售商也无法对客户进行鉴别；</li>
<li>顾客的浏览器和销售商的服务器间进行数据交互（比如账单传输）是明文的，可以被别人抓取查看甚至更改。</li>
</ol>
<p>SSL/TLS 通过证书机制进行身份鉴别，通过协商一个对称会话密钥来进行安全的数据传输。下面通过 HTTPS 的通信过程进行详细解释。</p>
<h3 id="22-https-通信过程">2.2 HTTPS 通信过程</h3>
<p>一个比较清晰的流程说明图片如下</p>
<p></p>
<p>第一部分是<strong>证书验证过程</strong>，服务端的公司需要首先向专门的数字证书认证机构申请数字证书，获得证书的同时会得到一对公私钥，私钥自己保存，公钥放在证书里。另外，证书里除了公钥外，还包含证书颁发机构信息、公司信息和证书有效期等字段。客户端通过 HTTPS 协议进行请求时，服务器就会把证书传给客户端。注意，证书颁发机构颁发证书时，已经用自己的私钥进行了签名，公钥公开在网络中，所以客户端收到证书后，就可以利用网络中的证书颁发机构的公钥来验证证书的合法性，这就是验证服务端身份的过程。我们点击浏览器搜索栏的锁图标，可以查看网站证书，下面是B站的证书。</p>
<p></p>
<p>接下来是<strong>协商会话密钥的过程</strong>，协商好的对称会话密钥会用于之后的通信进行数据加解密。之前我们提到，客户端收到的证书里包含一份公钥，客户端验证了服务端的合法性后，就会将证书里的公钥提取出来，同时自己生成一串随机数，然后利用该公钥对随机数进行加密，这串随机数就是之后的会话密钥。客户端将加密的随机数发回给服务器，服务器利用自己保存的私钥进行解密，就可以得到该随机数，此时，会话密钥的协商就完成了。</p>
<p>最后，服务器和客户端之间会利用协商好的密钥进行一次数据传输进行验证。服务器使用密钥（随机数）对数据进行加密并发送给客户端，客户端同样使用该随机数进行解密，自此通信完成。</p>
<p>这是一个大致的过程，实际的请求与响应如下，这里借用了《图解HTTP》的图，还要注意的一点是，TLS 的通信过程是在建立 TCP连接后开始的。</p>
<p></p>
<ol>
<li>客户端发送 Client Hello 报文，开始SSL通信，报文中包含客户端使用的 TLS 协议版本，加密组件列表（支持的加密算法和密钥长度）；</li>
<li>服务器以 Server Hello 报文作为应答，同样包含 TLS 协议版本，并从客户端发来的加密组件中选定一种，放在报文中发回去；</li>
<li>服务器发送 Certificate 报文，报文包含数字证书；</li>
<li>服务器发送 Server Hello Done 报文，表明初始的协商结束；</li>
<li>客户端验证证书合法性，利用证书中的公钥对随机数进行加密，然后放在 Client Key Exchange 报文中发回去；</li>
<li>客户端发送 Change Cipher Spec 报文，提示服务端之后以协商好的会话密钥通信；</li>
<li>客户端发送 Finished 报文，将包含连接至今所有的报文的加密值，如果之后服务端能成功解析才能说明成功；</li>
<li>服务端同样发送 Change Ciphper Spec 报文，表明之后用协商好的会话密钥通信；</li>
<li>服务端发送 Finished 报文；</li>
<li>客户端和服务端的 Finished 报文交换完毕后，实际上 TLS 连接就算建立完成了，之后的所有通信都使用会话密钥加密；</li>
<li>最后关闭连接时，客户端发送 close_notify 报文断开 TLS；</li>
<li>TLS 关闭后才会完成四次握手关闭 TCP 连接。</li>
</ol>
<h2 id="3-http和https">3. HTTP和HTTPS</h2>
<p>大家最常问的一个问题还是 HTTP 和 HTTPS 的区别，这里做一下总结</p>
<ol>
<li>HTTP 使用 80 端口，HTTPS 使用 443 端口；</li>
<li>HTTPS 可以保证身份合法以及数据传输的安全；</li>
<li>HTTPS 建立连接的过程比 HTTP 复杂很多；</li>
<li>HTTPS 通信更慢，因为要进行数据的加解密；</li>
</ol>
<p>实际上，不是所有的信息都使用 HTTPS，一是因为加解密对资源的消耗比较大，普通的非敏感信息不需要加密传输，另一方面是 HTTPS 证书价格太贵。</p>
<h2 id="附录1-http状态码">附录1 HTTP状态码</h2>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">Continue</td>
<td style="text-align:left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td style="text-align:left">101</td>
<td style="text-align:left">Switching Protocols</td>
<td style="text-align:left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td style="text-align:left">201</td>
<td style="text-align:left">Created</td>
<td style="text-align:left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">203</td>
<td style="text-align:left">Non-Authoritative Information</td>
<td style="text-align:left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">No Content</td>
<td style="text-align:left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td style="text-align:left">205</td>
<td style="text-align:left">Reset Content</td>
<td style="text-align:left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">300</td>
<td style="text-align:left">Multiple Choices</td>
<td style="text-align:left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other</td>
<td style="text-align:left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td style="text-align:left">304</td>
<td style="text-align:left">Not Modified</td>
<td style="text-align:left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td style="text-align:left">305</td>
<td style="text-align:left">Use Proxy</td>
<td style="text-align:left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td style="text-align:left">306</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect</td>
<td style="text-align:left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td style="text-align:left">308</td>
<td style="text-align:left">Permanent Redirect</td>
<td style="text-align:left">永久重定向</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">402</td>
<td style="text-align:left">Payment Required</td>
<td style="text-align:left">保留，将来使用</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</td>
</tr>
<tr>
<td style="text-align:left">405</td>
<td style="text-align:left">Method Not Allowed</td>
<td style="text-align:left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td style="text-align:left">406</td>
<td style="text-align:left">Not Acceptable</td>
<td style="text-align:left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td style="text-align:left">407</td>
<td style="text-align:left">Proxy Authentication Required</td>
<td style="text-align:left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td style="text-align:left">408</td>
<td style="text-align:left">Request Time-out</td>
<td style="text-align:left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td style="text-align:left">410</td>
<td style="text-align:left">Gone</td>
<td style="text-align:left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td style="text-align:left">411</td>
<td style="text-align:left">Length Required</td>
<td style="text-align:left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td style="text-align:left">412</td>
<td style="text-align:left">Precondition Failed</td>
<td style="text-align:left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td style="text-align:left">413</td>
<td style="text-align:left">Request Entity Too Large</td>
<td style="text-align:left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td style="text-align:left">414</td>
<td style="text-align:left">Request-URI Too Large</td>
<td style="text-align:left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td style="text-align:left">415</td>
<td style="text-align:left">Unsupported Media Type</td>
<td style="text-align:left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td style="text-align:left">416</td>
<td style="text-align:left">Requested range not satisfiable</td>
<td style="text-align:left">客户端请求的范围无效</td>
</tr>
<tr>
<td style="text-align:left">417</td>
<td style="text-align:left">Expectation Failed</td>
<td style="text-align:left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left">Not Implemented</td>
<td style="text-align:left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left">Service Unavailable</td>
<td style="text-align:left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left">Gateway Time-out</td>
<td style="text-align:left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td style="text-align:left">505</td>
<td style="text-align:left">HTTP Version not supported</td>
<td style="text-align:left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
<h2 id="附录2-http响应头">附录2 HTTP响应头</h2>
<table>
<thead>
<tr>
<th style="text-align:left">应答头</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">服务器支持哪些请求方法（如GET、POST等）。</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(&ldquo;Accept-Encoding&rdquo;)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">应该在什么时候认为文档已经过期，从而不再缓存它？</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>
</tr>
<tr>
<td style="text-align:left">Refresh</td>
<td style="text-align:left">表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(&ldquo;Refresh&rdquo;, &ldquo;5; URL=http://host/path&rdquo;)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=&ldquo;Refresh&rdquo; CONTENT=&ldquo;5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。  注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&rdquo;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=&ldquo;Refresh&rdquo; &hellip;＞。  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>
</tr>
<tr>
<td style="text-align:left">Set-Cookie</td>
<td style="text-align:left">设置和页面关联的Cookie。Servlet不应使用response.setHeader(&ldquo;Set-Cookie&rdquo;, &hellip;)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>
</tr>
<tr>
<td style="text-align:left">WWW-Authenticate</td>
<td style="text-align:left">客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(&ldquo;WWW-Authenticate&rdquo;, &ldquo;BASIC realm=＼&ldquo;executives＼&quot;&quot;)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>
</tr>
</tbody>
</table>]]></description></item><item><title>TCP和UDP协议</title><link>https://shuzang.github.io/transmission-control-protocol-and-user-datagram-protocol/</link><pubDate>Tue, 07 Jul 2020 21:16:00 +0800</pubDate><author>作者</author><guid>https://shuzang.github.io/transmission-control-protocol-and-user-datagram-protocol/</guid><description><![CDATA[<p>本篇介绍计算机网络运输层的的 TCP 和 UDP 协议，主要是过一遍，加深理解，以及方便以后查看，毕竟不是每次都带着书。</p>
<h2 id="1-运输层">1. 运输层</h2>
<p>五层体系结构中，运输层是从上往下的第二层，主要是 TCP 和 UDP 两个协议。</p>
<p>运输层的作用是为相互通信的应用进程提供逻辑通信，因此，运输层的端点是主机中的进程。而网络层为主机间提供通信，因此端点则是网络中的主机。数据在网络中传输时，路由器转发分组都只会用到下三层的功能，与运输层无关，因此，运输层仅在主机的协议栈中起作用。下面的图片比较清楚的说明了这一点</p>
<p></p>
<p>根据应用程序的不同需求，运输层有两种不同的协议，即<strong>用户数据报协议 UDP</strong>（User Datagram Protocol）和<strong>传输控制协议 TCP</strong>（Transmission Control Protocol）。这两种协议是我们在运输层需掌握的主要内容，它们在整体的协议栈中的位置如下所示</p>
<p></p>
<p>网络层的端点是主机，采用 IP 来标识，运输层的端点是应用进程，使用协议端口号（protocol port number）标识，通常简称为<strong>端口</strong>。不同的操作系统实现端口的方法可能是不同的，但其作用是相同的。传输层协议定义一个端口号为 16 位，仅在本地主机具有实际意义，目的是标识各应用进程与传输层交互的接口，因此不同的主机间相同的端口号没有关联。</p>
<p>16 位的端口号允许 65535 个不同的端口号。服务端使用的端口主要分为两类。一类叫做熟知端口或系统端口，数值为 0~1023，这些端口号被指派给了固定的某类应用，其它的应用不得使用。另一类叫做登记端口号，数值为 1024~49151，主要为没有熟知端口号的应用使用，但也有进行登记防止重复。常用的熟知端口号如下</p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>SNMP</th>
<th>SNMP(trap)</th>
</tr>
</thead>
<tbody>
<tr>
<td>熟知端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>161</td>
<td>162</td>
</tr>
</tbody>
</table>
<p>客户端使用的端口号数值为 49152~65535，仅在客户进程运行时才动态选择，存在周期较短，又叫做短暂端口号。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以将数据发送给客户进程，通信结束后，该客户端端口就被释放。</p>
<p>最后要注意的是，对所传输的数据单元，TCP叫做报文段，UDP叫做用户数据报。</p>
<h2 id="2-udp">2. UDP</h2>
<p>UDP 仅在 IP 的基础上增加了很少的功能，关于 UDP 的特点介绍如下</p>
<ol>
<li>
<p>UDP 是<strong>无连接</strong>的。无连接的含义是发送数据前不需要建立连接，发送结束后不需要释放连接；</p>
</li>
<li>
<p>UDP <strong>尽最大努力交付</strong>。尽最大努力的意思是不保证可靠；</p>
</li>
<li>
<p>UDP 是<strong>面向报文</strong>的。发送方的 UDP 对应用程序交下来的报文，添加首部后直接交付 IP 层，不做合并或拆分处理，一次发送一个报文，接收方的 UDP 对 IP 层交上来的报文，去除首部后直接交付应用进程，一次接受一个报文。简单的逻辑图如下</p>
<p></p>
</li>
<li>
<p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p>
</li>
<li>
<p>UDP 首部只有 8 个字节，比 TCP 的20 个字节小的多；</p>
</li>
<li>
<p>UDP 没有拥塞控制，这意味着网络上的拥塞不会影响源主机的发送速率，这种特性使其适合于一些实时的应用，如 IP电话、实时视频会议等，这些应用允许一定的数据丢失，却不允许太大的时延。</p>
</li>
</ol>
<p>UDP 的数据报非常简单，除了 8 个字节的首部，剩下的全是数据部分，首部格式如下图所示</p>
<p></p>
<p>首部共分四个字段，每个字段两个字节，具体解释如下</p>
<ol>
<li>
<p>源端口：源端口号，需要对方回复时使用，不需要时置全 0；</p>
</li>
<li>
<p>目的端口：目的端口号，接收端交付报文必须的；</p>
</li>
<li>
<p>长度：这里的长度是 UDP 整个报文的长度，最小为 UDP 首部 8 个字节</p>
</li>
<li>
<p>校验和：UDP 校验和的计算包括整个 UDP 数据报，除此之外和 IP 首部校验和计算很相似。发送端首先将校验和字段置0，然后在 UDP 首部前加 12 个字节的伪首部，再按 16 位进行划分，最后一行不足16位补 0，写成一串竖式，进行求和计算，对和取反码，从而得到校验和。过程如下图所示</p>
<p></p>
<p>将得到的结果填入校验和字段，并发送出去，接收方收到报文后，添加 12 个字节的伪首部然后继续 16 位划分求和，结果取反码后应该为 1，否则就表明有差错，接收方就会丢弃该报文。</p>
</li>
</ol>
<p>最后要注意的是，UDP 在 IP 报文中的协议字段为 17.</p>
<h2 id="3-tcp">3. TCP</h2>
<p>TCP 协议要复杂很多，我们仍然先介绍其特点</p>
<ol>
<li>
<p>TCP 是<strong>面向连接</strong>的，使用前必须先建立连接，使用后释放连接；</p>
</li>
<li>
<p>TCP <strong>保证可靠</strong>，可靠的含义是通过 TCP 传输的数据无差错、不丢失、不重复、按序到达；</p>
</li>
<li>
<p>TCP 是<strong>面向字节流</strong>的，其含义是 TCP 将应用层交下来的数据看作一连串无结构的字节流，而不是看作一个整体，TCP 不知道所传输的字节流的含义，也不保证接收与交付的数据具有对应大小的关系，仅保证接收方收到的字节流和发送方发出的字节流完全一致，这里的完全一致指的是字节的顺序一致和每个字节的内容没有差错。当然，接收方的应用是一定有能力识别这一连串字节流的含义，这就是应用层的功能了。整个过程可以用下图简单的说明，虽然图中仅仅涉及几个字节，但实际上每个 TCP 报文涉及成百上千字节是很常见的。</p>
<p></p>
</li>
<li>
<p>TCP 仅支持一对一的通信，不同于 UDP，TCP 连接是点对点的；</p>
</li>
<li>
<p>TCP 提供全双工通信，通信双方的应用进程在任何时候都能发送数据。事实上，TCP 连接的两端都设有发送缓存和接收缓存，发送时应用将数据交给发送缓存后就不管了，由 TCP 在合适的时候将数据发出去，接收时把收到的数据放入缓存，上层的应用在合适的时候读取缓存中的数据。</p>
</li>
</ol>
<p>TCP 连接的端点叫做套接字（socket），其实就是 IP 地址和端口号的拼接，尽管 socket 在其它地方还有很多含义，但在这里就这么简单。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">套接字 socket = (IP地址：端口号)
</code></pre></td></tr></table>
</div>
</div><h3 id="31-超时重传">3.1 超时重传</h3>
<p>TCP 可靠传输主要靠下面几个机制保证</p>
<ol>
<li>确认应答和序列号</li>
<li>超时重传</li>
<li>校验和</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ol>
<p>流量控制和拥塞控制需要理解 TCP 报文，放在后面介绍，校验和在 TCP报文中介绍，现在先介绍前两个机制。</p>
<p>首先，理想的情况下，也就是信道不出差错，接收的速度永远跟得上发送的速度，此时数据的发送和接收遵循简单的<strong>停等协议</strong>。由于全双工通信的双方既是发送方也是接收方，下面为了讨论方便，仅考虑 A 发送数据而 B 接收数据，而且将一个 TCP 报文包含的数据称为一个分组。</p>
<p>停等协议的过程如下所示，简单地讲，就是发送方发送分组，接收方接收后返回确认，发送方收到确认后再发送下一个分组，如此循环。</p>
<p></p>
<p>但我们知道现实是不可能出现这种理想情况的，我们必须考虑数据可能出差错，可能丢失，可能不按序到达等许多情况。因此必须采取一定的措施避免这些情况的出现或出现时进行纠正。</p>
<p>首先是发送方<strong>发送的数据出现差错</strong>。差错可以通过校验和的计算检测出来，当检测的差错后，接收方只做一件事，就是丢弃该分组（不通知发送方分组出错），可靠传输的保证是，A 在发送数据后设置了一个超时计时器，如果计时器到期前收到了确认，就撤销该计时器，而此时由于 B 丢弃了分组且没有返回确认，计时器到期后 A 仍然无法收到确认，就会重传前面发送过的分组。这一过程在上图中同样有所说明。</p>
<p>超时重传机制的设定还会同时引入另外两个机制：</p>
<ol>
<li>A 发送完分组后，必须暂时保留已发送的分组的副本（为发生超市重传时使用），只有在收到确认后才能清除保留的副本；</li>
<li>发送的分组和返回的确认分组都必须进行编号，这样才能明确是哪个发送出去的分组收到了确认，哪个没有收到确认。而由于 TCP 是面向字节流的，编号实际上也是针对字节的，也就是说每个字节一个编号。</li>
</ol>
<p>因此我们可以看到，确认应答、序列号、超市重传实际上是协同工作的，一起来保证 TCP 连接的可靠。最后还要注意的一点是，超时计时器的重传时间应当稍微比分组传输的平均往返时间多一点点，从而确保正常网络情况下足已收到确认。</p>
<p>其次是发送方<strong>发送的分组丢失</strong>，丢失的后果是 B 收不到任何数据，同样也不会发送确认，之后触发的超时重传就和出现差错完全相同了。</p>
<p>再然后是<strong>确认丢失</strong>，确认丢失指的是 B 所发送的对分组 $M_1$ 的确认丢失了，此时 A 无法收到确认，依然会触发超时重传，但接下来我们就会注意到 B 再次收到了同样的分组，面对同样的分组 B 所作的事情是：丢弃整个重复的分组，然后向 A 发送确认，丢弃是因为分组已经在缓冲区存在，重新发送确认是因为先前的确认 A 没有收到。整个过程如下图所示</p>
<p></p>
<p>最后一种情况是确认重复。我们考虑一种可能，那就是 B 对分组 $M_1$ 的确认并不是丢失了，而是由于种种原因迟到了，当 A 收到该确认的时候，已经触发了超时重传重新发送了分组，此时 B 所作的事没有区别，依然是丢弃分组然后回复确认，A 所做的事情则是对收到的第二个确认分组进行丢弃。如上图 (b) 所示。</p>
<p>这些机制保证了 A 总能收到对所有发出的分组的确认，如果 A 不断重传而一直收不到确认，那么只能说明一件事，那就是信道质量太差。添加了这一系列机制的协议就叫做 <strong>自动重传请求 ARQ</strong>（Automatic Repeat reQuest）。</p>
<h3 id="32-滑动窗口">3.2 滑动窗口</h3>
<p>无论是停等还是 ARQ，信道的利用率都比较低，主要是因为只有在收到上一个分组的确认后才会发送下一个分组，优化的办法就是使用流水线传输，即发送方连续发送多个分组，不必等待上一个分组的确认，从而使信道上一直有数据在传送。</p>
<p></p>
<p></p>
<p>当使用流水线传输时，就需要连续 ARQ 协议和滑动窗口协议。这里先介绍连续 ARQ 协议，滑动窗口之后介绍。</p>
<p>如下图所示，发送方维持一个发送窗口，其含义是位于发送窗口内的5个字节可以连续的发出去，不必等待对方的确认。一般我们在讨论时，默认理解为下面图中箭头所示的时间流动方向，向前就指向着时间增大的方向，向后就是向着时间减少的方向。字节的发送是按照序号从小到大的方向。</p>
<p></p>
<p>连续 ARQ 协议规定，发送方每收到一个确认，发送窗口就向前移动一格，上图中发送方收到了对第1个字节的确认，因此发送窗口向前移动了1个字节，现在可以发送第6个字节了。另外，由于发送和接收都是面向字节流的，一次发送接收很可能涉及很多字节，所以接收方一般采用<strong>累积确认</strong>的方式，也就是说，接收方不必对收到的每个字节都发送确认，而是只对按序到达的最后一个字节发送确认，这一动作就表示到该字节为止前面所有的字节都正确收到了。</p>
<p>累积确认尽管提高了传输效率，减少了网络中的数据，但可能会造成回退 N 问题（Go-back-N）。该问题描述如下，加入发送方发送了 5 个字节，第 3 个字节丢失了，此时接收方只能对前两个字节发送确认，发送方无法知道后面 3 个字节的下落，此时尽管第 4 和第 5 个字节接收方都已经收到了，发送方还是需要对第 3 个字节开始的数据都重传一次，回退 N 的含义就是退回来重传已发送过的 N 个数据。所以在信道质量不好时，连续 ARQ 具有较大的副作用。</p>
<h3 id="33-tcp-报文">3.3 TCP 报文</h3>
<p>TCP 是面向字节流的，但意思仅限于逐字节编号，交付网络层的实际上是报文段。TCP 报文段首部有 20 个字节是固定的，后面还可以添加 40 个字节，首部最大 60 字节，再往后就是 TCP 的数据部分。TCP 报文格式如下</p>
<p></p>
<ul>
<li>
<p><strong>源端口</strong>和<strong>目的端口</strong>：含义同 UDP</p>
</li>
<li>
<p><strong>序号</strong>：所传输的数据的第一个字节的编号，也就是本报文段数据部分的第一个字节，序号一共四个字节，意味着可编号范围为 $[0, 2^{32}-1]$</p>
</li>
<li>
<p><strong>确认号</strong>：期望收到的对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发过来的报文段，序号字段值为 501，数据部分共 200字节，所以 B 收到的最后一个字节序号为 700，那么 B 期望收到的 A 的下一个报文段的第一个字节序号就是 701，所以在确认报文中将 确认号字段置为 701。</p>
<p>总之，要明白：若 确认号 = N，就说明到序号 N-1 为止的所有数据都正确收到了。</p>
</li>
<li>
<p><strong>数据偏移</strong>：占4位，指 TCP 报文段数据部分距离报文段起始处有多远，简单来说就是 TCP 首部长度。单位是 4 字节，因此最大值为 15 * 4 = 60 字节，这就是 TCP 首部最大长度。</p>
</li>
<li>
<p><strong>保留</strong>：共6位，当前没有使用，全部置0。</p>
</li>
<li>
<p><strong>控制位</strong>：共6位，每位的作用不一样，如下</p>
<ul>
<li><strong>紧急URG</strong> (URGent) ：当URG = 1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Control + C）。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了许多时间。当URG置1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针(UrgentPointer)字段配合使用。</li>
<li><strong>确认ACK</strong> (ACKnowlegment) ：仅当ACK = 1时确认号字段才有效。当ACK = 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li>
<li><strong>推送 PSH</strong> (PuSH)：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送(push)操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH = 1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</li>
<li><strong>复位RST</strong> (ReSeT)：当RST = 1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</li>
<li><strong>同步SYN</strong> (SYNchronization)： 在连接建立时用来同步序号。当SYN = 1而ACK = 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。关于连接的建立和释放，在本章的5.9节还要进行详细讨论。</li>
<li><strong>终止FIN</strong> (FINis，意思是“完”、“终”) ：用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li>
</ul>
</li>
<li>
<p><strong>窗口</strong>：16位，指的是发送本报文段的一方的接收窗口，目的是告诉对方自己还能收多少数据。例如，设确认号是701，窗口字段是1000。这就表明，从701号算起，发送此报文段的一方还有接收1000个字节数据（字节序号是701～1700）的接收缓存空间。</p>
</li>
<li>
<p><strong>校验和</strong>：TCP 校验和的计算方式和 UDP 相同。</p>
</li>
<li>
<p><strong>紧急指针</strong>：占2字节。紧急指针仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</p>
</li>
<li>
<p><strong>选项</strong>：长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
</li>
</ul>
<h3 id="34-流量控制">3.4 流量控制</h3>
<p>流量控制主要依靠滑动窗口，为了方便说明，假定数据传输只在一个方向进行，即 A 发送数据，B 给出确认。</p>
<p>首先，假定 A 收到了 B 发来的确认报文段，其中窗口是20（字节），确认号是31（即期望收到的B发送的下一个序号是31），根据这两个值，A 构造自己的发送窗口如下</p>
<p></p>
<p>此时 A 可以将序号 31 起连续 20 个字节都发送出去，但在未收到确认前都必须保留，以便超时重传使用。因此，发送窗口中的数据表示允许发送的数据，后沿后面的数据表示已收到确认的数据，前沿前面的数据表示不允许发送的数据。如果没有收到新的确认，后沿不可移动，收到新的确认后，后沿向前移动，而如果收到的确认中对方通知的窗口缩小了，使得发送窗口前沿正好不动，那么前沿也不动，否则前沿根据通知的窗口大小向前移动。当然，前沿也可以向后收缩，但 TCP 强烈不赞成这么做。</p>
<p>TCP 的流量控制指的是通过窗口和确认号来调整发送速率，让发送方的发送不要太快，从而使接收方来得及接收。</p>
<p>除此之外，流量控制还包括两个问题。</p>
<p>第一个问题是由于发送方应用层交付过慢造成的，假如发送方应用层每次交付1个字节，那么就需要加上 20 个字节的 TCP 首部，再加上 20 字节的 IP 首部，然后发送出去，每次为了1字节的数据，要多发送远大于数据部分的 40 个字节，效率非常低。应对这种情况主要使用 Nagle 算法，算法如下：若发送方应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来，当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组成一个报文发送出去，同时继续对随后到达的数据进行缓存，只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用地网络带宽。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p>
<p>另一个问题叫做糊涂窗口综合症（silly window syndrome），是由于接收方接收过慢造成的。设想一种情况：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节（这样就使接收缓存空间仅腾出1个字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报是40字节长）。接着，发送方又发来1个字节的数据（请注意，发送方发送的IP数据报是41字节长）。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p>
<p>TCP 的流量控制主要指的就是滑动窗口的控制和这两个问题。</p>
<h3 id="35-拥塞控制">3.5 拥塞控制</h3>
<p>流量控制往往指点对点通信量的控制，要做的是抑制发送端发送数据的速率，以便接收端来得及接收。拥塞控制要做的则是防止过量的数据注入网络，它与流量控制的相似之处在于，某些拥塞控制算法是通过向发送端发送控制报文，令其放慢发送速率完成的，手段与流量控制相似。TCP 的拥塞控制主要是指通过某种手段判断网络是否出现拥塞，然后对发送速率进行调整。</p>
<p>当前进行拥塞控制主要是四种算法：<strong>慢开始</strong>（slow-start）、<strong>拥塞避免</strong>（congestion avoidance）、<strong>快重传</strong>（fast retransmit）和<strong>快恢复</strong>（fast recovery）。</p>
<p>这四种算法都与一个<strong>拥塞窗口</strong> cwnd（congestion window）的状态变量有关，拥塞窗口由发送方维持，其大小取决于网络的拥塞程度，并且在动态地变化，发送方会让自己的发送窗口等于拥塞窗口大小。只要发送方没有按时收到应当到达的确认报文，就猜测网络可能出现了拥塞，此时就将拥塞窗口减小，从而减少发送到网络中的数据，如果按时收到确认，就证明网络没有出现拥塞，拥塞窗口就再增大一些。四种拥塞控制算法实际上就是在控制拥塞窗口的变化。</p>
<h4 id="慢开始">慢开始</h4>
<p>慢开始的思路是这样的，当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因此先将拥塞窗口设置为一个最大报文段的数值，每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值，这样从小到大逐步增加拥塞窗口大小，从而使数据注入到网络的速率更加合理。</p>
<p>举个例子，假设在一开始发送方先设置cwnd = 1，发送第一个报文段M1，接收方收到后确认M1。发送方收到对M1的确认后，把cwnd从1增大到2，于是发送方接着发送M2和M3两个报文段。接收方收到后发回对M2和M3的确认。发送方每收到一个对新报文段的确认（重传的不算在内）就使发送方的拥塞窗口加1，因此发送方在收到两个确认后，cwnd就从2增大到4，并可发送M4～M7共4个报文段（见图5-24）。因此使用慢开始算法后，每经过一个传输轮次(transmission round)，拥塞窗口cwnd就加倍。这里的传输轮次指的是一次往返时间。简单的图示如下</p>
<p></p>
<p>慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd = 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多”。这对防止网络出现拥塞是一个非常有力的措施。</p>
<h4 id="拥塞避免">拥塞避免</h4>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh状态变量。慢开始门限ssthresh的用法如下：</p>
<ul>
<li>当cwnd &lt; ssthresh时，使用上述的慢开始算法。</li>
<li>当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li>
</ul>
<p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样，拥塞窗口cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<h4 id="快重传">快重传</h4>
<p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。</p>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。在下图所示的例子中，接收方收到了M1和M2后都分别发出了确认。现假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段（按照顺序的M3还没有收到）。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对 M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送M5和M6。接收方收到后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待为M3设置的重传计时器到期。由于发送方能尽早重传未被确认的报文段。</p>
<p></p>
<h4 id="快恢复">快恢复</h4>
<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<ol>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。</li>
<li>由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li>
</ol>
<h3 id="36-tcp连接">3.6 TCP连接</h3>
<p>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，而被动等待连接建立的应用进程叫做服务器(server)。</p>
<h4 id="连接建立">连接建立</h4>
<p>TCP 连接建立的过程如下图所示，假定主机 A 运行的是 TCP 客户程序，而 B 运行 TCP 服务器程序。最初两端的TCP 进程都处于 CLOSED（关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。请注意，A 主动打开连接，而 B 被动打开连接。</p>
<p></p>
<p>B 被动打开连接的意思不是在连接建立前 B 不做任何事，相反，B 的 TCP 服务器进程需要先创建传输控制块 TCB，准备接受客户进程的连接请求。然后使服务器进程处于 LISTEN（收听）状态，等待客户的连接请求。</p>
<p>A 的 TCP 客户进程也是首先创建传输控制模块 TCB，然后在需要建立连接时向 B 发出连接请求报文段，这是建立连接的第一条报文，这时首部中的同步位 SYN = 1，同时选择一个初始序号 seq= x。TCP规定，SYN 报文段（即SYN = 1的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p>
<p>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入 SYN-RCVD（同步收到）状态。</p>
<p>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置1，确认号 ack = y + 1，而自己的序号seq = x + 1。TCP 的标准规定，这一个报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p>
<p>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</p>
<p>整个连接建立的过程涉及三个报文的发送接收，因此叫做三次握手(three-way handshake)。</p>
<p>面试时经常问的，也是比较关键的一个问题是第三次确认报文的作用，这里明确：<strong>A 发送第三次确认的原因是防止已失效的连接请求报文段突然又传送到了 B，从而产生错误。</strong></p>
<p>所谓“已失效的连接请求报文段”是这样产生的。假设 A 发出一个连接请求，但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。如果 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用三次握手，那么只要 B 发出确认，新的连接就建立了。</p>
<p>此时由于 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。第三次的确认报文可以防止上述现象的发生。例如在刚才的情况下，A 不会向 B 的确认发出确认。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<h4 id="连接释放">连接释放</h4>
<p>数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意，TCP规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</p>
<p></p>
<p>B 收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭(half-close)状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一些时间。</p>
<p>A 收到来自 B 的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待 B 发出的连接释放报文段。</p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 w（在半关闭状态B可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK（最后确认）状态，等待 A 的确认。</p>
<p>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack = w + 1，而自己的序号是 seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到 TIME-WAIT（时间等待）状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做最长报文段寿命(Maximum Segment Lifetime)，RFC 793建议设为2分钟。但这完全是从工程上来考虑，对于现在的网络，MSL = 2分钟可能太长了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值。因此，从 A 进入到 TIME-WAIT 状态后，要经过4分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接</p>
<p>为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？这有两个理由。</p>
<p>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK状态的 B 收不到对已发送的 FIN+ ACK 报文段的确认。B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 CLOSED 状态。</p>
<p>第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<p>B 只要收到了 A 发出的确认，就进入 CLOSED 状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的TCP 连接。我们注意到，B 结束 TCP 连接的时间要比 A 早一些。</p>
<p>上述的 TCP 连接释放过程叫做四次握手。</p>
<p>除时间等待计时器外，TCP还设有一个保活计时器(keepalive timer)。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75分钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p>]]></description></item><item><title>ICMP协议</title><link>https://shuzang.github.io/internet-control-message-protocol/</link><pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/internet-control-message-protocol/</guid><description><![CDATA[<p>网络层除了主要的 IP 协议外，还有 ICMP（Internet Control Message Protocol） 协议，ping 和 traceroute 都会用到它，本文进行介绍。</p>
<h2 id="1-icmp">1. ICMP</h2>
<p>网际控制报文协议 ICMP，目的是更有效的转发 IP 数据报，提高交付成功的机会。通常被主机或路由器用来报告差错情况和提供有关异常情况的报告。</p>
<p>ICMP 虽然是网络层协议，但其报文是作为 IP 数据报的数据部分传输的。ICMP 的报文格式如下</p>
<p></p>
<p>ICMP 报文有两种：差错报告报文和询问报文，报文的前四字节是统一的格式，有三个字段：类型、代码和检验和，后面四个字节与类型有关，随后就是数据部分。下表给出几种常用的报文类型</p>
<p></p>
<p>代码字段是为了进一步区分某种类型的几种不同情况，比如类型12，又可以分为下面两种</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>0</td>
<td>IP header bad (catchall error)——坏的IP首部（包括各种差错）</td>
</tr>
<tr>
<td>12</td>
<td>1</td>
<td>Required options missing——缺少必需的选项</td>
</tr>
</tbody>
</table>
<p>校验和字段用来检验整个 ICMP 报文，因为 IP 数据报首部的校验和并不检验 IP 数据报的数据部分，不能保证传输的 ICMP 报文不产生差错。</p>
<p>所有的 ICMP 差错报告报文中的数据字段都具有相同的格式，把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来作为 ICMP 报文的数据字段，然后添加 ICMP 首部，就构成了 ICMP 差错报告报文。如下图</p>
<p></p>
<p>提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号以及运输层报文的发送序号，这些信息对源点通知高层协议是有用的。</p>
<p>常用的 ICMP 询问报文有两种</p>
<ol>
<li><strong>回送请求和回答</strong>： ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</li>
<li><strong>时间戳请求和回答</strong>：ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用来进行时钟同步和测量时间。</li>
</ol>
<h2 id="2-traceroute">2. Traceroute</h2>
<p>ICMP 的一个很有用的应用是 traceroute，用来跟踪一个分组从源点到终点的路径，Windows 系统中 命令为 tracert。原理如下：</p>
<p>Traceroute从源主机向目的主机发送一连串的 IP 数据报，数据报中封装的是无法交付的 UDP 用户数据报（使用非法端口）。第一个数据报 P1 的生存时间 TTL 设置为1。当 P1 到达路径上的第一个路由器 R1 时，路由器 R1 先收下它，接着把 TTL 的值减1。由于 TTL 等于零了，R1 就把 P1 丢弃了，并向源主机发送一个ICMP<strong>时间超过</strong>差错报告报文。</p>
<p>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达路由器 R1，R1 收下后把 TTL 减1再转发给路由器 R2。R2 收到 P2 时 TTL 为1，但减1后 TTL 变为零了。R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报告报文。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的 TTL 是1。主机不转发数据报，也不把 TTL 值减1。但因IP数据报中封装的是无法交付的运输层的 UDP 用户数据报，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</p>
<p>这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的 ICMP 报文正好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。下面是向 baidu.com 发出 tracert 命令后得到的结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="p">&gt;</span> <span class="n">tracert</span> <span class="n">www</span><span class="p">.</span><span class="n">baidu</span><span class="p">.</span><span class="n">com</span>

<span class="n">通过最多</span> <span class="n">30</span> <span class="n">个跃点跟踪</span>
<span class="n">到</span> <span class="n">www</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">shifen</span><span class="p">.</span><span class="n">com</span> <span class="p">[</span><span class="n">61</span><span class="p">.</span><span class="n">135</span><span class="p">.</span><span class="n">169</span><span class="p">.</span><span class="n">121</span><span class="p">]</span> <span class="n">的路由</span><span class="err">:</span>

  <span class="n">1</span>     <span class="n">1</span> <span class="n">ms</span>    <span class="p">&lt;</span><span class="n">1</span> <span class="n">毫秒</span>   <span class="p">&lt;</span><span class="n">1</span> <span class="n">毫秒</span> <span class="n">laptop</span> <span class="p">[</span><span class="n">192</span><span class="p">.</span><span class="n">168</span><span class="p">.</span><span class="n">0</span><span class="p">.</span><span class="n">1</span><span class="p">]</span>
  <span class="n">2</span>     <span class="n">6</span> <span class="n">ms</span>     <span class="n">6</span> <span class="n">ms</span>     <span class="n">3</span> <span class="n">ms</span>  <span class="n">1</span><span class="p">.</span><span class="n">28</span><span class="p">.</span><span class="n">220</span><span class="p">.</span><span class="n">60</span><span class="p">.</span><span class="n">adsl-pool</span><span class="p">.</span><span class="n">sx</span><span class="p">.</span><span class="n">cn</span> <span class="p">[</span><span class="n">60</span><span class="p">.</span><span class="n">220</span><span class="p">.</span><span class="n">28</span><span class="p">.</span><span class="n">1</span><span class="p">]</span>
  <span class="n">3</span>    <span class="n">21</span> <span class="n">ms</span>    <span class="n">18</span> <span class="n">ms</span>     <span class="n">5</span> <span class="n">ms</span>  <span class="n">201</span><span class="p">.</span><span class="n">5</span><span class="p">.</span><span class="n">220</span><span class="p">.</span><span class="n">60</span><span class="p">.</span><span class="n">adsl-pool</span><span class="p">.</span><span class="n">sx</span><span class="p">.</span><span class="n">cn</span> <span class="p">[</span><span class="n">60</span><span class="p">.</span><span class="n">220</span><span class="p">.</span><span class="n">5</span><span class="p">.</span><span class="n">201</span><span class="p">]</span>
  <span class="n">4</span>    <span class="n">36</span> <span class="n">ms</span>    <span class="n">14</span> <span class="n">ms</span>    <span class="n">13</span> <span class="n">ms</span>  <span class="n">253</span><span class="p">.</span><span class="n">8</span><span class="p">.</span><span class="n">220</span><span class="p">.</span><span class="n">60</span><span class="p">.</span><span class="n">adsl-pool</span><span class="p">.</span><span class="n">sx</span><span class="p">.</span><span class="n">cn</span> <span class="p">[</span><span class="n">60</span><span class="p">.</span><span class="n">220</span><span class="p">.</span><span class="n">8</span><span class="p">.</span><span class="n">253</span><span class="p">]</span>
  <span class="n">5</span>    <span class="n">18</span> <span class="n">ms</span>    <span class="n">22</span> <span class="n">ms</span>     <span class="p">*</span>     <span class="n">219</span><span class="p">.</span><span class="n">158</span><span class="p">.</span><span class="n">11</span><span class="p">.</span><span class="n">113</span>
  <span class="n">6</span>    <span class="n">48</span> <span class="n">ms</span>     <span class="p">*</span>       <span class="n">26</span> <span class="n">ms</span>  <span class="n">124</span><span class="p">.</span><span class="n">65</span><span class="p">.</span><span class="n">194</span><span class="p">.</span><span class="n">158</span>
  <span class="n">7</span>    <span class="n">86</span> <span class="n">ms</span>    <span class="n">36</span> <span class="n">ms</span>    <span class="n">22</span> <span class="n">ms</span>  <span class="n">124</span><span class="p">.</span><span class="n">65</span><span class="p">.</span><span class="n">58</span><span class="p">.</span><span class="n">54</span>
  <span class="n">8</span>    <span class="n">64</span> <span class="n">ms</span>    <span class="n">22</span> <span class="n">ms</span>    <span class="n">21</span> <span class="n">ms</span>  <span class="n">123</span><span class="p">.</span><span class="n">125</span><span class="p">.</span><span class="n">248</span><span class="p">.</span><span class="n">46</span>
  <span class="n">9</span>     <span class="p">*</span>        <span class="p">*</span>        <span class="p">*</span>     <span class="n">请求超时</span><span class="err">。</span>
 <span class="n">10</span>     <span class="p">*</span>        <span class="p">*</span>        <span class="p">*</span>     <span class="n">请求超时</span><span class="err">。</span>
 <span class="n">11</span>    <span class="n">25</span> <span class="n">ms</span>    <span class="n">18</span> <span class="n">ms</span>    <span class="n">75</span> <span class="n">ms</span>  <span class="n">61</span><span class="p">.</span><span class="n">135</span><span class="p">.</span><span class="n">169</span><span class="p">.</span><span class="n">121</span>

<span class="n">跟踪完成</span><span class="err">。</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-ping">3. Ping</h2>
<p>ICMP 的另一个重要应用是分组网间探测 PING (Packet InterNetGroper)，用来测试两个主机之间的连通性。Ping 主要使用 ICMP 回送请求和回送回答报文，这是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。</p>
<h3 id="31-原理">3.1 原理</h3>
<p>下面是向 baidu.com 发出的 Ping 请求，计算机连续发出了四个 ICMP 回送请求报文，目标服务器收到后，就返回 ICMP 回收回答报文，往返的 ICMP 报文上都有时间戳，因此很容易得出往返时间。最后会显示出统计结果：发送到哪个机器（IP地址），发送的、收到的和丢失的分组数（但不给出分组丢失的原因），往返时间的最小值、最大值和平均值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="p">&gt;</span>  <span class="n">ping</span> <span class="n">baidu</span><span class="p">.</span><span class="n">com</span>

<span class="n">正在</span> <span class="n">Ping</span> <span class="n">baidu</span><span class="p">.</span><span class="n">com</span> <span class="p">[</span><span class="n">39</span><span class="p">.</span><span class="n">156</span><span class="p">.</span><span class="n">69</span><span class="p">.</span><span class="n">79</span><span class="p">]</span> <span class="n">具有</span> <span class="n">32</span> <span class="n">字节的数据</span><span class="err">:</span>
<span class="n">来自</span> <span class="n">39</span><span class="p">.</span><span class="n">156</span><span class="p">.</span><span class="n">69</span><span class="p">.</span><span class="n">79</span> <span class="n">的回复</span><span class="err">:</span> <span class="n">字节</span><span class="p">=</span><span class="n">32</span> <span class="n">时间</span><span class="p">=</span><span class="n">34ms</span> <span class="n">TTL</span><span class="p">=</span><span class="n">48</span>
<span class="n">来自</span> <span class="n">39</span><span class="p">.</span><span class="n">156</span><span class="p">.</span><span class="n">69</span><span class="p">.</span><span class="n">79</span> <span class="n">的回复</span><span class="err">:</span> <span class="n">字节</span><span class="p">=</span><span class="n">32</span> <span class="n">时间</span><span class="p">=</span><span class="n">54ms</span> <span class="n">TTL</span><span class="p">=</span><span class="n">48</span>
<span class="n">来自</span> <span class="n">39</span><span class="p">.</span><span class="n">156</span><span class="p">.</span><span class="n">69</span><span class="p">.</span><span class="n">79</span> <span class="n">的回复</span><span class="err">:</span> <span class="n">字节</span><span class="p">=</span><span class="n">32</span> <span class="n">时间</span><span class="p">=</span><span class="n">49ms</span> <span class="n">TTL</span><span class="p">=</span><span class="n">48</span>
<span class="n">来自</span> <span class="n">39</span><span class="p">.</span><span class="n">156</span><span class="p">.</span><span class="n">69</span><span class="p">.</span><span class="n">79</span> <span class="n">的回复</span><span class="err">:</span> <span class="n">字节</span><span class="p">=</span><span class="n">32</span> <span class="n">时间</span><span class="p">=</span><span class="n">37ms</span> <span class="n">TTL</span><span class="p">=</span><span class="n">48</span>

<span class="n">39</span><span class="p">.</span><span class="n">156</span><span class="p">.</span><span class="n">69</span><span class="p">.</span><span class="n">79</span> <span class="n">的</span> <span class="n">Ping</span> <span class="n">统计信息</span><span class="err">:</span>
    <span class="n">数据包</span><span class="err">:</span> <span class="n">已发送</span> <span class="p">=</span> <span class="n">4</span><span class="err">，</span><span class="n">已接收</span> <span class="p">=</span> <span class="n">4</span><span class="err">，</span><span class="n">丢失</span> <span class="p">=</span> <span class="n">0</span> <span class="p">(</span><span class="n">0</span><span class="p">%</span> <span class="n">丢失</span><span class="p">)</span><span class="err">，</span>
<span class="n">往返行程的估计时间</span><span class="p">(</span><span class="n">以毫秒为单位</span><span class="p">)</span><span class="err">:</span>
    <span class="n">最短</span> <span class="p">=</span> <span class="n">34ms</span><span class="err">，</span><span class="n">最长</span> <span class="p">=</span> <span class="n">54ms</span><span class="err">，</span><span class="n">平均</span> <span class="p">=</span> <span class="n">43ms</span>
</code></pre></td></tr></table>
</div>
</div><p>注：在 Linux 下，ping 命令会持续不断地发出 ICMP 回送请求报文，而不是发 4 个就停止，需要手动给出停止信号。</p>
<h3 id="32-c语言实现">3.2 C语言实现</h3>
<p>下面给出一个使用 C 语言的 Ping 命令实现，主要使用 RAW 模式的 SOCKET 编程，因为基于 UDP 的 socket 编程和基于 TCP 的 socket 编程都无法对下一层（网络层）的数据包进行操作。</p>
<p><strong>所用的API函数</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建socket</td>
<td>socket(af, type, protocol)</td>
</tr>
<tr>
<td>关闭socket</td>
<td>closesocket(socket)</td>
</tr>
<tr>
<td>发送数据</td>
<td>sendto(s, buf, len, flags, to, tolen)</td>
</tr>
<tr>
<td>接收数据</td>
<td>recvfrom(s, buf, len, flags, from, fromlen)</td>
</tr>
<tr>
<td>将域名翻译为IP</td>
<td>gethostbyname(name)</td>
</tr>
<tr>
<td>将IP转换为点分十进制格式</td>
<td>Inet_ntoa(ip)</td>
</tr>
<tr>
<td>WSAStartupWSACleanup</td>
<td>其它socket函数使用前和使用后用这两个</td>
</tr>
</tbody>
</table>
<p>ICMP数据头结构定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_ihdr</span>
<span class="p">{</span>
   <span class="n">BYTE</span> <span class="n">i_type</span><span class="p">;</span>      <span class="c1">//类型
</span><span class="c1"></span>   <span class="n">BYTE</span> <span class="n">i_code</span><span class="p">;</span>      <span class="c1">//代码
</span><span class="c1"></span>   <span class="n">USHORT</span> <span class="n">i_cksum</span><span class="p">;</span>      <span class="c1">//校验和
</span><span class="c1"></span>   <span class="n">USHORT</span> <span class="n">i_id</span><span class="p">;</span>      <span class="c1">//标识符
</span><span class="c1"></span>   <span class="n">USHORT</span> <span class="n">i_seq</span><span class="p">;</span>      <span class="c1">//序号
</span><span class="c1"></span>   <span class="cm">/* 下面的时间戳不是标准ICMP头部，这个程序里是为了容易计算世界定义的 */</span>
   <span class="n">ULONG</span> <span class="n">timestamp</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IcmpHeader</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>IP数据包头结构定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">iphdr</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">h_len</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>     <span class="c1">// 首部长度
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">version</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>    <span class="c1">// 版本号
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tos</span><span class="p">;</span>        <span class="c1">// 服务类型
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">total_len</span><span class="p">;</span>     <span class="c1">// 总长度
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ident</span><span class="p">;</span>       <span class="c1">// 标识
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">frag_and_flags</span><span class="p">;</span>    <span class="c1">// 标志和片偏移
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ttl</span><span class="p">;</span>        <span class="c1">//跳数
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">proto</span><span class="p">;</span>       <span class="c1">// 协议
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">checksum</span><span class="p">;</span>     <span class="c1">// 校验和
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sourceIP</span><span class="p">;</span>      <span class="c1">//源地址
</span><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">destIP</span><span class="p">;</span>        <span class="c1">//目的地址
</span><span class="c1"></span><span class="p">}</span> <span class="n">IpHeader</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>程序实现的功能包括对域名和 IP 地址发出的 Ping 命令，举例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="p">&gt;</span> <span class="n">ping</span> <span class="n">192</span><span class="p">.</span><span class="n">168</span><span class="p">.</span><span class="n">1</span><span class="p">.</span><span class="n">1</span>
<span class="p">&gt;</span> <span class="n">ping</span> <span class="no">[www.neu.edu.cn]</span><span class="p">(</span><span class="n">http</span><span class="err">:</span><span class="p">//</span><span class="n">www</span><span class="p">.</span><span class="n">neu</span><span class="p">.</span><span class="n">edu</span><span class="p">.</span><span class="n">cn</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>程序流程如下</p>
<p></p>
<p>代码放在了 <a href="https://gist.github.com/shuzang/26b2052e5283fa0ff596c43fa3c52265.js" target="_blank" rel="noopener noreffer">Github Gist</a>，测试结果如下参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="o">&gt;</span> <span class="n">www</span><span class="p">.</span><span class="n">neu</span><span class="p">.</span><span class="n">edu</span><span class="p">.</span><span class="n">cn</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">15</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">2.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">32</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">3.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">4.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">5.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">16</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">6.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">15</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">7.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">16</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">8.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">16</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">9.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">10.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">11.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">16</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">12.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">16</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">13.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">14.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">31</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">15.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">16.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">0</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">17.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">16</span> <span class="n">ms</span>
<span class="mi">32</span> <span class="n">bytes</span> <span class="n">from</span> <span class="mf">202.118.1.7</span><span class="o">:</span> <span class="n">icmp_seq</span> <span class="o">=</span> <span class="mf">18.</span>  <span class="nl">time</span><span class="p">:</span> <span class="mi">1188</span> <span class="n">ms</span>
<span class="o">-</span>    
</code></pre></td></tr></table>
</div>
</div><p>注意：</p>
<ul>
<li>
<p>Sleep(1000)，删除会使被ping的目的机非常繁忙</p>
</li>
<li>
<p>发送的ICMP报文中的数据部分最大可以设置为65535-20-8个字节，这将使网络拥堵</p>
</li>
</ul>]]></description></item></channel></rss>