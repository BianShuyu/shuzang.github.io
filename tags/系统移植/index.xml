<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>系统移植 - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</link><description>系统移植 - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>lylw1996@qq.com (shuzang)</managingEditor><webMaster>lylw1996@qq.com (shuzang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 11 Apr 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://shuzang.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/" rel="self" type="application/rss+xml"/><item><title>Android系统移植</title><link>https://shuzang.github.io/android-system-migration/</link><pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/android-system-migration/</guid><description><![CDATA[<p>采用Android6.0（棉花糖），编译环境为Ubuntu14.04和opoenjdk-7-jdk</p>
<h2 id="1-获取源码">1. 获取源码</h2>
<p>首先参阅Android网站<a href="http://source.android.com/source/initializing.html" target="_blank" rel="noopener noreffer">source.android.com/source/initializing.html</a>安装依赖</p>
<p>除Android网站要求的软件包，还需要安装如下软件包：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt-get install uuid uuid-dev
$ sudo apt-get install zlib1g-dev liblz-dev
$ sudo apt-get install liblzo2-2 liblzo2-dev
$ sudo apt-get install lzop
$ sudo apt-get install git-core curl
$ sudo apt-get install u-boot-tools
$ sudo apt-get install mtd-utils
$ sudo apt-get install android-tools-fsutils
$ sudo apt-get install openjdk-7-jdK
</code></pre></td></tr></table>
</div>
</div><p>获取安卓源码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~
$ mkdir myandroid
$ mkdir bin
$ <span class="nb">cd</span> myandroid
$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
$ ~/bin/repo init -u https://android.googlesource.com/platform/manifest -b android-6.0.1_r22
$ ~/bin/repo sync <span class="c1"># This command loads most needed repos. Therefore, it can take several hours to load.</span>
</code></pre></td></tr></table>
</div>
</div><p>获取内核源码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/myandroid
$ git clone git://git.freescale.com/imx/linux-2.6-imx.git kernel_imx
<span class="c1"># the kernel repo is large. Therefore, this process can take a while.</span>
$ <span class="nb">cd</span> kernel_imx
$ git checkout m6.0.1_2.1.0-ga
</code></pre></td></tr></table>
</div>
</div><p>获取u-boot源码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/myandroid/bootable
$ mkdir bootloader
$ <span class="nb">cd</span> bootloader
$ git clone git://git.freescale.com/imx/uboot-imx.git uboot-imx
$ <span class="nb">cd</span> uboot-imx
$ git checkout m6.0.1_2.1.0-ga
</code></pre></td></tr></table>
</div>
</div><p>为标准Android源码包patch</p>
<h2 id="2-编译">2. 编译</h2>
<p>前面步骤执行完后，执行下列命令开始编译</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/myandroid
$ <span class="nb">source</span> build/envsetup.sh
$ lunch sabresd_6dq-user
$ make 2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> tee build-log.txt
</code></pre></td></tr></table>
</div>
</div><p>make命令执行完后，默认在myandroid/out/target/product/sabresd_6dq中生成输出，我们使用boot-imx6dl.img，u-boot-imx6dl.imx和system.img文件。此时得到的system.img文件的格式并不是我们想要的，要转换成raw格式</p>
<p>System.img经常以两种格式出现：raw和sparse。</p>
<p>一种是raw ext4 image，即raw image，使用file命令可查看它：</p>
<p></p>
<p>其特点是完整的ext4分区镜像（包含很多全零的无效填充区），可以直接使用mount进行挂载，因此比较大（一般1G左右）。</p>
<p>另一种是sparse ext4 image，即simg，使用file命令查看它：</p>
<p></p>
<p>就是说是一个非常普通的dat文件。由于它将raw ext4进行稀疏描述，因此尺寸比较小（没有全零的无效填充区，一般在300到500M之间）。</p>
<p>我们进行的编译会默认的生成sparse格式的system.img，因此需要进行转换，而Android本身提供了源代码工具进行两者的转换，位于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">system/core/libsparse/simg2img.c // 将sparse image转换为raw image； 
system/core/libsparse/img2simg.c // 将raw image转换为sparse image
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>转换的命令如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ simg2img &lt;sparse_image_files&gt; &lt;raw_image_file&gt;
<span class="c1"># 使用示例</span>
$ simg2img system.img system.raw.img
</code></pre></td></tr></table>
</div>
</div><h2 id="3-分区及烧录">3. 分区及烧录</h2>
<p>分区与格式化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo ./fsl-sdcard-partition.sh -f imx6dl /dev/sdX
<span class="c1"># fsl-sdcard-partition.sh为分区脚本，</span>
$ sudo mkfs.fat -n BOOT /dev/sdX1
</code></pre></td></tr></table>
</div>
</div><p>烧录uboot</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo dd <span class="k">if</span><span class="o">=</span>u-boot-imx6dl.imx <span class="nv">of</span><span class="o">=</span>/dev/sdX <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">seek</span><span class="o">=</span>2<span class="p">;</span>sync
</code></pre></td></tr></table>
</div>
</div><p>烧录内核</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cp boot-imx6dl.img /media/登录名/BOOT/boot-imx6dl.img
</code></pre></td></tr></table>
</div>
</div><p>烧录系统</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo dd <span class="k">if</span><span class="o">=</span>system.raw.img <span class="nv">of</span><span class="o">=</span>/dev/sdX5<span class="p">;</span>sync
</code></pre></td></tr></table>
</div>
</div><p>连线，上电，进行串口调试，设置参数如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ setenv bootargs <span class="s1">&#39;console=ttymxc0,115200 init=/init video=mxcfb0:dev=ldb,bpp=32,if=RGB666 video=mxcfb1:dev=ldb,bpp=32,if=RGB666 video=mxcfb2:off video=mxcfb3:off vmalloc=320M androidboot.console=ttymxc0 consoleblank=0 androidboot.hardware=freescale cma=384M&#39;</span>
$ setenv bootcmd <span class="s1">&#39;fatload mmc 1:1 12000000 boot.img;boota 12000000&#39;</span>
$ saveenv
</code></pre></td></tr></table>
</div>
</div><p>此时系统应可以启动成功</p>
<h2 id="4-使用界面">4. 使用界面</h2>
<p></p>
<p></p>
<p></p>
<h2 id="5-android-项目源码管理">5. Android 项目源码管理</h2>
<p>做 Android 移植需要了解的</p>
<p>AOSP：&ldquo;Android Open-Source Project&rdquo;，中文意为&quot;Android 开放源代码项目&quot;。</p>
<p>AOSP项目由不同的子项目组成,为了方便进行管理,Google采用Git对AOSP项目进行多仓库管理</p>
<p>多仓库项目管理的原理是这样的（该部分学习甚至图片都是借用网上某文章）：</p>
<p>我们有个非常庞大的项目Pre,该项目由很多个子项目R1,R2,&hellip;Rn等组成,为了方便管理和协同开发,我们为每个子项目创立自己的仓库,整个项目的结构如下:</p>
<p></p>
<p>将一个项目Pre进行分库后会遇到这么一个问题:如果我们想要创建Pre分支来做feature开发,这就意味着,我们需要到每个子项目中分别创建对应的分支,这个过程如果纯粹靠手工做,那简直是个灾难,利索当然我们会想写个自动化处理程序(我们假设这个工具叫做RepoUtil)来帮助我们解决这个问题.这个RepoUtil也会有版本管理之类的需求,因此我们也用Git对其管理,并为其创建对应的仓库.此时整个项目的结构如下:</p>
<p></p>
<p>这里RepoUtil知道整个项目Pre下的每个子项目(即维护子项目的列表),同时需要提供对这些子项目的管理功能,比如统一创建分支等.但是从&quot;单一职责&quot;角度来看,RepoUitl这个工具的功能过于复杂,我们完全可以将维护子项目列表这个功能抽取出来作为一个新项目sub_projects,因为子项目也会变化,因此,为其创建对应的仓库,并用Git管理,这样的化,RepoUtil只需要通过简单的对ub_projects进行依赖即可,此时整个项目的结构如下:</p>
<p></p>
<p>AOSP项目结构和我上文的描述非常类似.repo工具对应RepoUtil,mainfest对应sub_projects.</p>
<p>总结一下:repo就是这么一种工具,由一系列python脚本组成,通过调用Git命令实现对AOSP项目的管理.</p>
]]></description></item><item><title>Debian系统的移植</title><link>https://shuzang.github.io/migration-of-debian-system/</link><pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/migration-of-debian-system/</guid><description><![CDATA[<p>Debian 系统的移植总分四部分：u-boot的编译与烧录，Linux内核的编译与烧录，Debian 基本根文件系统的制作、配置与烧录，开发板设置。</p>
<h2 id="1-u-boot的编译">1. u-boot的编译</h2>
<p>对应于EMSYM的blurr开发板的u-boot项目使用GitHub进行开源维护，<a href="https://github.com/EMSYM/U-boot" target="_blank" rel="noopener noreffer">下载地址</a>，我的编译环境为Ubuntu16.04 LTS系统</p>
<h3 id="11-下载源码">1.1 下载源码</h3>
<p>方法一：在链接打开后的项目界面依次选择clone or download—&gt;Download ZIP，将源码下载到PC中相应的文件夹（记得解压&hellip;..）</p>
<p>方法二：采用git命令（须事先安装git）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git clone https://github.com/EMSYM/U-boot.git
</code></pre></td></tr></table>
</div>
</div><p>注：该链接在选中clone or download后可看到</p>
<h3 id="12-分支切换">1.2 分支切换</h3>
<p>在下载好的u-boot项目目录下打开虚拟终端，创建并切换分支</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b v4.1 origin/blurr-4.1.15
</code></pre></td></tr></table>
</div>
</div><p></p>
<h3 id="13-安装依赖">1.3 安装依赖</h3>
<p>gcc-arm-linux-gnueabi是我们用到的交叉编译器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt install gcc-arm-linux-gnueabi
$ sudo apt-get install build-essential gcc
</code></pre></td></tr></table>
</div>
</div><p>注：Ubuntu缺省情况下，并没有提供C/C++的编译环境，因此还需要手动安装。如果单独安装gcc以及g++比较麻烦，幸运的是，为了能够编译Ubuntu的内核，Ubuntu提供了一个build-essential软件包。因为依赖关系的问题，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，只需要安装该软件包就可以了。</p>
<p></p>
<h3 id="14-开始编译">1.4 开始编译</h3>
<p>指定核心类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nv">ARCH</span><span class="o">=</span>arm
</code></pre></td></tr></table>
</div>
</div><p>生成配置文件（用到Makefile，参阅<a href="https://hacker-yhj.github.io/resources/gun_make.pdf" target="_blank" rel="noopener noreffer">GNU make中文手册</a>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ make mx6dl_blurr_defconfig
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>指定交叉编译前缀，编译u-boot</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ make <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabi- 
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>执行完上述步骤后，编译即可成功</p>
<h2 id="2-linux内核编译">2. Linux内核编译</h2>
<p>同样，对应于blurr开发板的Linux内核项目也在GitHub上开源维护，<a href="https://github.com/EMSYM/linux" target="_blank" rel="noopener noreffer">项目地址</a></p>
<p></p>
<h3 id="21-源码下载">2.1 源码下载</h3>
<p>下载源码的手段与u-boot类似。这里要提醒的是，最好直接Download ZIP，不要clone，因为下载ZIP只有100多M，clone会有一个多G。而这两种手段得到的源码对之后的编译没有影响。（记得解压zip文件）</p>
<h3 id="22-安装压缩工具lzop">2.2 安装压缩工具lzop</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt-get install lzop
</code></pre></td></tr></table>
</div>
</div><p>lzop是最后生成时要用到的一个压缩工具，当没有安装此工具就开始编译，过程中会出现一个lozp：not found的错误</p>
<p></p>
<h3 id="23-编译">2.3 编译</h3>
<p>进入下载好的Linux项目主目录，逐步执行如下命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">export</span> <span class="nv">ARCH</span><span class="o">=</span>arm
$ <span class="nb">export</span> <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabi-
$ make blurr_defconfig
$ make
</code></pre></td></tr></table>
</div>
</div><p>前两句的意思是指定芯片的架构以及交叉编译器前缀，然后就开始编译了（之前编译u-boot时已装好交叉编译器），可参考 <a href="http://blog.csdn.net/wl_fln/article/details/7258294" target="_blank" rel="noopener noreffer">export命令的介绍</a></p>
<p></p>
<p>会有一些warning，但不碍事</p>
<p></p>
<p>要等很久&hellip;..</p>
<p></p>
<p>完成如上步骤后即可编译完成，我们需要编译得到的zImage文件和imx6dl-blurr.dtb文件位置如下：</p>
<ul>
<li>
<p>zImage：linux-blurr 4.1.15—&gt;arch—&gt;arm—&gt;boot</p>
</li>
<li>
<p>imx6dl-blurr.dtb：linux-blurr 4.1.15—&gt;arch—&gt;arm—&gt;boot—&gt;dts</p>
</li>
</ul>
<p>zImage位置如下图</p>
<p></p>
<p>imx6dl-blurr.dtb直接从上面目录里的dts点进去</p>
<p></p>
<h2 id="3-debian-根文件系统的制作与配置">3. Debian 根文件系统的制作与配置</h2>
<p>该部分内容主要参考官方文档 <a href="https://wiki.debian.org/EmDebian/CrossDebootstrap" target="_blank" rel="noopener noreffer">EmDebian CrossDebootstrap</a>，方法为QEMU/debootstrap的方法。使用debootstrap工具完成根文件系统的制作，使用QEMU模拟器完成配置工作。</p>
<h3 id="31-基本说明">3.1 基本说明</h3>
<p>制作根文件系统的工具常用Debootstrap和Multistrap，制作流程大概分为四个步骤：</p>
<p>1、从源里下载需要的.deb软件包</p>
<p>2、解压它们到相应的目标目录</p>
<p>3、用chroot命令修改该目标目录为根目录</p>
<p>4、配置脚本，完成安装</p>
<p>通常，使用debootstrap、cdebootstrap或multistrap完成第一二阶段的工作，QEMU完成第三四阶段的工作。</p>
<h3 id="32-工具软件安装">3.2 工具软件安装</h3>
<p>使用如下的命令安装所需要工具软件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt-get install binfmt-support qemu qemu-user-static debootstrap
</code></pre></td></tr></table>
</div>
</div><p>debootstrap是根文件系统制作工具，qemu是模拟器，是为了在宿主机上模拟开发板的环境</p>
<p>接下来的步骤需要以root身份执行，因为debootstrap的工作以及chroot到建好的新系统的目录都需要root权限</p>
<h3 id="33-根文件系统制作">3.3 根文件系统制作</h3>
<p>首先选择要引导的目标架构和Debian版本（例如stable、testing或sid）,我们选择开发板对应的arm架构，版本选择Debian9.1,叫做stretch。</p>
<p>创建一个目录文件，制作好的根文件系统将放在这个目录下。需要提示以后所有对根文件系统的修改都局限在这个目录里，不会影响到宿主机，所以不用担心搞毁你的系统。为了介绍清楚，我们采用“debian_armhf_stretch”作为目录名，但它其实就是rootfs，如果你这样命名的话</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo mkdir debian_armhf_stretch
</code></pre></td></tr></table>
</div>
</div><p>制作根文件系统，需要运行debootstrap</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo debootstrap --foreign --arch armhf stretch debian_armhf_stretch http://ftp.debian.org/debian/
</code></pre></td></tr></table>
</div>
</div><p>其中<code>debian_armhf_stretch</code>是创建的目录，<code>armhf</code>是目标架构，<code>http://ftp.debian.org/debian</code>是Debian镜像，必需的.deb包将从这里下载。可以随意选择自己喜欢的镜像，只要它有我们要用于的目标架构。<a href="http://www.debian.org/mirror/list" target="_blank" rel="noopener noreffer">可用的Debian镜像列表</a>，<a href="https://linux.cn/man/man8/debootstrap.8.html" target="_blank" rel="noopener noreffer">debootstrap命令说明</a></p>
<p>会运行两次，第一次是从网上下载，第二次就是在debian_armhf_stretch目录下生成bin、sbin这些Linux文件系统目录了。</p>
<h3 id="34-qemu-配置">3.4 QEMU 配置</h3>
<p>根文件系统已经创建完成。默认情况下，debootstrap创建的是一个非常小的系统，所以可能需要扩展一下，这个放在后面的配置新系统。</p>
<p>先复制“qemu-arm-static” 到刚构建的根文件系统中。为了能chroot到目标文件系统，针对目标CPU的qemu模拟器需要从内部访问</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo cp /usr/bin/qemu-arm-static  debian_armhf_stretch/usr/bin
</code></pre></td></tr></table>
</div>
</div><p>接下来运行debootstrap的第二个阶段来解压步骤3中安装的所有软件包</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo <span class="nv">DEBIAN_FRONTEND</span><span class="o">=</span>noninteractive <span class="nv">DEBCONF_NONINTERACTIVE_SEEN</span><span class="o">=</span><span class="nb">true</span> <span class="nv">LC_ALL</span><span class="o">=</span>C <span class="nv">LANGUAGE</span><span class="o">=</span>C <span class="nv">LANG</span><span class="o">=</span>C chroot debian_armhf_stretch debootstrap/debootstrap --second-stage
</code></pre></td></tr></table>
</div>
</div><p>该命令意思是设置一些环境变量,然后切换根目录到debian_armhf_stretch（这个操作是chroot做的，这个命令很有意思），执行目录debian_armhf_stretch/debootstrap下的命令: debootstrap &ndash;second-stage。终端上最后会打印 <code>I: Base system installed successfully.</code>，就说明成功了。</p>
<p>切换到qemu</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">$sudo</span> chroot debian_armhf_stretch
</code></pre></td></tr></table>
</div>
</div><p>不过如果这样的话之后的提示都是英文的，想显示中文需要把上面的命令这样输入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo <span class="nv">LANG</span><span class="o">=</span>C.UTF-8 chroot debian_armhf_stretch
</code></pre></td></tr></table>
</div>
</div><h2 id="4-新系统配置">4. 新系统配置</h2>
<p>刚刚创建的新系统需要一些简单的调整以便于你运用它做一些特殊的工作。下面的步骤需要以root权限执行</p>
<ol>
<li>
<p>手动在/etc/apt/sources.list里面添加如下条目</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">deb http://ftp.debian.org/debian/ stretch main contrib non-free
deb-src http://ftp.debian.org/debian/ stretch main contrib non-free
</code></pre></td></tr></table>
</div>
</div><p>源的选择是随便的，只要它支持目标平台就行，不过国内<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/debian" target="_blank" rel="noopener noreffer">中科大的源</a>好用一点，这时候就可以像往常一样使用apt-get install 命令安装其它软件包了。</p>
</li>
<li>
<p>安装xorg和KDE，KDE新版本叫plasma</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt-get install xorg
$ sudo apt-get install plasma-desktop
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>这句执行也是真的久，不要着急，中间可能会自动进入一些配置界面，根据选项自己选就行，如果乱码的话可以选第一个，其实上面设置成中文就没乱码了。</p>
</li>
<li>
<p>安装终端konsole，安装浏览器qupzilla（这是因为Debian9以下不支持chrome），安装文件管理器dolphin，网络管理器plasma-nm</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo apt-get install konsole
$ sudo apt-get install qupzilla
$ sudo apt-get install dolphin
$ sudo apt-get install plasma-nm
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>打开etc文件夹中的fstab文件，在末尾添加</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">/dev/sda / ext4 defaults <span class="m">0</span> <span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>root用户下输入命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chown root:root /usr/bin/sudo
chmod <span class="m">4755</span> /usr/bin
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="5-烧录工作">5. 烧录工作</h2>
<p>u-boot，Linux内核和根文件系统都是需要烧录的，下面介绍如何进行这部分工作。首先将SD卡格式化，准备好要烧录的文件</p>
<ul>
<li>u-boot：u-boot.imx</li>
<li>内核：zImage和imx6dl-blurr.dtb</li>
<li>根文件系统：debian_armhf_stretch</li>
</ul>
<h3 id="51-设置sd卡">5.1 设置SD卡</h3>
<p>SD卡需要创建2个分区，并且在第一个分区之前预留一段空间用于保存u-boot.imx；然后第一个分区设置为fat格式，用于保存内核编译成的两个文件；第二个分区设置为ext4格式，用于保存根文件系统。</p>
<h4 id="格式化">格式化</h4>
<p>在分区之前，先将SD卡格式化（可能Windows下格式化方便一点），首先在Linux系统下插入SD卡，查看挂载位置，使用<a href="http://www.linuxidc.com/Linux/2012-06/61872.htm" target="_blank" rel="noopener noreffer">fdisk</a>命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo fdisk -l
</code></pre></td></tr></table>
</div>
</div><p>这个命令作用为查看磁盘使用情况的，最后那个即为我们新挂载的SD卡</p>
<p></p>
<p>从结果输出中可以看到SD卡，挂载位置是/dev/sdb，输入命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo fdisk /dev/sdb
</code></pre></td></tr></table>
</div>
</div><p>该命令含义为进入分割硬盘模式，这个命令执行结束就可以操作分区了。</p>
<p></p>
<h4 id="删除原有分区">删除原有分区</h4>
<p>输入m可以获取帮助，显示所有可用命令。先用d 命令删除原来的分区，提示Selected partition，在后面输入要删除的分区号，回车，分区即可删除成功</p>
<p></p>
<p>输入命令p查看此时的分区信息，已变成一整块的磁盘未分区，接下来开始分区</p>
<h4 id="重新分区">重新分区</h4>
<p>n命令新建分区，第一次输入p分割为主分区，分区号为1，分区的起始位置和结束位置自己算好填上去，注意分区必以sector为单位，一个sector 为512 bytes，所以不要输不是512整数倍的数。</p>
<p>n命令新建分区，第二次输入e分割分区，分区号为2，起始位置接着上一个分区的结束位置。</p>
<p></p>
<p>p命令查看分区信息，看是否符合预想。w命令保存退出。弹出重新插入SD卡或者重新启动Ubuntu系统，之后再次查看分区信息，这是为了更新分区表给内核，否则看不到分好的区。</p>
<p></p>
<p>格式化新建的分区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo mkfs.ext4 /dev/sdb2
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>然后对两个分区格式化</p>
<p>输入t，选择分区1，将分区1格式化为fat，这里输入6为FAT16，c为FAT32</p>
<p>输入t，选择分区2，将分区2格式化为ext4格式，输入83即可</p>
<p>注：这里输入83格式化结束最后查看分区其实显示的是83 Linux，这就已经是ext4格式了，不要觉得自己错了，因为Linux的默认格式就是ext4</p>
<p>w命令保存</p>
<p></p>
<h3 id="52-烧录">5.2 烧录</h3>
<h4 id="u-boot">u-boot</h4>
<p>执行如下命令，把u-boot弄到SD卡开头预留的那段空间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo dd <span class="k">if</span><span class="o">=</span>u-boot.imx <span class="nv">of</span><span class="o">=</span>/dev/sdb  <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">seek</span><span class="o">=</span><span class="m">2</span> <span class="p">;</span>sync
</code></pre></td></tr></table>
</div>
</div><p></p>
<p><a href="http://blog.csdn.net/pugu12/article/details/47047341" target="_blank" rel="noopener noreffer">dd命令的解释</a>，至于为什么要seek=2，跳过头两个块我现在也不懂</p>
<h4 id="内核">内核</h4>
<p>把编译好的内核的两个文件zImage和imx6dl-blurr.dtb复制到第一个分区，可以直接鼠标操作</p>
<p></p>
<h4 id="根文件系统">根文件系统</h4>
<p>先 fdisk -l 查看第二个分区的位置，是/dev/sdb2。把第二个分区挂载到/mnt下，这里执行成功后把文件放到/mnt下就相当于放到了U盘第二个分区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo mount /dev/sdb2 /mnt
</code></pre></td></tr></table>
</div>
</div><p>然后就在rootfs的当前目录用cp命令复制，意思是将根文件系统的所有内容复制到挂载的目录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo cp -rf rootfs/.  /mnt
</code></pre></td></tr></table>
</div>
</div><p>执行完有必要的话取消挂载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo umount /mnt
</code></pre></td></tr></table>
</div>
</div><h2 id="6-开发板设置">6. 开发板设置</h2>
<p>确保zImage文件和imx6dl-blurr.dtb文件都已放入SD卡第一个分区，也就是FAT格式的分区中；文件系统解压到SD卡第二个分区，也就是ext4格式的分区中</p>
<p>注：若之前已经进行到屏幕上出现两只企鹅，此时只需要将解压好文件系统的SD卡插入开发板，上电即可进入命令行界面，若无法进入命令行界面则继续进行下列步骤，</p>
<ol>
<li>
<p>靠近 HDMI接口的地方有个开关，拨动开关到boot一端，设置八位红色开关为0100001</p>
<p></p>
</li>
<li>
<p>将SD卡插入SD3插槽</p>
</li>
<li>
<p>下好窗口调试软件putty（windows或Linux下都可），其它串口调试软件也行，用数据线连接开发板和PC（调试），开发板与屏幕，开发板与电源，开发板与键盘</p>
</li>
<li>
<p>打开设备管理器，找到这个设备，这时候还没有驱动，所以右键更新驱动程序，在网络上查找，第一次可能一直是寻找中，那就关掉重新打开。直到驱动装好，从设备管理器里就可以看到相应的COM口。</p>
</li>
<li>
<p>打开putty，选择serial，将COM1改成上面设备管理器里看到的COM号，speed改为115200，然后最下面点open</p>
<p></p>
</li>
<li>
<p>此时看到串口输出（若没有，请按开发板HDMI口旁边的RESET按钮），按回车进入调试模式，输入如下命令命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">setenv bootargs <span class="s1">&#39;console=ttymxc0,115200 root=/dev/mmcblk2p2 init=/sbin/init&#39;</span>
saveenv
<span class="c1">#加载镜像</span>
fatload mmc 1:1 <span class="m">12000000</span> zImage<span class="p">;</span> <span class="c1">#将SD卡分区一的镜像加载到内存地址0x12000000</span>
fatload mmc 1:1 <span class="m">11000000</span> imx6dl-blurr.dtb<span class="p">;</span>
<span class="c1">#加载Device Tree文件</span>
<span class="c1">#启动镜像</span>
bootz <span class="m">12000000</span> - <span class="m">11000000</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
</li>
</ol>
<p>开发板上电，如果SD卡中此时只有u-boot和内核，屏幕上会有两只企鹅，</p>
<p></p>
<p>如果根文件系统也已经放进去了，那就会出现登录选项，连接键盘与开发板，输入root，这个是拿到的这个根文件系统就是这个名字，之后即可使用键盘输入各种命令与开发板交互。在命令行使用如下命令可以启动 GUI，然后就进入KDE桌面环境了，Debian系统哦</p>
<p></p>
<p>注：开发板获得读写权限的方法如下，如果模拟器中已完成此工作则不需要</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ mount rw -o remount /
</code></pre></td></tr></table>
</div>
</div><h2 id="7-使用界面">7. 使用界面</h2>
<p></p>
<p></p>
<h2 id="8-参考">8. 参考</h2>
<ol>
<li>
<p><a href="http://www.cnblogs.com/qiaoqiao2003/p/3738552.html" target="_blank" rel="noopener noreffer">debian下为arm开发板创建基于debian或emdebian的根文件系统</a></p>
<p>这篇文章主要是提供一个思路，用工具来制作Debian的根文件系统。</p>
</li>
<li>
<p><a href="http://blog.csdn.net/luoqindong/article/details/42737879" target="_blank" rel="noopener noreffer">创建基于arm的debian文件系统</a></p>
<p>主要是因为上面制作的根文件系统直接弄到板子上没网，所以就没法用板子的命令行安装软件，只好借助模拟器在PC上装好一些东西，比如GUI和其它一些软件。这篇文章提供一些模拟器QWMU使用的借鉴</p>
</li>
<li>
<p><a href="http://www.emdebian.org/emdebian/flavours.html" target="_blank" rel="noopener noreffer">Emdebian</a></p>
<p>这个就没什么了，主要是区别一下我们用到的嵌入式Debian的源码版本</p>
</li>
</ol>
]]></description></item><item><title>内核配置</title><link>https://shuzang.github.io/linux-lernel-configuration/</link><pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/linux-lernel-configuration/</guid><description><![CDATA[<p>内核配置的目的主要是裁剪掉不必要的文件和目录，获得一个最适用的操作系统。可通过执行下面的命令进入配置窗口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ make menuconfig
</code></pre></td></tr></table>
</div>
</div><p>执行完毕后显示一个基于文本的图形化终端配置菜单，这是是使用最广的配置方法，如果一个.config文件已经存在，它将使用该文件设置那些默认值</p>
<h2 id="1-启动内核配置窗口">1. 启动内核配置窗口</h2>
<p>进入需要被配置的内核的根目录，使用 <code>make menuconfig</code> 命令启动内核配置窗口，如下图</p>
<p></p>
<p>最上面的标题栏里，.config是核心功能列表档，我们现在就是在对这个文件做处理；x86是我的电脑CPU架构，4.1.15是我现在要配置的这个内核的版本</p>
<p>整个界面的用法大概是这样：</p>
<ol>
<li>
<p>左右方向键：可以移动最底下的 项目；</p>
</li>
<li>
<p>上下方向键：可以移动上面框里的蓝色光柱选择选项，该行有箭头 (&mdash;&gt;) 则表示该行内部还有其他细项需要来配置的意思；</p>
</li>
<li>
<p>选定项目：以上下方向键选择好想要配置的项目之后，以左右方向键选择， 按下回车就可以进入该项目去作更进一步的细节配置；</p>
</li>
<li>
<p>可挑选功能：在细节项目的配置当中，如果前面有 <i class="far fa-square fa-fw"></i> 或 &lt; &gt; 符号时，该项目才可以选择， 而选择使用空格键；</p>
</li>
<li>
<p>若为 [<em>] &lt;</em>&gt; 则表示编译进核心；若为则表示编译成模块。</p>
</li>
</ol>
<p>配置时可以遵循这样的原则：</p>
<ol>
<li>一定用的功能，编译进核心；</li>
<li>未来可能用到的功能，尽量编译为模块</li>
<li>不知道用来做什么的功能，看help也看不懂，保留默认值，或者编译为模块</li>
</ol>
<h2 id="2-具体配置">2. 具体配置</h2>
<p>关于内核配置主选项的记录丢失，只剩关于 General setup 部分的记录。与 Linux 最相关的程序互动、核心版本说明、是否使用发展中程序码等资讯都在该部分配置的。 这里的项目主要都是针对核心与程序之间的相关性来设计的，基本上，保留默认值即可！ 不要随便取消底下的任何一个项目，因为可能会造成某些程序无法被同时运行的困境！ 不过底下有非常多新的功能，如果有不清楚的地方，可以按<code>&lt;help&gt;</code>进入查阅，里面会有一些建议！ 你可以依据 Help 的建议来选择新功能的启动与否！</p>
<p></p>
<p><strong>cross-compiler tool prefix</strong></p>
<p>交叉编译工具前缀，功能是make时自动使用交叉编译器进行编译。比如在这儿填上<em>arm-linux</em>，相当与编译时使用*make CROSS_COMPILE=arm-linux-*命令。如果你不想自动使用交叉编译工具，此处应该留空</p>
<p><strong>compile also drivers which will not load</strong></p>
<p>编译驱动程序将不加载，一些驱动可能在其它的编译平台被编译，而这个编译平台跟它的期望运行平台不一样（好像就是交叉编译。。），所以即使这些驱动不能在编译平台加载运行，一些开发者仍然可能想要构建这个驱动来进行编译测试（就是看看它到底能不能编译通过，没打算让它运行么）所以，根据你的需求来选择好了，这个一般是不选。</p>
<p><strong>Local version - append to kernel release</strong></p>
<p>附加一段自定义字符串在内核的版本后面，当你使用uname命令的时候，这段字符串会显示在原本的输出后面，这个就是用来玩的吧。最大支持64个字符，看了一下我的</p>
<p></p>
<p><strong>Automatically append version information to the version string</strong></p>
<p>这个选项会通过查找内核目录下的git标签来自动检测内核目录下是否包含git版本树信息，如果找到的话，就会在上面设置的自定义字符串后边自动添加“-gxxxxxxxx”这种格式的后缀。需要有git的支持。也是个可有可无的选项</p>
<p><strong>Kernel compression mode ( ) &mdash;&gt;</strong></p>
<p>这儿是选择内核的压缩格式，回车进去可以看到，有Gzip,Bzip2,LZMA,XZ,LZ0,LZ4，一般情况下选哪一个都可以，如果不确定到底选哪个的话，官方推荐Gzip</p>
<p></p>
<p><strong>Default hostname</strong></p>
<p>在这儿设置默认的主机名，在你的用户空间程序使用系统调用sethostname来修改主机名之前，内核将使用你在这儿设置的默认主机名。这儿的默认值是“(none)”，这儿保持默认就好，反正没什么意义，系统启动之后肯定要修改主机名的，那时会将主机名改为/etc/hostname下的设置</p>
<p><strong>Support for paging of anonymous memory (swap)</strong></p>
<p>通过分页、交换区等机制来实现虚拟内存，通俗的理解成是对swap区的支持也可以，总之，这个选项是你必选的，没有MMU的cpu除外</p>
<p><strong>System V IPC</strong></p>
<p>system V进程间通信支持，这个必选，这样应用程序才能使用内核提供的各种通信机制进行进程间通信。syetem V IPC包括消息队列，信号量，共享内存等</p>
<p><strong>POSIX Message Queues</strong></p>
<p>POSIX消息队列支持，POSIX消息队列是一种进程通信机制， 在POSIX消息队列中，每一个消息有一个优先级。如果你想要编译运行像mq_*这样子的函数（一般是为Solaris系统而写的程序），那么你需要选上此项</p>
<p><strong>Enable process_vm_readv/writev syscalls</strong></p>
<p>启用此选项可添加系统调用process_vm_read 和process_vm_writev，这些进程允许具有正确p的进程直接从另一进程的地址读取或写入另一个进程的地址</p>
<p><strong>Open By Fhandle Syscalls</strong></p>
<p>如果你选上此项，意味着一个用户空间的应用程序将能够映射一个文件句柄到一个文件名，然后通过这个文件句柄来操作这个文件，这个特性对用户空间文件服务器很有用，就是说开启此选项后，可以使用句柄来追踪一个文件，这样即使文件被重命名，程序依然可以通过句柄来定位这个文件。这个选项会开启内核对open_by_handle_at()和name_to_handle_at这两个系统调用的支持</p>
<p><strong>uselib syscall</strong></p>
<p>此选项启用了uselib系统调用，这是从libc5和更早版本在动态链接器中使用的系统调用。 glibc不使用此系统调用。 如果您打算运行基于libc5或更早版本的程序，则可能需要启用此系统调用。 运行glibc的当前系统可以安全地禁用此功能。现在还有更早版本的吗，可以取消掉吧</p>
<p><strong>Auditing support</strong></p>
<p>内核审计支持，其它的一些内核子系统可能需要使用这个功能，比如SELinux</p>
<p><strong>Eanble system-call auditing support</strong></p>
<p>使能对low-overhead (低开销？) 系统调用的审计支持，这个功能可以单独使用，也可以被系统中其他的内核子系统使用，比如SELinux</p>
<p><strong>IRQ subsystem &mdash;&gt;</strong></p>
<p>中断请求子系统，回车进去只有一个选项：</p>
<p>Expose hardware/virtual IRQ mapping via debugfs</p>
<p>这个选项可以让你通过debugfs中的irq_domain_mapping文件来获得硬件的中断请求号和Linux中的中断请求号之间的映射关系。一般只在内核调试时候使用，help解释如果你听不懂上面的那些名词，说明你不需要开启这个选项，好吧，其实我能看懂的没几个。。。</p>
<p><strong>Timers subsystem &mdash;&gt;</strong></p>
<p>内核时钟子系统，回车进去三个选项：</p>
<p>1）Timer tick handling (Idle dynticks system (tickless idle))&mdash;&gt;</p>
<p>定时器滴答处理程序，这儿有三个选择，下面分别介绍</p>
<p>第一种：Periodic timer ticks (constant rate, no dynticks)</p>
<p>以固定周期触发时钟中断，无论CPU是否需要，不使用动态定时器（dyniticks），这是最耗电的方式，不推荐使用。</p>
<p>第二种：Idle dynticks system (tickless idle)</p>
<p>在CPU空闲时不产生不触发的时钟中断，可以省电</p>
<p>第三种：Full dynticks system (tickless)</p>
<p>使用动态定时器，即使CPU在忙碌状态，也尽可能的关闭所有时钟中断，这个特性很早就有但是直到3.10版本才完整支持DynTicks（动态定时器），并成为内核级别的核心特性，tickless适用于CPU在同一时间内只运行一个任务，或者用户空间程序极少与内核交互的场合，但是即使你选择了tickless，仍然需要额外设置‘nohz_full=?’的内核参数才能是tickless真正生效</p>
<p>所以。。意思就是一般选第二个咯</p>
<p>2）Old Idle dynticks config</p>
<p>这个选项是Idle dynticks system (tickless idle)旧的入口，此选项被用来保持与旧版本的兼容，未来应该会被删除，但现在为了和上面保持一致还是选了吧</p>
<p>3）High Resolution Timer Suppor</p>
<p>高精度计时器支持，如果你的硬件不能胜任这个选项，那么开启这个选项仅仅是给内核增加体积，高精度定时器（hrtimer）是从2.6.16开始被引入内核，采用红黑树算法（传统timer使用时间轮算法），在硬中断中执行中断服务例程，它可以为我们提供纳秒级的定时精度（这么厉害），以满足对精确时间有迫切需求的应用程序或内核驱动，例如多媒体应用，音频设备的驱动程序等等，额，这个还是选着吧，说不定用板子做什么呢</p>
<p><strong>CPU/Task time and stats accounting &mdash;&gt;</strong></p>
<p>CPU/任务 时间和状态统计</p>
<p>1）Cputime accounting (Simple tick based cputime accounting) &mdash;&gt;</p>
<p>CPU时间统计方式，三种选择：</p>
<p>第一种：Simple tick based cputime acounting</p>
<p>最简单的基于tick统计方式，使用jiffies变量（这个变量记录了系统自启动以来经过的操作系统节拍的数目） 官方推荐：if unsure, say Y(yes)</p>
<p>第二种：Full dynticks CPU time accounting</p>
<p>利用上下文跟踪子系统，通过观察每一个内核与用户空间的边界来统计，如果你不是在帮助开发内核的动态定时器（dynticks）的话，不要选择这个</p>
<p>第三种：Fine granularity task level IRQ time accounting</p>
<p>通过读取TSC时间戳进行CPU时间统计，这是统计CPU时间的更细粒度的方式，对系统性能有显著不良影响 官方推荐：if in doubt , say No</p>
<p>2）BSD Process Accounting</p>
<p>BSD进程记账支持.用户空间程序可以要求内核将进程的统计信息写入一个指定的文件,主要包括进程的创建时间/创建者/内存占用等信息.不确定的选&quot;N&quot;.</p>
<p>3）BSD Process Accounting version 3 file format</p>
<p>使用新的v3版文件格式,可以包含每个进程的PID和其父进程的PID,但是不兼容老版本的文件格式.比如 GNU Accounting Utilities 这样的工具可以识别v3格式</p>
<p>4）Export task/process statistics through netlink</p>
<p>通过netlink接口向用户空间导出进程的统计信息,与 BSD Process Accounting 的不同之处在于这些统计信息在整个进程生存期都是可用的.</p>
<p>5）Enable per-task delay accounting</p>
<p>在统计信息中包含进程等候系统资源(cpu,IO同步,内存交换等)所花费的时间</p>
<p>6）Enable extended accounting over taskstats</p>
<p>在统计信息中包含进程的更多扩展信息.不确定的选&quot;N&quot;.</p>
<p>7）Enable per-task storage I/O accounting</p>
<p>在统计信息中包含进程在存储设备上的I/O字节数.</p>
]]></description></item><item><title>移植相关知识</title><link>https://shuzang.github.io/migration-related-knowledge/</link><pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate><author>作者</author><guid>https://shuzang.github.io/migration-related-knowledge/</guid><description><![CDATA[<h2 id="1-linux-操作系统组成">1. Linux 操作系统组成</h2>
<p>Linux 操作系统由 Linux 内核、shell 命令解释器和应用程序3部分构成</p>
<h3 id="11-shell">1.1 shell</h3>
<p>Linux的内核不能直接接受来自终端的用户命令，shell 为用户提供使用 Linux 操作系统的接口。在Linux 中几乎所有的操作都可以通过命令行来完成，使用 shell 编写的程序称为 shell 脚本。shell 可以作为命令语言、命令解释程序及程序设计语言，用户成功登录Linux时系统自动启用shell，当在终端输入正确的shell命令时，shell通过相应的命令和程序，通过内核执行用户需要的操作。更详细的知识可参考 <a href="https://www.ibm.com/developerworks/cn/linux/l-linux-shells/index.html" target="_blank" rel="noopener noreffer">评估Linux中的shell</a> 一文。</p>
<p></p>
<p>几种 shell 的比较表如下</p>
<table>
<thead>
<tr>
<th>Shell</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bourne Shell</td>
<td>编程方式占优势，但在与用户交互方面比较差</td>
</tr>
<tr>
<td>Bourne - Again Shell</td>
<td>专为 Linux 而写，在 Bourne Shell 基础上增加了功能，是 Linux 默认内核</td>
</tr>
<tr>
<td>C Shell</td>
<td>语法类似于 C 语言，有较高的编程能力</td>
</tr>
<tr>
<td>Tcsh</td>
<td>C shell 的扩展</td>
</tr>
<tr>
<td>Korn Shell</td>
<td>集合了 C shell 和 Bourne shell 的优点</td>
</tr>
</tbody>
</table>
<h3 id="12-linux-内核">1.2 Linux 内核</h3>
<p>Linux 内核是操作系统的核心部分。它由进程管理、文件管理、存储管理、设备管理和网络管理五大部分组成。采用模块化的设计，它的功能也是通过增加和减少模块来实现的。这种设计保证系统封闭和开放与效率的平衡，避免在修剪功能时改变系统结构。</p>
<p>Linux 内核最注重的问题是实用和效率，其特点如下</p>
<ol>
<li>整个 Linux 内核由很多过程组成，每个过程可以独立编译，然后用连接程序将其连接在一起成为一个单独的目标程序。</li>
<li>Linux 的文件系统最大特点是实现了一种抽象文件模型——VFS。使用虚拟文件系统屏蔽了各种不同文件系统的内在差别，使得用户可以使用同样的方式访问各种不同格式的文件系统，可以毫无区别的在不同格式、不同介质的文件系统之间使用 VFS 提供的统一接口交换数据。</li>
<li>为了保证方便的支持新设备、新功能，又不会无限扩大内核规模，Linux 系统对设备驱动或新文件系统等采用了模块化方式，用户在需要时可以动态加载，使用完毕可以动态卸载。同时对内核，用户也可以定制，选择适合自己的功能，将不需要的部分剔除出内核。这两种技术都保证了内核的紧凑性和扩展性。</li>
</ol>
<h2 id="2-u-boot">2. u-boot</h2>
<p>u-boot是在 PPCBOOT 和 ARMBOOT 基础上发展而来的，是一个通用引导程序，支持很多架构，这一点上篇BootLoader已经很明白。u-boot的移植过程是一个对嵌入式系统包括软硬件及操作系统加深理解的一个过程，我们通过这个过程来一点点学习。</p>
<h3 id="21-常用命令">2.1 常用命令</h3>
<p>u-boot在下载模式下，提供了许多有用的命令</p>
<p><strong>环境变量类</strong></p>
<p>printenv：查看环境变量</p>
<p>saveenv：保存当前环境变量</p>
<p>setenv：设置当前环境变量</p>
<p>askenv：在标准输入获得环境变量</p>
<p><strong>存储类</strong></p>
<p>md：显示指定内存地址中的内容</p>
<p>mm：顺序显示指定地址往后内存中的内容，可同时修改，地址自动递增</p>
<p>mw：向内存地址写内容</p>
<p>nm：修改内存地址，地址不递增</p>
<p>mtest：简单的RAM检测</p>
<p><strong>下载类</strong></p>
<p>tftp：将内核镜像文件从PC中下载到SDRAM的指定地址，然后通过bootm来引导内核，前提是所用PC要安装设置TFTP服务</p>
<p>loadb：透过串口下载二进制格式的文件</p>
<p>loads：透过串口下载S-Record格式的文件</p>
<p><strong>启动类</strong></p>
<p>boot：预先设定的启动命令并且启动</p>
<p>bootm：从某个地址启动内核</p>
<p>bootp：通过网络使用bootp或者TFTP协议引导镜像文件</p>
<p>bootelf：默认从0x30008000引导elf格式的文件</p>
<p>bootd（=boot）：引导的默认命令，即运行u-boot中在“include/configs/”板子名.h”中设置的“bootcmd”中的命令</p>
<p><strong>Flash命令</strong></p>
<p>erase：擦除Flash内容，必须以扇区为单位进行擦除</p>
<p>flinfo：查看Flash的信息</p>
<p>help：帮助命令，用于查询u-boot支持的命令</p>
<p>bdinfo：查看目标系统参数和变量，目标板的硬件配置</p>
<p>coninfo：显示控制设备和信息</p>
<p>flinfo：获取Flash存储器的信息</p>
<p>iminfo：打印和校验内核镜像头，内核的起始地址由CFG_LOAD_ADDR指定</p>
<p><strong>Cache类命令</strong></p>
<p>icache：开启和关闭指令Cache</p>
<p>dcachd：开启和关闭数据Cache</p>
<p><strong>其他命令</strong></p>
<p>reset：复位CPU</p>
<p>run：运行已经定义好的u-boot命令</p>
<p>sleep：命令延时执行时间</p>
<p>autoscr：从内存运行脚本</p>
<p>base：打印或者设置当前指令与下载地址的地址偏移</p>
<p>cmp：对输入的两段内存地址进行比较</p>
<p>version：打印u-boot版本信息</p>
<p><strong>Nand相关命令</strong></p>
<p>Nand info：打印Nand Flash信息</p>
<p>Nand device <n>：显示某个Nand设备</p>
<p>Nand erase FLAddr size：FLAddr为Nand Flash起始地址，size为从中擦除数据块的大小</p>
<p>Nand write InAddr FLAddr size ：InAddr为写到Nand Flash中的数据在内存的起始地址</p>
<h3 id="22-u-boot源代码目录结构">2.2 u-boot源代码目录结构</h3>
<p>u-boot主要的源代码目录如下图：</p>
<p></p>
<p>主要目录的作用列一个表如下：</p>
<p></p>
<h3 id="23-u-boot的编译">2.3 u-boot的编译</h3>
<p>u-boot的源码是通过gcc和Makefile组织编译的。顶层目录下的Makefile首先可以设置开发板的定义，然后递归地调用各级子目录下的Makefile，最后把编译过的程序链接成u-boot镜像。</p>
<p>目录下的Makefile看不懂，等学完Makefile再回来看这个吧，这里是一篇<a href="https://hacker-yhj.github.io/resources/gun_make.pdf" target="_blank" rel="noopener noreffer">GNU make 中文手册</a></p>
<h4 id="配置头文件">配置头文件</h4>
<p>除了编译过程Makefile外，还要在程序中为开发板定义配置选项或者参数。这个头文件是include/configs&lt;board_name&gt;.h。&lt;board_name&gt;用相应的BOARD定义代替。</p>
<p>这个头文件中主要定义了两类变量：</p>
<ul>
<li>
<p>选项：前缀是CONFIG_，用来选择处理器、设备接口、命令、属性等</p>
</li>
<li>
<p>参数：前缀是CFG_，用来定义总线频率、串口波特率、Flash地址等参数</p>
</li>
</ul>
<h4 id="编译">编译</h4>
<p>根据对Makefile的分析，编译分为两步：</p>
<p>配置：make smdk2410_config</p>
<p>编译：make</p>
<p>编译完成后，可以得到u-boot各种格式的映像文件和符号表，如下：</p>
<p></p>
<p>u-boot的3中映像格式都可以烧写到Flash中，但需要看加载器能否识别这些格式。u-boot.bin最为常用，直接按照二进制格式下载，并且按照绝对地址烧写到Flash中就可以。</p>
<h4 id="u-boot工具">u-boot工具</h4>
<p>还记得上面列到的tools目录吗，这个目录下存放有u-boot的一些工具，有的工具经常被用到，下面用一个表说明几种工具的用途：</p>
<p></p>
<h3 id="24-u-boot的移植">2.4 u-boot的移植</h3>
<p>为了使u-boot支持新的开发板，一种简便的做法是在u-boot已经支持的开发板中选择一种和目标板接近的，并在其基础上进行修改，代码修改的步骤如下。</p>
<ol>
<li>
<p>在board目录下创建smdk2410目录，添加smdk2410.c、flash.c、memsetup.s、u-boot.lds和config.mk等；</p>
</li>
<li>
<p>在cpu目录下创建arm920t目录，主要包含start.s、interrupts.c、cpu.c、serial.c和speed.c等文件</p>
</li>
<li>
<p>在include/configs目录下添加smdk2410.h，它定义了全局的宏定义等。</p>
</li>
<li>
<p>修改u-boot根目录下的Makefile文件，如下：</p>
<p><code>smdk2410_config：$（@： _config=）arm arm920t smdk2410</code></p>
</li>
<li>
<p>运行 make smdk2410_config，如果没有错误，就可以开始进行与硬件相关的代码移植工作</p>
</li>
</ol>
<h3 id="25-u-boot的使用">2.5 u-boot的使用</h3>
<p>1）烧写u-boot到Flash</p>
<p>新开发板中没有任何程序可执行，也就不能启动，需要先将u-boot烧写到Flash中</p>
<p>如果主板上的EPROM或者Flash能够取下来，就可以通过编程器烧写。计算机BIOS就存储在一块256KB的Flash上，通过插座与主板相连。但是多数嵌入式单板使用贴片的Flash，不能取下来烧写。这种情况可以通过处理器的调试接口，直接对板上的Flash编程。</p>
<p>处理器调试接口是为处理器芯片设计的标准调试接口，包含BDM，JTAG和EJTAG 3中接口标准。这3种硬件接口标准定义有所不同，但是功能基本相同，下面都统称为JTAG接口。</p>
<p>JTAG接口需要专用的硬件工具来连接，无论从功能、性能角度，还是从价格角度，这些工具都有很大差异。最简单方式就是通过JTAG电缆，转接到计算机并口连接。这需要在主机端开发烧写程序，还需要有并口设备驱动程序。开发板上电或复位时，烧写程序探测到处理器并且开始通信，然后把BootLoader下载并烧写到Flash中。</p>
<p>烧写完成后，复位开发板，串口终端应该显示u-boot启动信息。</p>
<p></p>
<p>2）u-boot的环境变量</p>
<p>可通过printenv命令查看环境变量设置，前面介绍过这些命令</p>
<p></p>
<p>下表列出一些常用的环境变量的含义解释</p>
<p></p>
<p>u-boot的环境变量都可以有默认值，也可以修改并且保存在参数区。u-boot的参数区一般有EEPROM和Flash两种设备。</p>
<h2 id="3-交叉编译">3. 交叉编译</h2>
<p>因为对这方面可以说是完全不了解，所以凭现有的知识提出来的问题大概是这么几个，至于学习过程中产生的新的问题，就到时候再解决：</p>
<p>1、交叉编译是什么以及为什么需要交叉编译</p>
<p>2、怎么得到这个交叉编译环境</p>
<p>3、怎么使用这个交叉编译环境</p>
<h3 id="31-交叉编译简介">3.1 交叉编译简介</h3>
<p>交叉编译，就是在一种平台上（称为宿主机）开发编译，编译出来的程序，在别的平台上（称为目标机）运行，即编译的环境和运行的环境是不一样的、交叉的，而程序的调试需要通过宿主机和目标机之间的协作来交互进行。交叉编译这个概念，主要和嵌入式开发有关，英文称为cross compile。这和我们平常在X86的电脑上开发、编译可执行程序，然后直接在X86环境下运行是相对的。</p>
<p>一种最常见的例子就是：在进行嵌入式开发时，手上有个嵌入式开发板，CPU是arm的，然后在x86的平台下开发，比如Ubuntu环境，然后就需要在x86的平台上，（用交叉编译器）去编译写好的程序代码，生成的（可执行的）程序是放到目标开发板—arm的CPU上运行的，即在x86平台上编译，在ARM平台上运行。</p>
<p>至于为什么需要交叉编译，有两点</p>
<ol>
<li>嵌入式系统硬件资源的限制，比如cpu主频相对较低，内存容量较小等，相对来说，pc机的速度更快，硬件资源更加丰富，因此利用pc机进行开发会提高开发效率。这是一直以来的说法，不过，现在嵌入式的硬件主频和内存这些资源都不算小了，个人觉得可以直接放在开发板上做本地编译。</li>
<li>嵌入式系统MCU体系结构和指令集不同，因此需要安装交叉编译工具进行编译，这样编译的目标程序才能够在相应的平台上比如：ARM、MIPS、POWEPC上正常运行。</li>
</ol>
<h3 id="32-交叉工具链简介">3.2 交叉工具链简介</h3>
<p>我们要完成的目标是生成可执行程序或库文件，为了达成此目标，内部的执行过程和逻辑主要包括：</p>
<ol>
<li>编译：编译的输入是程序代码，输出是目标文件，使用的工具叫编译器，常见的编译器如gcc</li>
<li>链接：链接的输入为程序运行时所依赖的或者某个库所依赖的另外一个库（文件），链接的输出为程序的可执行文件，或者是可以被别人调用的完整的库文件。链接使用的工具叫链接器，最常见的链接器是ld</li>
</ol>
<p>实际上，ld只是处理目标文件（二进制文件）最主要的一个工具，相关的还有很多其他工具，如as, objcopy, strip, ar等，对此，GNU官网弄出一个binutils，即binary utils，二进制工具（包），集成了所有这些和操作二进制相关的工具集合。关于这个东西，详见<a href="https://www.crifan.com/files/doc/docbook/binutils_intro/release/html/binutils_intro.html" target="_blank" rel="noopener noreffer">GNU Binutils详解</a>，而对于常用的列一个表给大家看一下：</p>
<p></p>
<p>把上面设计到的一系列工具，按照对应的逻辑功能，编译、链接、后期其它处理等等，串起来，就是工具链。</p>
<p>而用于交叉编译的工具链就是交叉工具链。里面包含了很多工具，但是最主要的是用于编译的gcc，所以常把交叉工具链称为交叉编译器。那我们平常说的交叉编译版本的gcc，比如arm-linux-gcc，实际上指代了包含一系列交叉编译版本的交叉工具链（arm-linux-gcc，arm-linux-ld，arm-linux-as等等）</p>
<h3 id="33-交叉编译器">3.3 交叉编译器</h3>
<h4 id="命名规则">命名规则</h4>
<p>在嵌入式开发用到交叉编译器的时候，常看到这样的名字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">arm-xscale-linux-gnueabi-gcc
arm-liunx-gnu-gcc
</code></pre></td></tr></table>
</div>
</div><p>其对应的交叉编译器前缀为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">arm-xscale-linux-gnueabi-
arm-liunx-gnu-
</code></pre></td></tr></table>
</div>
</div><p>命名规则为：$arch-vendor-kernel-system$，各部分解释如下</p>
<p><strong>arch</strong>：系统架构，表示交叉编译器是用于那个目标系统架构的，哪个平台的，即用此交叉编译器编译出来的程序运行在哪种CPU上，可能是arm，x86，mips等</p>
<p><strong>vendor</strong>：即生产厂家，提供商，表示谁做的这个交叉编译器，一般有这么几种情况，一是写成开发板的名字，比如cortex_a9；二是写成个人作者自己的名字；三是厂家的名字。</p>
<p><strong>kernel</strong>：即用此交叉编译器编译出来的程序所运行的目标系统，主要有两种：一种是<em>Linux</em>，表示有OS（主要是Linux）的环境；另一种是<em>bare-metal</em>，表示无操作系统的环境，比如编译u-boot，运行时还没OS，比如一些跑马灯之类的小程序。</p>
<p><strong>system</strong>：表示交叉编译器所选择的库函数和目标系统，最常见的值有gnu，gnueabi，uclibcgnueabi等。</p>
<ul>
<li>
<p>gnu：表示用的是glibc的意思</p>
</li>
<li>
<p>eabi：embedded application binary interface，应用程序二进制接口，作用是使得程序的二进制（级别）的兼容</p>
</li>
<li>
<p>uclibc：C库的一种，专门为嵌入式环境开发而编写的一个自由软件包，可以提供绝大多数标准C库的函数支持</p>
</li>
</ul>
<p>一个简单通俗的解释为：gnu      等价于    glibc+oabi，gnueabi  等价于    glibc+eabi，uclibc    等价于    uclibc+oabi（待确认）</p>
<h4 id="如何获得">如何获得</h4>
<p>1）在网上寻找并下载别人已经编译好的交叉编译器</p>
<p>2）购买开发板时厂家会直接提供相应的交叉编译器</p>
<p>3）自己动手从头开始制作一个交叉编译器</p>
<p>4）借助一些工具来制作交叉编译器</p>
<h4 id="制作工具">制作工具</h4>
<ol>
<li><a href="http://crosstool-ng.org/" target="_blank" rel="noopener noreffer">crosstool-NG</a>：详细的可以看看这篇<a href="https://www.crifan.com/files/doc/docbook/crosstool_ng/release/html/crosstool_ng.html" target="_blank" rel="noopener noreffer">crosstool-ng详解</a></li>
<li><a href="http://www.buildroot.net/" target="_blank" rel="noopener noreffer">Buildroot</a>不仅能制作交叉工具链，而且还可以制作根文件系统rootfs。而且还支持同时编译对应的Linux内核和Uboot。</li>
<li><a href="http://kegel.com/crosstool/" target="_blank" rel="noopener noreffer">crosstool</a>现在用的最多的是0.43的版本：</li>
<li><a href="http://www.denx.de/wiki/DULG/ELDK" target="_blank" rel="noopener noreffer">Embedded Linux Development Kit (ELDK)</a>：也是和交叉编译相关的，提供编译好的东西供使用。</li>
<li><a href="http://www.openembedded.org/wiki/Main_Page" target="_blank" rel="noopener noreffer">OpenEmbedded</a>的<a href="http://en.wikipedia.org/wiki/BitBake" target="_blank" rel="noopener noreffer">BitBake</a>：OpenEmbedded是一个创建嵌入式Linux的整套框架，其中包括了制作对应的交叉编译器的工具，叫做BitBake。OpenEmbedded简称OE。</li>
<li>Crossdev</li>
<li><a href="http://www.pengutronix.de/oselas/toolchain/index_en.html" target="_blank" rel="noopener noreffer">OSELAS.Toolchain()</a></li>
</ol>
]]></description></item></channel></rss>